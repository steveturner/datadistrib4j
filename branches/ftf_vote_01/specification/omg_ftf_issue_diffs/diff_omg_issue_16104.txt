
Property changes on: ftf_vote_01
___________________________________________________________________
Added: svn:mergeinfo
   Merged /trunk:r104-115

Index: ftf_vote_01/srcJava/org/omg/dds/type/TypeSupport.java
===================================================================
--- ftf_vote_01/srcJava/org/omg/dds/type/TypeSupport.java	(revision 139)
+++ ftf_vote_01/srcJava/org/omg/dds/type/TypeSupport.java	(working copy)
@@ -22,6 +22,14 @@
 import org.omg.dds.core.DDSObject;
 
 
+/**
+ * TypeSupport is an abstract interface that has to be specialized for each
+ * concrete type that will be used by the application to publish and/or
+ * subscribe to data over DDS.
+ * 
+ * @param <TYPE>    The type to be supported for publication and/or
+ *                  subscription.
+ */
 public abstract class TypeSupport<TYPE> implements DDSObject
 {
     // -----------------------------------------------------------------------
@@ -82,5 +90,9 @@
     // Instance Methods
     // -----------------------------------------------------------------------
 
+    /**
+     * @return  the registered name for the data type represented by the
+     *          TypeSupport.
+     */
     public abstract String getTypeName();
 }
Index: ftf_vote_01/srcJava/org/omg/dds/pub/PublisherListener.java
===================================================================
--- ftf_vote_01/srcJava/org/omg/dds/pub/PublisherListener.java	(revision 139)
+++ ftf_vote_01/srcJava/org/omg/dds/pub/PublisherListener.java	(working copy)
@@ -20,12 +20,18 @@
 
 import java.util.EventListener;
 
+import org.omg.dds.core.Entity;
 import org.omg.dds.core.status.LivelinessLostStatus;
 import org.omg.dds.core.status.OfferedDeadlineMissedStatus;
 import org.omg.dds.core.status.OfferedIncompatibleQosStatus;
 import org.omg.dds.core.status.PublicationMatchedStatus;
 
 
+/**
+ * Since a {@link Publisher} is a kind of {@link Entity}, it has the ability
+ * to have a listener associated with it. In this case, the associated
+ * listener must be of concrete type PublisherListener.
+ */
 public interface PublisherListener extends EventListener {
     public void onOfferedDeadlineMissed(
             OfferedDeadlineMissedStatus<?> status);
Index: ftf_vote_01/srcJava/org/omg/dds/pub/package-info.java
===================================================================
--- ftf_vote_01/srcJava/org/omg/dds/pub/package-info.java	(revision 139)
+++ ftf_vote_01/srcJava/org/omg/dds/pub/package-info.java	(working copy)
@@ -1,6 +1,6 @@
 /**
- * The Publication Module contains the {@link Publisher }and
- * {@link DataWriter} interfaces as well as the {@link PublisherListener }and
+ * The Publication Module contains the {@link Publisher} and
+ * {@link DataWriter} interfaces as well as the {@link PublisherListener} and
  * {@link DataWriterListener} interfaces, and more generally, all that is
  * needed on the publication side.
  */
Index: ftf_vote_01/srcJava/org/omg/dds/pub/DataWriter.java
===================================================================
--- ftf_vote_01/srcJava/org/omg/dds/pub/DataWriter.java	(revision 139)
+++ ftf_vote_01/srcJava/org/omg/dds/pub/DataWriter.java	(working copy)
@@ -25,16 +25,47 @@
 import org.omg.dds.core.DomainEntity;
 import org.omg.dds.core.Duration;
 import org.omg.dds.core.InstanceHandle;
+import org.omg.dds.core.NotEnabledException;
+import org.omg.dds.core.OutOfResourcesException;
+import org.omg.dds.core.PreconditionNotMetException;
 import org.omg.dds.core.Time;
 import org.omg.dds.core.modifiable.ModifiableInstanceHandle;
+import org.omg.dds.core.policy.DestinationOrderQosPolicy;
+import org.omg.dds.core.policy.HistoryQosPolicy;
+import org.omg.dds.core.policy.LivelinessQosPolicy;
+import org.omg.dds.core.policy.OwnershipQosPolicy;
+import org.omg.dds.core.policy.ReliabilityQosPolicy;
+import org.omg.dds.core.policy.ResourceLimitsQosPolicy;
 import org.omg.dds.core.status.LivelinessLostStatus;
 import org.omg.dds.core.status.OfferedDeadlineMissedStatus;
 import org.omg.dds.core.status.OfferedIncompatibleQosStatus;
 import org.omg.dds.core.status.PublicationMatchedStatus;
+import org.omg.dds.domain.DomainParticipant;
+import org.omg.dds.sub.DataReader;
+import org.omg.dds.sub.InstanceState;
+import org.omg.dds.sub.Sample;
 import org.omg.dds.topic.SubscriptionBuiltinTopicData;
 import org.omg.dds.topic.Topic;
 
 
+/**
+ * DataWriter allows the application to set the value of the data to be
+ * published under a given {@link Topic}.
+ * 
+ * A DataWriter is attached to exactly one {@link Publisher} that acts as a
+ * factory for it. A DataWriter is bound to exactly one Topic and therefore
+ * to exactly one data type. The Topic must exist prior to the DataWriter's
+ * creation.
+ * 
+ * All operations except for the inherited operations
+ * {@link #setQos(org.omg.dds.core.EntityQos)}, {@link #getQos()},
+ * {@link #setListener(java.util.EventListener)},{@link #getListener()},
+ * {@link #enable()}, {@link #getStatusCondition()}, and {@link #close()} may
+ * fail with the exception {@link NotEnabledException}.
+ * 
+ * @param <TYPE>    The concrete type of the data to be published over the
+ *                  the topic.
+ */
 public interface DataWriter<TYPE>
 extends DomainEntity<DataWriter<TYPE>,
                      Publisher,
@@ -56,61 +87,502 @@
      */
     public <OTHER> DataWriter<OTHER> cast();
 
+    /**
+     * @return  the {@link Topic} associated with the DataWriter. This is the
+     *          same Topic that was used to create the DataWriter.
+     */
     public Topic<TYPE> getTopic();
 
+    /**
+     * This operation is intended to be used only if the DataWriter has
+     * {@link ReliabilityQosPolicy#getKind()} set to
+     * {@link ReliabilityQosPolicy.Kind#RELIABLE}. Otherwise the operation
+     * will return immediately.
+     * 
+     * The operation blocks the calling thread until either all data written
+     * by the DataWriter is acknowledged by all matched {@link DataReader}
+     * entities that have {@link ReliabilityQosPolicy#getKind()} set to
+     * {@link ReliabilityQosPolicy.Kind#RELIABLE}, or else the duration
+     * specified by the maxWait parameter elapses, whichever happens first.
+     * 
+     * A normal return indicates that all the samples written have been
+     * acknowledged by all reliable matched data readers.
+     * 
+     *  @throws TimeoutException    if maxWait elapsed before all the data
+     *          was acknowledged.
+     */
     public void waitForAcknowledgments(Duration maxWait)
     throws TimeoutException;
 
+    /**
+     * This operation is intended to be used only if the DataWriter has
+     * {@link ReliabilityQosPolicy#getKind()} set to
+     * {@link ReliabilityQosPolicy.Kind#RELIABLE}. Otherwise the operation
+     * will return immediately.
+     * 
+     * The operation blocks the calling thread until either all data written
+     * by the DataWriter is acknowledged by all matched {@link DataReader}
+     * entities that have {@link ReliabilityQosPolicy#getKind()} set to
+     * {@link ReliabilityQosPolicy.Kind#RELIABLE}, or else the duration
+     * specified by the maxWait parameter elapses, whichever happens first.
+     * 
+     * A normal return indicates that all the samples written have been
+     * acknowledged by all reliable matched data readers.
+     * 
+     *  @throws TimeoutException    if maxWait elapsed before all the data
+     *          was acknowledged.
+     */
     public void waitForAcknowledgments(long maxWait, TimeUnit unit)
     throws TimeoutException;
 
+    /**
+     * This operation allows access to the LIVELINESS_LOST communication
+     * status.
+     * 
+     * @param   status  a container, into which this method will place its
+     *                  result.
+     * @return  the input status, as a convenience to facilitate chaining.
+     * 
+     * @see     org.omg.dds.core.status
+     */
     public LivelinessLostStatus<TYPE> getLivelinessLostStatus(
             LivelinessLostStatus<TYPE> status);
 
+    /**
+     * This operation allows access to the OFFERED_DEADLINE_MISSED
+     * communication status.
+     * 
+     * @param   status  a container, into which this method will place its
+     *                  result.
+     * @return  the input status, as a convenience to facilitate chaining.
+     * 
+     * @see     org.omg.dds.core.status
+     */
     public OfferedDeadlineMissedStatus<TYPE> getOfferedDeadlineMissedStatus(
             OfferedDeadlineMissedStatus<TYPE> status);
 
+    /**
+     * This operation allows access to the OFFERED_INCOMPATIBLE_QOS
+     * communication status.
+     * 
+     * @param   status  a container, into which this method will place its
+     *                  result.
+     * @return  the input status, as a convenience to facilitate chaining.
+     * 
+     * @see     org.omg.dds.core.status
+     */
     public OfferedIncompatibleQosStatus<TYPE> getOfferedIncompatibleQosStatus(
             OfferedIncompatibleQosStatus<TYPE> status);
 
+    /**
+     * This operation allows access to the PUBLICATION_MATCHED
+     * communication status.
+     * 
+     * @param   status  a container, into which this method will place its
+     *                  result.
+     * @return  the input status, as a convenience to facilitate chaining.
+     * 
+     * @see     org.omg.dds.core.status
+     */
     public PublicationMatchedStatus<TYPE> getPublicationMatchedStatus(
             PublicationMatchedStatus<TYPE> status);
 
+    /**
+     * This operation manually asserts the liveliness of the DataWriter. This
+     * is used in combination with the {@link LivelinessQosPolicy} to
+     * indicate to the Service that the entity remains active.
+     * 
+     * This operation need only be used if
+     * {@link LivelinessQosPolicy#getKind()} is either
+     * {@link LivelinessQosPolicy.Kind#MANUAL_BY_PARTICIPANT} or
+     * {@link LivelinessQosPolicy.Kind#MANUAL_BY_TOPIC}. Otherwise, it has
+     * no effect.
+     * 
+     * <b>Note</b> - Writing data via {@link #write(Object)} asserts
+     * liveliness on the DataWriter itself and its DomainParticipant.
+     * Consequently the use of assertLiveliness is only needed if the
+     * application is not writing data regularly.
+     */
     public void assertLiveliness();
 
+    /**
+     * This operation retrieves the list of subscriptions currently
+     * "associated" with the DataWriter; that is, subscriptions that have a
+     * matching {@link Topic} and compatible QoS that the application has not
+     * indicated should be "ignored" by means of
+     * {@link DomainParticipant#ignoreSubscription(InstanceHandle)}.
+     * 
+     * The handles returned in the 'subscriptionHandles' list are the ones
+     * that are used by the DDS implementation to locally identify the
+     * corresponding matched {@link DataReader} entities. These handles match
+     * the ones that appear in {@link Sample#getInstanceHandle()} when
+     * reading the "DCPSSubscriptions" built-in topic.
+     * 
+     * The operation may fail if the infrastructure does not locally maintain
+     * the connectivity information.
+     * 
+     * @param   subscriptionHandles     a container, into which this method
+     *          will place its result.
+     * 
+     * @return  subscriptionHandles, as a convenience to facilitate chaining.
+     * 
+     * @see     #getMatchedSubscriptionData(SubscriptionBuiltinTopicData, InstanceHandle)
+     */
     public Collection<InstanceHandle> getMatchedSubscriptions(
             Collection<InstanceHandle> subscriptionHandles);
+
+    /**
+     * This operation retrieves information on a subscription that is
+     * currently "associated" with the DataWriter; that is, a subscription
+     * with a matching {@link Topic} and compatible QoS that the application
+     * has not indicated should be "ignored" by means of
+     * {@link DomainParticipant#ignoreSubscription(InstanceHandle)}.
+     * 
+     * The operation {@link #getMatchedSubscriptions(Collection)} can be used
+     * to find the subscriptions that are currently matched with the
+     * DataWriter.
+     * 
+     * @param   subscriptionData        a container, into which this method
+     *          will place its result.
+     * @param   subscriptionHandle      a handle to the subscription, the
+     *          data of which is to be retrieved.
+     * 
+     * @return  subscriptionData, as a convenience to facilitate chaining.
+     * 
+     * @throws  IllegalArgumentException        if subscriptionHandle does
+     *          not correspond to a subscription currently associated with
+     *          the DataWriter.
+     * @throws  UnsupportedOperationException   if the infrastructure does
+     *          not hold the information necessary to fill in the
+     *          subscriptionData.
+     *
+     * @see     #getMatchedSubscriptions(Collection)
+     */
     public SubscriptionBuiltinTopicData getMatchedSubscriptionData(
             SubscriptionBuiltinTopicData subscriptionData,
             InstanceHandle subscriptionHandle);
 
 
     // --- Type-specific interface: ------------------------------------------
+
+    /**
+     * This operation informs the Service that the application will be
+     * modifying a particular instance. It gives an opportunity to the
+     * Service to pre-configure itself to improve performance.
+     * 
+     * It takes as a parameter an instance (to get the key value) and returns
+     * a handle that can be used in successive {@link #write(Object)} or
+     * {@link #dispose(InstanceHandle)} operations.
+     * 
+     * This operation should be invoked prior to calling any operation that
+     * modifies the instance.
+     * 
+     * A nil handle may be returned by the Service if it does not want to
+     * allocate any handle for that instance.
+     * 
+     * This operation may block and exit with {@link TimeoutException} under
+     * the same circumstances described for the {@link #write(Object)}.
+     * 
+     * The operation is idempotent. If it is called for an already registered
+     * instance, it just returns the already allocated handle. This may be
+     * used to lookup and retrieve the handle allocated to a given instance.
+     * The explicit use of this operation is optional as the application may
+     * call directly the write operation and specify a nil handle to indicate
+     * that the 'key' should be examined to identify the instance.
+     * 
+     * @throws  OutOfResourcesException under the same circumstances
+     *          described for {@link #write(Object)}.
+     * @throws  TimeoutException        under the same circumstances
+     *          described for {@link #write(Object)}.
+     * 
+     * @see     #registerInstance(Object, Time)
+     * @see     #registerInstance(Object, long, TimeUnit)
+     * @see     #unregisterInstance(InstanceHandle)
+     * @see     #unregisterInstance(InstanceHandle, Object)
+     * @see     InstanceHandle#nilHandle(org.omg.dds.core.Bootstrap)
+     */
     public InstanceHandle registerInstance(
             TYPE instanceData) throws TimeoutException;
+
+    /**
+     * This operation performs the same function as
+     * {@link #registerInstance(Object)} and can be used instead in the cases
+     * where the application desires to specify the value for the source
+     * time stamp. The source time stamp potentially affects the relative
+     * order in which readers observe events from multiple writers. For
+     * details see {@link DestinationOrderQosPolicy}.
+     * 
+     * This operation may block and exit with {@link TimeoutException} under
+     * the same circumstances described for the {@link #write(Object)}.
+     * 
+     * @throws  OutOfResourcesException under the same circumstances
+     *          described for {@link #write(Object)}.
+     * @throws  TimeoutException        under the same circumstances
+     *          described for {@link #write(Object)}.
+     * 
+     * @see     #registerInstance(Object)
+     * @see     #registerInstance(Object, long, TimeUnit)
+     * @see     #unregisterInstance(InstanceHandle, Object, Time)
+     */
     public InstanceHandle registerInstance(
             TYPE instanceData, 
             Time sourceTimestamp) throws TimeoutException;
+
+    /**
+     * This operation performs the same function as
+     * {@link #registerInstance(Object)} and can be used instead in the cases
+     * where the application desires to specify the value for the source
+     * time stamp. The source time stamp potentially affects the relative
+     * order in which readers observe events from multiple writers. For
+     * details see {@link DestinationOrderQosPolicy}.
+     * 
+     * This operation may block and exit with {@link TimeoutException} under
+     * the same circumstances described for the {@link #write(Object)}.
+     * 
+     * @throws  OutOfResourcesException under the same circumstances
+     *          described for {@link #write(Object)}.
+     * @throws  TimeoutException        under the same circumstances
+     *          described for {@link #write(Object)}.
+     * 
+     * @see     #registerInstance(Object)
+     * @see     #registerInstance(Object, Time)
+     * @see     #unregisterInstance(InstanceHandle, Object, long, TimeUnit)
+     */
     public InstanceHandle registerInstance(
             TYPE instanceData, 
             long sourceTimestamp,
             TimeUnit unit) throws TimeoutException;
 
+    /**
+     * This operation reverses the action of
+     * {@link #registerInstance(Object)}. It should only be called on an
+     * instance that is currently registered.
+     * 
+     * The operation should be called just once per instance, regardless of
+     * how many times {@link #registerInstance(Object)} was called for that
+     * instance.
+     * 
+     * This operation informs the Service that the DataWriter is not
+     * intending to modify that data instance any more. This operation also
+     * indicates that the Service can locally remove all information
+     * regarding that instance. The application should not attempt to use the
+     * handle previously allocated to that instance after calling
+     * {@link #unregisterInstance(InstanceHandle)}.
+     * 
+     * If handle is any value other than nil, then it must correspond to the
+     * value returned by {@link #registerInstance(Object)} when the instance
+     * (identified by its key) was registered.
+     * 
+     * If after that, the application wants to modify (write or dispose) the
+     * instance, it has to register it again, or else use a nil handle.
+     * 
+     * This operation does not indicate that the instance is deleted (that is
+     * the purpose of dispose). The operation just indicates that the
+     * DataWriter no longer has 'anything to say' about the instance.
+     * DataReader entities that are reading the instance will eventually
+     * receive a sample with a {@link InstanceState#NOT_ALIVE_NO_WRITERS}
+     * instance state if no other DataWriter entities are writing the
+     * instance.
+     * 
+     * This operation can affect the ownership of the data instance (see
+     * {@link OwnershipQosPolicy}). If the DataWriter was the exclusive owner
+     * of the instance, then calling this method will relinquish that
+     * ownership.
+     * 
+     * This operation may block and exit with {@link TimeoutException} under
+     * the same circumstances described for the {@link #write(Object)}.
+     * 
+     * @throws  IllegalArgumentException    if the handle does not correspond
+     *          to an existing instance, and if this situation is detectable
+     *          by the Service implementation. If the situation is not
+     *          detectable, the behavior is unspecified.
+     *
+     * @see     #unregisterInstance(InstanceHandle, Object)
+     * @see     #unregisterInstance(InstanceHandle, Object, Time)
+     * @see     #unregisterInstance(InstanceHandle, Object, long, TimeUnit)
+     * @see     #registerInstance(Object)
+     */
     public void unregisterInstance(
             InstanceHandle handle) throws TimeoutException;
+
+    /**
+     * This operation reverses the action of
+     * {@link #registerInstance(Object)}. It should only be called on an
+     * instance that is currently registered.
+     * 
+     * The operation should be called just once per instance, regardless of
+     * how many times {@link #registerInstance(Object)} was called for that
+     * instance.
+     * 
+     * This operation informs the Service that the DataWriter is not
+     * intending to modify that data instance any more. This operation also
+     * indicates that the Service can locally remove all information
+     * regarding that instance. The application should not attempt to use the
+     * handle previously allocated to that instance after calling
+     * {@link #unregisterInstance(InstanceHandle)}.
+     * 
+     * A nil handle can be used for the parameter handle. This indicates that
+     * the identity of the instance should be automatically deduced from the
+     * instance data (by means of the key).
+     * 
+     * If handle is any value other than nil, then it must correspond to the
+     * value returned by {@link #registerInstance(Object)} when the instance
+     * (identified by its key) was registered.
+     * 
+     * If after that, the application wants to modify (write or dispose) the
+     * instance, it has to register it again, or else use a nil handle.
+     * 
+     * This operation does not indicate that the instance is deleted (that is
+     * the purpose of dispose). The operation just indicates that the
+     * DataWriter no longer has 'anything to say' about the instance.
+     * DataReader entities that are reading the instance will eventually
+     * receive a sample with a {@link InstanceState#NOT_ALIVE_NO_WRITERS}
+     * instance state if no other DataWriter entities are writing the
+     * instance.
+     * 
+     * This operation can affect the ownership of the data instance (see
+     * {@link OwnershipQosPolicy}). If the DataWriter was the exclusive owner
+     * of the instance, then calling this method will relinquish that
+     * ownership.
+     * 
+     * This operation may block and exit with {@link TimeoutException} under
+     * the same circumstances described for the {@link #write(Object)}.
+     * 
+     * @throws  IllegalArgumentException    if the handle does not correspond
+     *          to an existing instance, and if this situation is detectable
+     *          by the Service implementation. If the situation is not
+     *          detectable, the behavior is unspecified.
+     * @throws  PreconditionNotMetException if the handle corresponds to an
+     *          existing instance but does not correspond to the same
+     *          instance referred by the instancData parameter, and if this
+     *          situation is detectable by the Service implementation If the
+     *          situation is not detectable, the behavior is unspecified.
+     * 
+     * @see     #unregisterInstance(InstanceHandle)
+     * @see     #unregisterInstance(InstanceHandle, Object, Time)
+     * @see     #unregisterInstance(InstanceHandle, Object, long, TimeUnit)
+     * @see     #registerInstance(Object)
+     * @see     InstanceHandle#nilHandle(org.omg.dds.core.Bootstrap)
+     */
     public void unregisterInstance(
             InstanceHandle handle, 
             TYPE instanceData) throws TimeoutException;
+
+    /**
+     * This operation performs the same function as
+     * {@link #unregisterInstance(InstanceHandle, Object)} and can be used
+     * instead in the cases where the application desires to specify the
+     * value for the source time stamp. The source time stamp potentially
+     * affects the relative order in which readers observe events from
+     * multiple writers. For details see {@link DestinationOrderQosPolicy}.
+     * 
+     * The constraints on the values of the handle parameter and the
+     * corresponding error behavior are the same specified for the
+     * {@link #unregisterInstance(InstanceHandle, Object)} operation.
+     * 
+     * This operation may block and exit with {@link TimeoutException} under
+     * the same circumstances described for the {@link #write(Object)}.
+     * 
+     * @see     #unregisterInstance(InstanceHandle)
+     * @see     #unregisterInstance(InstanceHandle, Object)
+     * @see     #unregisterInstance(InstanceHandle, Object, long, TimeUnit)
+     * @see     #registerInstance(Object, Time)
+     */
     public void unregisterInstance(
             InstanceHandle handle, 
             TYPE instanceData,
             Time sourceTimestamp) throws TimeoutException;
+
+    /**
+     * This operation performs the same function as
+     * {@link #unregisterInstance(InstanceHandle, Object)} and can be used
+     * instead in the cases where the application desires to specify the
+     * value for the source time stamp. The source time stamp potentially
+     * affects the relative order in which readers observe events from
+     * multiple writers. For details see {@link DestinationOrderQosPolicy}.
+     * 
+     * The constraints on the values of the handle parameter and the
+     * corresponding error behavior are the same specified for the
+     * {@link #unregisterInstance(InstanceHandle, Object)} operation.
+     * 
+     * This operation may block and exit with {@link TimeoutException} under
+     * the same circumstances described for the {@link #write(Object)}.
+     * 
+     * @see     #unregisterInstance(InstanceHandle)
+     * @see     #unregisterInstance(InstanceHandle, Object)
+     * @see     #unregisterInstance(InstanceHandle, Object, Time)
+     * @see     #registerInstance(Object, long, TimeUnit)
+     */
     public void unregisterInstance(
             InstanceHandle handle, 
             TYPE instanceData,
             long sourceTimestamp,
             TimeUnit unit) throws TimeoutException;
 
+    /**
+     * This operation modifies the value of a data instance. When this
+     * operation is used, the Service will automatically supply the value of
+     * the source time stamp that is made available to {@link DataReader}
+     * objects by means of {@link Sample#getSourceTimestamp()}. See also
+     * {@link DestinationOrderQosPolicy}.
+     * 
+     * As a side effect, this operation asserts liveliness on the DataWriter
+     * itself, the {@link Publisher} and the {@link DomainParticipant}.
+     * 
+     * If {@link ReliabilityQosPolicy#getKind()} kind is set to
+     * {@link ReliabilityQosPolicy.Kind#RELIABLE}, the operation may block if
+     * the modification would cause data to be lost or else cause one of the
+     * limits specified in {@link ResourceLimitsQosPolicy} to be exceeded.
+     * Under these circumstances,
+     * {@link ReliabilityQosPolicy#getMaxBlockingTime()} configures the
+     * maximum time the operation may block waiting for space to become
+     * available. If this duration elapses before the DataWriter is able to
+     * store the modification without exceeding the limits, the operation
+     * will fail with {@link TimeoutException}.
+     * 
+     * Specifically, the DataWriter write operation may block in the
+     * following situations (note that the list may not be exhaustive), even
+     * if {@link HistoryQosPolicy#getKind()} is
+     * {@link HistoryQosPolicy.Kind#KEEP_LAST}.
+     * 
+     * <ul>
+     *     <li>If ({@link ResourceLimitsQosPolicy#getMaxSamples()} &lt;
+     *         {@link ResourceLimitsQosPolicy#getMaxInstances()} *
+     *         {@link HistoryQosPolicy#getDepth()}), then in the situation
+     *         where the max samples resource limit is exhausted the Service
+     *         is allowed to discard samples of some other instance as long
+     *         as at least one sample remains for such an instance. If it is
+     *         still not possible to make space available to store the
+     *         modification, the writer is allowed to block.</li>
+     *     <li>If ({@link ResourceLimitsQosPolicy#getMaxSamples()} &lt;
+     *         {@link ResourceLimitsQosPolicy#getMaxInstances()}), then the
+     *         DataWriter may block regardless of the HISTORY depth.</li>
+     * </ul>
+     * 
+     * Instead of blocking, the operation is allowed to fail immediately
+     * with {@link OutOfResourcesException} provided the following two
+     * conditions are met:
+     * 
+     * <ol>
+     *     <li>The reason for blocking would be that the RESOURCE_LIMITS are
+     *         exceeded.</li>
+     *     <li>The service determines that waiting the max blocking time has
+     *         no chance of freeing the necessary resources. For example, if
+     *         the only way to gain the necessary resources would be for the
+     *         user to unregister an instance.</li>
+     * </ol>
+     * 
+     * @throws  OutOfResourcesException     if it is not possible for
+     *          sufficient resources to be made available within the
+     *          configured max blocking time.
+     * @throws  TimeoutException            if the configured maximum
+     *          time elapses and the DataWriter is still unable to store the
+     *          new sample without exceeding its configured resource limits.
+     * 
+     * @see     #write(Object, InstanceHandle)
+     * @see     #write(Object, InstanceHandle, Time)
+     * @see     #write(Object, InstanceHandle, long, TimeUnit)
+     */
     public void write(
             TYPE instanceData) throws TimeoutException;
     public void write(
@@ -120,38 +592,334 @@
             TYPE instanceData, 
             long sourceTimestamp,
             TimeUnit unit) throws TimeoutException;
+
+    /**
+     * This operation modifies the value of a data instance. When this
+     * operation is used, the Service will automatically supply the value of
+     * the source time stamp that is made available to {@link DataReader}
+     * objects by means of {@link Sample#getSourceTimestamp()}. See also
+     * {@link DestinationOrderQosPolicy}.
+     * 
+     * As a side effect, this operation asserts liveliness on the DataWriter
+     * itself, the {@link Publisher} and the {@link DomainParticipant}.
+     * 
+     * A nil handle can be used for the parameter handle. This indicates that
+     * the identity of the instance should be automatically deduced from the
+     * instanceData (by means of the key). If handle is not nil, then it must
+     * correspond to the value returned by {@link #registerInstance(Object)}
+     * when the instance (identified by its key) was registered.
+     * 
+     * If {@link ReliabilityQosPolicy#getKind()} kind is set to
+     * {@link ReliabilityQosPolicy.Kind#RELIABLE}, the operation may block if
+     * the modification would cause data to be lost or else cause one of the
+     * limits specified in {@link ResourceLimitsQosPolicy} to be exceeded.
+     * Under these circumstances,
+     * {@link ReliabilityQosPolicy#getMaxBlockingTime()} configures the
+     * maximum time the operation may block waiting for space to become
+     * available. If this duration elapses before the DataWriter is able to
+     * store the modification without exceeding the limits, the operation
+     * will fail with {@link TimeoutException}.
+     * 
+     * Specifically, the DataWriter write operation may block in the
+     * following situations (note that the list may not be exhaustive), even
+     * if {@link HistoryQosPolicy#getKind()} is
+     * {@link HistoryQosPolicy.Kind#KEEP_LAST}.
+     * 
+     * <ul>
+     *     <li>If ({@link ResourceLimitsQosPolicy#getMaxSamples()} &lt;
+     *         {@link ResourceLimitsQosPolicy#getMaxInstances()} *
+     *         {@link HistoryQosPolicy#getDepth()}), then in the situation
+     *         where the max samples resource limit is exhausted the Service
+     *         is allowed to discard samples of some other instance as long
+     *         as at least one sample remains for such an instance. If it is
+     *         still not possible to make space available to store the
+     *         modification, the writer is allowed to block.</li>
+     *     <li>If ({@link ResourceLimitsQosPolicy#getMaxSamples()} &lt;
+     *         {@link ResourceLimitsQosPolicy#getMaxInstances()}), then the
+     *         DataWriter may block regardless of the HISTORY depth.</li>
+     * </ul>
+     * 
+     * Instead of blocking, the operation is allowed to fail immediately
+     * with {@link OutOfResourcesException} provided the following two
+     * conditions are met:
+     * 
+     * <ol>
+     *     <li>The reason for blocking would be that the RESOURCE_LIMITS are
+     *         exceeded.</li>
+     *     <li>The service determines that waiting the max blocking time has
+     *         no chance of freeing the necessary resources. For example, if
+     *         the only way to gain the necessary resources would be for the
+     *         user to unregister an instance.</li>
+     * </ol>
+     * 
+     * @throws  IllegalArgumentException    if the handle does not correspond
+     *          to an existing instance, and if this situation is detectable
+     *          by the Service implementation. If the situation is not
+     *          detectable, the behavior is unspecified.
+     * @throws  PreconditionNotMetException if the handle corresponds to an
+     *          existing instance but does not correspond to the same
+     *          instance referred by the instancData parameter, and if this
+     *          situation is detectable by the Service implementation If the
+     *          situation is not detectable, the behavior is unspecified.
+     * @throws  OutOfResourcesException     if it is not possible for
+     *          sufficient resources to be made available within the
+     *          configured max blocking time.
+     * @throws  TimeoutException            if the configured maximum
+     *          time elapses and the DataWriter is still unable to store the
+     *          new sample without exceeding its configured resource limits.
+     * 
+     * @see     #write(Object)
+     * @see     #write(Object, InstanceHandle, Time)
+     * @see     #write(Object, InstanceHandle, long, TimeUnit)
+     * @see     InstanceHandle#nilHandle(org.omg.dds.core.Bootstrap)
+     */
     public void write(
             TYPE instanceData, 
             InstanceHandle handle) throws TimeoutException;
+
+    /**
+     * This operation performs the same function as
+     * {@link #write(Object, InstanceHandle)} except that it also provides
+     * the value for the source time stamp that is made available to
+     * {@link DataReader} objects by means of
+     * {@link Sample#getSourceTimestamp()}. See also
+     * {@link DestinationOrderQosPolicy}.
+     * 
+     * The constraints on the values of the handle parameter and the
+     * corresponding error behavior are the same specified for
+     * {@link #write(Object, InstanceHandle)}.
+     * 
+     * This operation may block and exit with {@link TimeoutException} under
+     * the same circumstances described for
+     * {@link #write(Object, InstanceHandle)}.
+     * 
+     * @throws  IllegalArgumentException    under the same circumstances as
+     *          {@link #write(Object, InstanceHandle)}.
+     * @throws  PreconditionNotMetException under the same circumstances as
+     *          {@link #write(Object, InstanceHandle)}.
+     * @throws  OutOfResourcesException     under the same circumstances as
+     *          {@link #write(Object, InstanceHandle)}.
+     * @throws  TimeoutException            under the same circumstances as
+     *          {@link #write(Object, InstanceHandle)}.
+     * 
+     * @see     #write(Object)
+     * @see     #write(Object, InstanceHandle)
+     * @see     #write(Object, InstanceHandle, long, TimeUnit)
+     */
     public void write(
             TYPE instanceData, 
             InstanceHandle handle,
             Time sourceTimestamp) throws TimeoutException;
+
+    /**
+     * This operation performs the same function as
+     * {@link #write(Object, InstanceHandle)} except that it also provides
+     * the value for the source time stamp that is made available to
+     * {@link DataReader} objects by means of
+     * {@link Sample#getSourceTimestamp()}. See also
+     * {@link DestinationOrderQosPolicy}.
+     * 
+     * The constraints on the values of the handle parameter and the
+     * corresponding error behavior are the same specified for
+     * {@link #write(Object, InstanceHandle)}.
+     * 
+     * This operation may block and exit with {@link TimeoutException} under
+     * the same circumstances described for
+     * {@link #write(Object, InstanceHandle)}.
+     * 
+     * @throws  IllegalArgumentException    under the same circumstances as
+     *          {@link #write(Object, InstanceHandle)}.
+     * @throws  PreconditionNotMetException under the same circumstances as
+     *          {@link #write(Object, InstanceHandle)}.
+     * @throws  OutOfResourcesException     under the same circumstances as
+     *          {@link #write(Object, InstanceHandle)}.
+     * @throws  TimeoutException            under the same circumstances as
+     *          {@link #write(Object, InstanceHandle)}.
+     * 
+     * @see     #write(Object)
+     * @see     #write(Object, InstanceHandle)
+     * @see     #write(Object, InstanceHandle, Time)
+     */
     public void write(
             TYPE instanceData, 
             InstanceHandle handle,
             long sourceTimestamp,
             TimeUnit unit) throws TimeoutException;
 
+    /**
+     * This operation requests the middleware to delete the data (the actual
+     * deletion is postponed until there is no more use for that data in the
+     * whole system). In general, applications are made aware of the deletion
+     * by means of operations on the {@link DataReader} objects that already
+     * knew that instance. DataReader objects that didn't know the instance
+     * will never see it.
+     * 
+     * When this operation is used, the Service will automatically supply the
+     * value of the source time stamp that is made available to DataReader
+     * objects by means of {@link Sample#getSourceTimestamp()}.
+     * 
+     * The constraints on the values of the instanceHandle parameter and the
+     * corresponding error behavior are the same specified for
+     * {@link #unregisterInstance(InstanceHandle)}.
+     * 
+     * This operation may block and exit with {@link TimeoutException} under
+     * the same circumstances described for {@link #write(Object)}.
+     * 
+     * @throws  OutOfResourcesException     under the same circumstances as
+     *          {@link #write(Object)}.
+     * @throws  TimeoutException            under the same circumstances as
+     *          {@link #write(Object)}.
+     *
+     * @see     #dispose(InstanceHandle, Object)
+     * @see     #dispose(InstanceHandle, Object, Time)
+     * @see     #dispose(InstanceHandle, Object, long, TimeUnit)
+     */
     public void dispose(
             InstanceHandle instanceHandle) throws TimeoutException;
+
+    /**
+     * This operation requests the middleware to delete the data (the actual
+     * deletion is postponed until there is no more use for that data in the
+     * whole system). In general, applications are made aware of the deletion
+     * by means of operations on the {@link DataReader} objects that already
+     * knew that instance. DataReader objects that didn't know the instance
+     * will never see it.
+     * 
+     * This operation does not modify the value of the instance. The
+     * instanceData parameter is passed just for the purposes of identifying
+     * the instance.
+     * 
+     * When this operation is used, the Service will automatically supply the
+     * value of the source time stamp that is made available to DataReader
+     * objects by means of {@link Sample#getSourceTimestamp()}.
+     * 
+     * The constraints on the values of the instanceHandle parameter and the
+     * corresponding error behavior are the same specified for
+     * {@link #unregisterInstance(InstanceHandle, Object)}.
+     * 
+     * This operation may block and exit with {@link TimeoutException} under
+     * the same circumstances described for
+     * {@link #write(Object, InstanceHandle)}.
+     * 
+     * @throws  OutOfResourcesException     under the same circumstances as
+     *          {@link #write(Object, InstanceHandle)}.
+     * @throws  TimeoutException            under the same circumstances as
+     *          {@link #write(Object, InstanceHandle)}.
+     *
+     * @see     #dispose(InstanceHandle)
+     * @see     #dispose(InstanceHandle, Object, Time)
+     * @see     #dispose(InstanceHandle, Object, long, TimeUnit)
+     */
     public void dispose(
             InstanceHandle instanceHandle, 
             TYPE instanceData) throws TimeoutException;
+
+    /**
+     * This operation performs the same functions as
+     * {@link #dispose(InstanceHandle, Object)} except that the application
+     * provides the value for the source time stamp that is made available to
+     * {@link DataReader} objects by means of
+     * {@link Sample#getSourceTimestamp()}.
+     * 
+     * The constraints on the values of the instanceHandle parameter and the
+     * corresponding error behavior are the same specified for
+     * {@link #dispose(InstanceHandle, Object)}.
+     * 
+     * This operation may block and exit with {@link TimeoutException} under
+     * the same circumstances described for
+     * {@link #write(Object, InstanceHandle)}.
+     * 
+     * @throws  IllegalArgumentException    under the same circumstances as
+     *          {@link #dispose(Object, InstanceHandle)}.
+     * @throws  PreconditionNotMetException under the same circumstances as
+     *          {@link #dispose(InstanceHandle, Object)}.
+     * @throws  OutOfResourcesException     under the same circumstances as
+     *          {@link #write(Object, InstanceHandle)}.
+     * @throws  TimeoutException            under the same circumstances as
+     *          {@link #write(Object, InstanceHandle)}.
+     * 
+     * @see     #dispose(InstanceHandle)
+     * @see     #dispose(InstanceHandle, Object)
+     * @see     #dispose(InstanceHandle, Object, long, TimeUnit)
+     */
     public void dispose(
             InstanceHandle instanceHandle, 
             TYPE instanceData,
             Time sourceTimestamp) throws TimeoutException;
+
+    /**
+     * This operation performs the same functions as
+     * {@link #dispose(InstanceHandle, Object)} except that the application
+     * provides the value for the source time stamp that is made available to
+     * {@link DataReader} objects by means of
+     * {@link Sample#getSourceTimestamp()}.
+     * 
+     * The constraints on the values of the instanceHandle parameter and the
+     * corresponding error behavior are the same specified for
+     * {@link #dispose(InstanceHandle, Object)}.
+     * 
+     * This operation may block and exit with {@link TimeoutException} under
+     * the same circumstances described for
+     * {@link #write(Object, InstanceHandle)}.
+     * 
+     * @throws  IllegalArgumentException    under the same circumstances as
+     *          {@link #dispose(Object, InstanceHandle)}.
+     * @throws  PreconditionNotMetException under the same circumstances as
+     *          {@link #dispose(InstanceHandle, Object)}.
+     * @throws  OutOfResourcesException     under the same circumstances as
+     *          {@link #write(Object, InstanceHandle)}.
+     * @throws  TimeoutException            under the same circumstances as
+     *          {@link #write(Object, InstanceHandle)}.
+     * 
+     * @see     #dispose(InstanceHandle)
+     * @see     #dispose(InstanceHandle, Object)
+     * @see     #dispose(InstanceHandle, Object, Time)
+     */
     public void dispose(
             InstanceHandle instanceHandle, 
             TYPE instanceData,
             long sourceTimestamp,
             TimeUnit unit) throws TimeoutException;
 
+    /**
+     * This operation can be used to retrieve the instance key that
+     * corresponds to an instance handle. The operation will only fill the
+     * fields that form the key inside the keyHolder instance.
+     * 
+     * @param   keyHolder       a container, into which this method shall
+     *          place its result.
+     * @param   handle          a handle indicating the instance whose value
+     *          this method should get.
+     *
+     * @return  keyHolder, as a convenience to facilitate chaining.
+     * 
+     * @throws  IllegalArgumentException    if the handle does not correspond
+     *          to an existing data object known to the DataWriter. If the
+     *          implementation is not able to check invalid handles, then the
+     *          result in this situation is unspecified.
+     */
     public TYPE getKeyValue(
             TYPE keyHolder, 
             InstanceHandle handle);
 
+    /**
+     * This operation takes as a parameter an instance and returns a handle
+     * that can be used in subsequent operations that accept an instance
+     * handle as an argument. The instance parameter is only used for the
+     * purpose of examining the fields that define the key.
+     * 
+     * This operation does not register the instance in question. If the
+     * instance has not been previously registered, or if for any other
+     * reason the Service is unable to provide an instance handle, the
+     * Service will return a nil handle.
+     * 
+     * @param   handle  a container, into which this method shall place its
+     *          result.
+     * @param   keyHolder       a sample of the instance whose handle this
+     *          method should look up.
+     *
+     * @return  handle, as a convenience to facilitate chaining.
+     */
     public ModifiableInstanceHandle lookupInstance(
             ModifiableInstanceHandle handle,
             TYPE keyHolder);
Index: ftf_vote_01/srcJava/org/omg/dds/pub/DataWriterListener.java
===================================================================
--- ftf_vote_01/srcJava/org/omg/dds/pub/DataWriterListener.java	(revision 139)
+++ ftf_vote_01/srcJava/org/omg/dds/pub/DataWriterListener.java	(working copy)
@@ -20,12 +20,20 @@
 
 import java.util.EventListener;
 
+import org.omg.dds.core.Entity;
 import org.omg.dds.core.status.LivelinessLostStatus;
 import org.omg.dds.core.status.OfferedDeadlineMissedStatus;
 import org.omg.dds.core.status.OfferedIncompatibleQosStatus;
 import org.omg.dds.core.status.PublicationMatchedStatus;
 
 
+/**
+ * Since a {@link DataWriter} is a kind of {@link Entity}, it has the ability
+ * to have a listener associated with it. In this case, the associated
+ * listener must be of concrete type DataWriterListener.
+ * 
+ * @param <TYPE>    The concrete type of the data written by the DataWriter.
+ */
 public interface DataWriterListener<TYPE> extends EventListener {
     public void onOfferedDeadlineMissed(
             OfferedDeadlineMissedStatus<TYPE> status);
Index: ftf_vote_01/srcJava/org/omg/dds/pub/Publisher.java
===================================================================
--- ftf_vote_01/srcJava/org/omg/dds/pub/Publisher.java	(revision 139)
+++ ftf_vote_01/srcJava/org/omg/dds/pub/Publisher.java	(working copy)
@@ -24,8 +24,12 @@
 
 import org.omg.dds.core.DomainEntity;
 import org.omg.dds.core.Duration;
+import org.omg.dds.core.InconsistentPolicyException;
+import org.omg.dds.core.NotEnabledException;
+import org.omg.dds.core.PreconditionNotMetException;
 import org.omg.dds.core.status.Status;
 import org.omg.dds.domain.DomainParticipant;
+import org.omg.dds.sub.DataReader;
 import org.omg.dds.topic.Topic;
 import org.omg.dds.topic.TopicQos;
 import org.omg.dds.type.builtin.BytesDataWriter;
@@ -36,6 +40,24 @@
 import org.omg.dds.type.builtin.StringDataWriter;
 
 
+/**
+ * A Publisher is the object responsible for the actual dissemination of
+ * publications.
+ * 
+ * The Publisher acts on the behalf of one or several {@link DataWriter}
+ * objects that belong to it. When it is informed of a change to the data
+ * associated with one of its DataWriter objects, it decides when it is
+ * appropriate to actually send the data-update message. In making this
+ * decision, it considers any extra information that goes with the data
+ * (time stamp, writer, etc.) as well as the QoS of the Publisher and the
+ * DataWriter.
+ * 
+ * All operations except for {@link #setQos(PublisherQos)}, {@link #getQos()},
+ * {@link #setListener(PublisherListener)}, {@link #getListener()},
+ * {@link #enable()}, {@link #getStatusCondition()},
+ * {@link #createDataWriter(Topic)}, and {@link Publisher#close()} may fail
+ * with the exception {@link NotEnabledException}.
+ */
 public interface Publisher
 extends DomainEntity<Publisher,
                      DomainParticipant,
@@ -44,15 +66,64 @@
 {
     // --- Create (any) DataWriter: ------------------------------------------
 
+    /**
+     * This operation creates a DataWriter. The returned DataWriter will be
+     * attached and belongs to the Publisher.
+     * 
+     * Note that a common application pattern to construct the QoS for the
+     * DataWriter is to:
+     * 
+     * <ul>
+     *     <li>Retrieve the QoS policies on the associated {@link Topic} by
+     *         means of {@link Topic#getQos()}.</li>
+     *     <li>Retrieve the default DataWriter QoS by means of
+     *         {@link Publisher#getDefaultDataWriterQos()}.</li>
+     *     <li>Combine those two QoS policies and selectively modify policies
+     *         as desired -- see
+     *         {@link #copyFromTopicQos(DataWriterQos, TopicQos)}.</li>
+     *     <li>Use the resulting QoS policies to construct the DataWriter.
+     *         </li>
+     * </ul>
+     * 
+     * The {@link Topic} passed to this operation must have been created from
+     * the same {@link DomainParticipant} that was used to create this
+     * Publisher. If the Topic was created from a different
+     * DomainParticipant, the operation will fail.
+     * 
+     * @see     #createDataWriter(Topic, DataWriterQos, DataWriterListener, Collection)
+     */
     public <TYPE> DataWriter<TYPE> createDataWriter(
             Topic<TYPE> topic);
 
     /**
-     * Create a new data writer.
+     * This operation creates a DataWriter. The returned DataWriter will be
+     * attached and belongs to the Publisher.
      * 
+     * Note that a common application pattern to construct the QoS for the
+     * DataWriter is to:
+     * 
+     * <ul>
+     *     <li>Retrieve the QoS policies on the associated {@link Topic} by
+     *         means of {@link Topic#getQos()}.</li>
+     *     <li>Retrieve the default DataWriter QoS by means of
+     *         {@link Publisher#getDefaultDataWriterQos()}.</li>
+     *     <li>Combine those two QoS policies and selectively modify policies
+     *         as desired -- see
+     *         {@link #copyFromTopicQos(DataWriterQos, TopicQos)}.</li>
+     *     <li>Use the resulting QoS policies to construct the DataWriter.
+     *         </li>
+     * </ul>
+     * 
+     * The {@link Topic} passed to this operation must have been created from
+     * the same {@link DomainParticipant} that was used to create this
+     * Publisher. If the Topic was created from a different
+     * DomainParticipant, the operation will fail.
+     * 
      * @param statuses  Of which status changes the listener should be
      *                  notified. A null collection signifies all status
      *                  changes.
+     *
+     * @see     #createDataWriter(Topic)
      */
     public <TYPE> DataWriter<TYPE> createDataWriter(
             Topic<TYPE> topic,
@@ -66,6 +137,8 @@
      * @param statuses  Of which status changes the listener should be
      *                  notified. A null collection signifies all status
      *                  changes.
+     *
+     * @see     #createDataWriter(Topic, DataWriterQos, DataWriterListener, Collection)
      */
     public <TYPE> DataWriter<TYPE> createDataWriter(
             Topic<TYPE> topic,
@@ -77,15 +150,22 @@
 
     // --- Create DataWriter for built-in bytes type: ------------------------
 
+    /**
+     * Create a new data writer for this built-in type.
+     * 
+     * @see     #createDataWriter(Topic)
+     */
     public BytesDataWriter createBytesDataWriter(
             Topic<byte[]> topic);
 
     /**
-     * Create a new data writer.
+     * Create a new data writer for this built-in type.
      * 
      * @param statuses  Of which status changes the listener should be
      *                  notified. A null collection signifies all status
      *                  changes.
+     * 
+     * @see     #createDataWriter(Topic, DataWriterQos, DataWriterListener, Collection)
      */
     public BytesDataWriter createBytesDataWriter(
             Topic<byte[]> topic,
@@ -94,11 +174,13 @@
             Collection<Class<? extends Status<?, ?>>> statuses);
 
     /**
-     * Create a new data writer.
+     * Create a new data writer for this built-in type.
      * 
      * @param statuses  Of which status changes the listener should be
      *                  notified. A null collection signifies all status
      *                  changes.
+     * 
+     * @see     #createDataWriter(Topic, DataWriterQos, DataWriterListener, Collection)
      */
     public BytesDataWriter createBytesDataWriter(
             Topic<byte[]> topic,
@@ -110,15 +192,22 @@
 
     // --- Create DataWriter for built-in KeyedBytes type: -------------------
 
+    /**
+     * Create a new data writer for this built-in type.
+     * 
+     * @see     #createDataWriter(Topic)
+     */
     public KeyedBytesDataWriter createKeyedBytesDataWriter(
             Topic<KeyedBytes> topic);
 
     /**
-     * Create a new data writer.
+     * Create a new data writer for this built-in type.
      * 
      * @param statuses  Of which status changes the listener should be
      *                  notified. A null collection signifies all status
      *                  changes.
+     * 
+     * @see     #createDataWriter(Topic, DataWriterQos, DataWriterListener, Collection)
      */
     public KeyedBytesDataWriter createKeyedBytesDataWriter(
             Topic<KeyedBytes> topic,
@@ -127,11 +216,13 @@
             Collection<Class<? extends Status<?, ?>>> statuses);
 
     /**
-     * Create a new data writer.
+     * Create a new data writer for this built-in type.
      * 
      * @param statuses  Of which status changes the listener should be
      *                  notified. A null collection signifies all status
      *                  changes.
+     * 
+     * @see     #createDataWriter(Topic, DataWriterQos, DataWriterListener, Collection)
      */
     public KeyedBytesDataWriter createKeyedBytesDataWriter(
             Topic<KeyedBytes> topic,
@@ -143,15 +234,22 @@
 
     // --- Create DataWriter for built-in string type: -----------------------
 
+    /**
+     * Create a new data writer for this built-in type.
+     * 
+     * @see     #createDataWriter(Topic)
+     */
     public StringDataWriter createStringDataWriter(
             Topic<String> topic);
 
     /**
-     * Create a new data writer.
+     * Create a new data writer for this built-in type.
      * 
      * @param statuses  Of which status changes the listener should be
      *                  notified. A null collection signifies all status
      *                  changes.
+     * 
+     * @see     #createDataWriter(Topic, DataWriterQos, DataWriterListener, Collection)
      */
     public StringDataWriter createStringDataWriter(
             Topic<String> topic,
@@ -160,11 +258,13 @@
             Collection<Class<? extends Status<?, ?>>> statuses);
 
     /**
-     * Create a new data writer.
+     * Create a new data writer for this built-in type.
      * 
      * @param statuses  Of which status changes the listener should be
      *                  notified. A null collection signifies all status
      *                  changes.
+     * 
+     * @see     #createDataWriter(Topic, DataWriterQos, DataWriterListener, Collection)
      */
     public StringDataWriter createStringDataWriter(
             Topic<String> topic,
@@ -176,15 +276,22 @@
 
     // --- Create DataWriter for built-in KeyedString type: ------------------
 
+    /**
+     * Create a new data writer for this built-in type.
+     * 
+     * @see     #createDataWriter(Topic)
+     */
     public KeyedStringDataWriter createKeyedStringDataWriter(
             Topic<KeyedString> topic);
 
     /**
-     * Create a new data writer.
+     * Create a new data writer for this built-in type.
      * 
      * @param statuses  Of which status changes the listener should be
      *                  notified. A null collection signifies all status
      *                  changes.
+     * 
+     * @see     #createDataWriter(Topic, DataWriterQos, DataWriterListener, Collection)
      */
     public KeyedStringDataWriter createKeyedStringDataWriter(
             Topic<KeyedString> topic,
@@ -193,11 +300,13 @@
             Collection<Class<? extends Status<?, ?>>> statuses);
 
     /**
-     * Create a new data writer.
+     * Create a new data writer for this built-in type.
      * 
      * @param statuses  Of which status changes the listener should be
      *                  notified. A null collection signifies all status
      *                  changes.
+     * 
+     * @see     #createDataWriter(Topic, DataWriterQos, DataWriterListener, Collection)
      */
     public KeyedStringDataWriter createKeyedStringDataWriter(
             Topic<KeyedString> topic,
@@ -209,38 +318,253 @@
 
     // --- Lookup operations: ------------------------------------------------
 
+    /**
+     * This operation retrieves a previously created {@link DataWriter}
+     * belonging to the Publisher that is attached to a {@link Topic} with a
+     * matching name. If no such DataWriter exists, the operation will return
+     * null.
+     * 
+     * If multiple DataWriters attached to the Publisher satisfy this
+     * condition, then the operation will return one of them. It is not
+     * specified which one.
+     * 
+     * @see     #lookupDataWriter(Topic)
+     */
     public <TYPE> DataWriter<TYPE> lookupDataWriter(String topicName);
-    public <TYPE> DataWriter<TYPE> lookupDataWriter(Topic<TYPE> topicName);
 
-    public BytesDataWriter lookupBytesDataWriter(Topic<byte[]> topicName);
+    /**
+     * This operation retrieves a previously created {@link DataWriter}
+     * belonging to the Publisher that is attached to the given
+     * {@link Topic}. If no such DataWriter exists, the operation will return
+     * null.
+     * 
+     * If multiple DataWriters attached to the Publisher satisfy this
+     * condition, then the operation will return one of them. It is not
+     * specified which one.
+     * 
+     * @see     #lookupDataWriter(String)
+     */
+    public <TYPE> DataWriter<TYPE> lookupDataWriter(Topic<TYPE> topic);
+
+    /**
+     * Look up a DataWriter for the given built-in data type.
+     * 
+     * @throws  ClassCastException      if a DataWriter exists on the given
+     *          Topic but is of a different type.
+     *
+     * @see     #lookupDataWriter(Topic)
+     */
+    public BytesDataWriter lookupBytesDataWriter(Topic<byte[]> topic);
+
+    /**
+     * Look up a DataWriter for the given built-in data type.
+     * 
+     * @throws  ClassCastException      if a DataWriter exists on the given
+     *          Topic but is of a different type.
+     *
+     * @see     #lookupDataWriter(Topic)
+     */
     public KeyedBytesDataWriter lookupKeyedBytesDataWriter(
-            Topic<KeyedBytes> topicName);
-    public StringDataWriter lookupStringDataWriter(Topic<String> topicName);
+            Topic<KeyedBytes> topic);
+
+    /**
+     * Look up a DataWriter for the given built-in data type.
+     * 
+     * @throws  ClassCastException      if a DataWriter exists on the given
+     *          Topic but is of a different type.
+     *
+     * @see     #lookupDataWriter(Topic)
+     */
+    public StringDataWriter lookupStringDataWriter(Topic<String> topic);
+
+    /**
+     * Look up a DataWriter for the given built-in data type.
+     * 
+     * @throws  ClassCastException      if a DataWriter exists on the given
+     *          Topic but is of a different type.
+     *
+     * @see     #lookupDataWriter(Topic)
+     */
     public KeyedStringDataWriter lookupKeyedStringDataWriter(
-            Topic<KeyedString> topicName);
+            Topic<KeyedString> topic);
 
 
     // --- Other operations: -------------------------------------------------
 
+    /**
+     * This operation closes all the entities that were created by means of
+     * the "create" operations on the Publisher. That is, it closes all
+     * contained {@link DataWriter} objects.
+     * 
+     * @throws  PreconditionNotMetException     if the any of the contained
+     *          entities is in a state where it cannot be deleted.
+     */
     public void closeContainedEntities();
 
+    /**
+     * This operation indicates to the Service that the application is about
+     * to make multiple modifications using DataWriter objects belonging to
+     * the Publisher.
+     * 
+     * It is a hint to the Service so it can optimize its performance by
+     * e.g., holding the dissemination of the modifications and then batching
+     * them.
+     * 
+     * It is not required that the Service use this hint in any way.
+     * 
+     * The use of this operation must be matched by a corresponding call to
+     * {@link #resumePublications()} indicating that the set of modifications
+     * has completed. If the Publisher is deleted before
+     * {@link #resumePublications()} is called, any suspended updates yet to
+     * be published will be discarded.
+     * 
+     * @see     #resumePublications()
+     */
     public void suspendPublications();
+
+    /**
+     * This operation indicates to the Service that the application has
+     * completed the multiple changes initiated by the previous
+     * {@link #suspendPublications()}. This is a hint to the Service that can
+     * be used by a Service implementation to e.g., batch all the
+     * modifications made since the {@link #suspendPublications()}.
+     *
+     * @throws  PreconditionNotMetException     if the call to this method
+     *          does not match a previous call to
+     *          {@link #suspendPublications()}.
+     * 
+     * @see     #suspendPublications()
+     */
     public void resumePublications();
 
+    /**
+     * This operation requests that the application will begin a 'coherent
+     * set' of modifications using {@link DataWriter} objects attached to the
+     * Publisher. The 'coherent set' will be completed by a matching call to
+     * {@link #endCoherentChanges()}.
+     * 
+     * A 'coherent set' is a set of modifications that must be propagated in
+     * such a way that they are interpreted at the receivers' side as a
+     * consistent set of modifications; that is, the receiver will only be
+     * able to access the data after all the modifications in the set are
+     * available at the receiver end.
+     * 
+     * A connectivity change may occur in the middle of a set of coherent
+     * changes; for example, the set of partitions used by the Publisher or
+     * one of its Subscribers may change, a late-joining DataReader may
+     * appear on the network, or a communication failure may occur. In the
+     * event that such a change prevents an entity from receiving the entire
+     * set of coherent changes, that entity must behave as if it had
+     * received none of the set.
+     * 
+     * These calls can be nested. In that case, the coherent set terminates
+     * only with the last call to {@link #endCoherentChanges()}.
+     * 
+     * The support for 'coherent changes' enables a publishing application to
+     * change the value of several data instances that could belong to the
+     * same or different topics and have those changes be seen 'atomically'
+     * by the readers. This is useful in cases where the values are
+     * interrelated. For example, if there are two data instances
+     * representing the 'altitude' and 'velocity vector' of the same aircraft
+     * and both are changed, it may be useful to communicate those values in
+     * a way the reader can see both together; otherwise, it may e.g.,
+     * erroneously interpret that the aircraft is on a collision course.
+     * 
+     * @see     #endCoherentChanges()
+     */
     public void beginCoherentChanges();
+
+    /**
+     * This operation terminates the 'coherent set' initiated by the matching
+     * call to {@link #beginCoherentChanges()}.
+     * 
+     * @throws  PreconditionNotMetException     if there is no matching call
+     *          to {@link #beginCoherentChanges()}.
+     * 
+     * @see     #beginCoherentChanges()
+     */
     public void endCoherentChanges();
 
+    /**
+     * This operation blocks the calling thread until either all data
+     * written by the reliable {@link DataWriter} entities is acknowledged by
+     * all matched reliable {@link DataReader} entities, or else the duration
+     * specified elapses, whichever happens first.
+     * 
+     * @throws  TimeoutException        if maxWait elapsed before all the
+     *          data was acknowledged.
+     */
     public void waitForAcknowledgments(Duration maxWait)
     throws TimeoutException;
 
+    /**
+     * This operation blocks the calling thread until either all data
+     * written by the reliable {@link DataWriter} entities is acknowledged by
+     * all matched reliable {@link DataReader} entities, or else the duration
+     * specified elapses, whichever happens first.
+     * 
+     * @throws  TimeoutException        if maxWait elapsed before all the
+     *          data was acknowledged.
+     */
     public void waitForAcknowledgments(long maxWait, TimeUnit unit)
     throws TimeoutException;
 
+    /**
+     * This operation retrieves the default value of the DataWriter QoS, that
+     * is, the QoS policies which will be used for newly created
+     * {@link DataWriter} entities in the case where the QoS policies are
+     * defaulted in the {@link #createDataWriter(Topic)} operation.
+     * 
+     * The values retrieved will match the set of values specified on the
+     * last successful call to
+     * {@link #setDefaultDataWriterQos(DataWriterQos)}, or else, if the call
+     * was never made, the default values identified by the DDS
+     * specification.
+     * 
+     * @see     #setDefaultDataWriterQos(DataWriterQos)
+     */
     public DataWriterQos getDefaultDataWriterQos();
+
+    /**
+     * This operation sets a default value of the DataWriter QoS policies,
+     * which will be used for newly created {@link DataWriter} entities in
+     * the case where the QoS policies are defaulted in the
+     * {@link #createDataWriter(Topic)} operation.
+     * 
+     * @throws  InconsistentPolicyException     if the resulting policies are
+     *          not self consistent; if they are not, the operation will have
+     *          no effect.
+     *
+     * @see     #getDefaultDataWriterQos()
+     */
     public void setDefaultDataWriterQos(DataWriterQos qos);
+
+    /**
+     * @see     #setDefaultDataWriterQos(DataWriterQos)
+     */
     public void setDefaultDataWriterQos(
             String qosLibraryName,
             String qosProfileName);
 
+    /**
+     * This operation copies the policies in the {@link Topic} QoS to the
+     * corresponding policies in the {@link DataWriter} QoS (replacing values
+     * in the DataWriter QoS, if present).
+     * 
+     * This is a "convenience" operation most useful in combination with the
+     * operations {@link #getDefaultDataWriterQos()} and
+     * {@link Topic#getQos()}. The operation can be used to merge the
+     * DataWriter default QoS policies with the corresponding ones on the
+     * Topic. The resulting QoS can then be used to create a new DataWriter
+     * or set its QoS.
+     * 
+     * This operation does not check the resulting DatWriter QoS for
+     * consistency. This is because the 'merged' QoS may not be the final
+     * one, as the application can still modify some policies prior to
+     * applying the policies to the DataWriter.
+     * 
+     * @param dst   the QoS whose policies are to be overwritten.
+     * @param src   the QoS from which the policies are to be taken.
+     */
     public void copyFromTopicQos(DataWriterQos dst, TopicQos src);
 }
Index: ftf_vote_01/srcJava/org/omg/dds/domain/DomainParticipant.java
===================================================================
--- ftf_vote_01/srcJava/org/omg/dds/domain/DomainParticipant.java	(revision 139)
+++ ftf_vote_01/srcJava/org/omg/dds/domain/DomainParticipant.java	(working copy)
@@ -25,12 +25,22 @@
 
 import org.omg.dds.core.Duration;
 import org.omg.dds.core.Entity;
+import org.omg.dds.core.InconsistentPolicyException;
 import org.omg.dds.core.InstanceHandle;
+import org.omg.dds.core.OutOfResourcesException;
+import org.omg.dds.core.PreconditionNotMetException;
 import org.omg.dds.core.modifiable.ModifiableTime;
+import org.omg.dds.core.policy.LivelinessQosPolicy;
+import org.omg.dds.core.policy.UserDataQosPolicy;
 import org.omg.dds.core.status.Status;
+import org.omg.dds.pub.DataWriter;
 import org.omg.dds.pub.Publisher;
 import org.omg.dds.pub.PublisherListener;
 import org.omg.dds.pub.PublisherQos;
+import org.omg.dds.sub.DataReader;
+import org.omg.dds.sub.QueryCondition;
+import org.omg.dds.sub.ReadCondition;
+import org.omg.dds.sub.Sample;
 import org.omg.dds.sub.Subscriber;
 import org.omg.dds.sub.SubscriberListener;
 import org.omg.dds.sub.SubscriberQos;
@@ -74,14 +84,32 @@
                DomainParticipantQos> {
     // --- Create Publisher: -------------------------------------------------
 
+    /**
+     * This operation creates a Publisher with default QoS policies and
+     * no PublisherListener.
+     * 
+     * The created Publisher belongs to the DomainParticipant that is its
+     * factory.
+     * 
+     * @see     #createPublisher(PublisherQos, PublisherListener, Collection)
+     */
     public Publisher createPublisher();
 
     /**
-     * Create a new publisher.
+     * This operation creates a Publisher.
      * 
-     * @param statuses  Of which status changes the listener should be
-     *                  notified. A null collection signifies all status
-     *                  changes.
+     * The created Publisher belongs to the DomainParticipant that is its
+     * factory.
+     * 
+     * @param   qos     The desired QoS policies. If the specified QoS
+     *                  policies are not consistent, the operation will
+     *                  fail and no Publisher will be created.
+     * @param   listener    The listener to be attached.
+     * @param   statuses    Of which status changes the listener should be
+     *                      notified. A null collection signifies all status
+     *                      changes.
+     *
+     * @see     #createPublisher()
      */
     public Publisher createPublisher(
             PublisherQos qos,
@@ -89,11 +117,17 @@
             Collection<Class<? extends Status<?, ?>>> statuses);
 
     /**
-     * Create a new publisher.
+     * This operation creates a Publisher.
      * 
-     * @param statuses  Of which status changes the listener should be
-     *                  notified. A null collection signifies all status
-     *                  changes.
+     * The created Publisher belongs to the DomainParticipant that is its
+     * factory.
+     * 
+     * @param   listener    The listener to be attached.
+     * @param   statuses    Of which status changes the listener should be
+     *                      notified. A null collection signifies all status
+     *                      changes.
+     * 
+     * @see     #createPublisher(PublisherQos, PublisherListener, Collection)
      */
     public Publisher createPublisher(
             String qosLibraryName,
@@ -103,14 +137,32 @@
 
     // --- Create Subscriber: ------------------------------------------------
 
+    /**
+     * This operation creates a Subscriber with default QoS policies and
+     * no SubscriberListener.
+     * 
+     * The created Subscriber belongs to the DomainParticipant that is its
+     * factory.
+     * 
+     * @see     #createSubscriber(SubscriberQos, SubscriberListener, Collection)
+     */
     public Subscriber createSubscriber();
 
     /**
-     * Create a new subscriber.
+     * This operation creates a Subscriber.
      * 
-     * @param statuses  Of which status changes the listener should be
-     *                  notified. A null collection signifies all status
-     *                  changes.
+     * The created Subscriber belongs to the DomainParticipant that is its
+     * factory.
+     * 
+     * @param   qos     The desired QoS policies. If the specified QoS
+     *                  policies are not consistent, the operation will
+     *                  fail and no Subscriber will be created.
+     * @param   listener    The listener to be attached.
+     * @param   statuses    Of which status changes the listener should be
+     *                      notified. A null collection signifies all status
+     *                      changes.
+     *
+     * @see     #createSubscriber()
      */
     public Subscriber createSubscriber(
             SubscriberQos qos,
@@ -118,11 +170,17 @@
             Collection<Class<? extends Status<?, ?>>> statuses);
 
     /**
-     * Create a new subscriber.
+     * This operation creates a Subscriber.
      * 
-     * @param statuses  Of which status changes the listener should be
-     *                  notified. A null collection signifies all status
-     *                  changes.
+     * The created Subscriber belongs to the DomainParticipant that is its
+     * factory.
+     * 
+     * @param   listener    The listener to be attached.
+     * @param   statuses    Of which status changes the listener should be
+     *                      notified. A null collection signifies all status
+     *                      changes.
+     * 
+     * @see     #createSubscriber(SubscriberQos, SubscriberListener, Collection)
      */
     public Subscriber createSubscriber(
             String qosLibraryName,
@@ -130,21 +188,57 @@
             SubscriberListener listener,
             Collection<Class<? extends Status<?, ?>>> statuses);
 
+    /**
+     * This operation allows access to the built-in Subscriber. Each
+     * DomainParticipant contains several built-in {@link Topic} objects as
+     * well as corresponding {@link DataReader} objects to access them. All
+     * these DataReader objects belong to a single built-in Subscriber.
+     * 
+     * The built-in Topics are used to communicate information about other
+     * DomainParticipant, Topic, {@link DataReader}, and {@link DataWriter}
+     * objects. 
+     */
     public Subscriber getBuiltinSubscriber();
 
 
     // --- Create Topic with implicit TypeSupport: ---------------------------
 
+    /**
+     * This operation creates a Topic with default QoS policies and no
+     * TopicListener.
+     * 
+     * The created Topic belongs to the DomainParticipant that is its
+     * factory.
+     * 
+     * @param   topicName   The name of the new Topic.
+     * @param   type        The type of all samples to be published and
+     *                      subscribed over the new Topic. The Service will
+     *                      attempt to locate an appropriate
+     *                      {@link TypeSupport} instance based on this type.
+     */
     public <TYPE> Topic<TYPE> createTopic(
             String topicName,
             Class<TYPE> type);
 
     /**
-     * Create a new topic.
+     * This operation creates a Topic with the desired QoS policies and
+     * attaches to it the specified TopicListener.
      * 
-     * @param statuses  Of which status changes the listener should be
-     *                  notified. A null collection signifies all status
-     *                  changes.
+     * The created Topic belongs to the DomainParticipant that is its
+     * factory.
+     * 
+     * @param   topicName   The name of the new Topic.
+     * @param   type        The type of all samples to be published and
+     *                      subscribed over the new Topic. The Service will
+     *                      attempt to locate an appropriate
+     *                      {@link TypeSupport} instance based on this type.
+     * @param   qos         The desired QoS policies. If the specified QoS
+     *                      policies are not consistent, the operation will
+     *                      fail and no Publisher will be created.
+     * @param   listener    The listener to be attached.
+     * @param   statuses    Of which status changes the listener should be
+     *                      notified. A null collection signifies all status
+     *                      changes.
      */
     public <TYPE> Topic<TYPE> createTopic(
             String topicName,
@@ -154,11 +248,20 @@
             Collection<Class<? extends Status<?, ?>>> statuses);
 
     /**
-     * Create a new topic.
+     * This operation creates a Topic with the desired QoS policies and
+     * attaches to it the specified TopicListener.
      * 
-     * @param statuses  Of which status changes the listener should be
-     *                  notified. A null collection signifies all status
-     *                  changes.
+     * The created Topic belongs to the DomainParticipant that is its
+     * factory.
+     * 
+     * @param   topicName   The name of the new Topic.
+     * @param   type        The type of all samples to be published and
+     *                      subscribed over the new Topic. The Service will
+     *                      attempt to locate an appropriate
+     *                      {@link TypeSupport} instance based on this type.
+     * @param   statuses    Of which status changes the listener should be
+     *                      notified. A null collection signifies all status
+     *                      changes.
      */
     public <TYPE> Topic<TYPE> createTopic(
             String topicName,
@@ -171,16 +274,40 @@
 
     // --- Create Topic with explicit TypeSupport: ---------------------------
 
+    /**
+     * This operation creates a Topic with default QoS policies and no
+     * TopicListener.
+     * 
+     * The created Topic belongs to the DomainParticipant that is its
+     * factory.
+     * 
+     * @param   topicName   The name of the new Topic.
+     * @param   type        A {@link TypeSupport} representing the type of
+     *                      all samples to be published and subscribed over
+     *                      the new Topic.
+     */
     public <TYPE> Topic<TYPE> createTopic(
             String topicName,
             TypeSupport<TYPE> type);
 
     /**
-     * Create a new topic.
+     * This operation creates a Topic with the desired QoS policies and
+     * attaches to it the specified TopicListener.
      * 
-     * @param statuses  Of which status changes the listener should be
-     *                  notified. A null collection signifies all status
-     *                  changes.
+     * The created Topic belongs to the DomainParticipant that is its
+     * factory.
+     * 
+     * @param   topicName   The name of the new Topic.
+     * @param   type        A {@link TypeSupport} representing the type of
+     *                      all samples to be published and subscribed over
+     *                      the new Topic.
+     * @param   qos         The desired QoS policies. If the specified QoS
+     *                      policies are not consistent, the operation will
+     *                      fail and no Publisher will be created.
+     * @param   listener    The listener to be attached.
+     * @param   statuses    Of which status changes the listener should be
+     *                      notified. A null collection signifies all status
+     *                      changes.
      */
     public <TYPE> Topic<TYPE> createTopic(
             String topicName,
@@ -190,8 +317,16 @@
             Collection<Class<? extends Status<?, ?>>> statuses);
 
     /**
-     * Create a new topic.
+     * This operation creates a Topic with the desired QoS policies and
+     * attaches to it the specified TopicListener.
      * 
+     * The created Topic belongs to the DomainParticipant that is its
+     * factory.
+     * 
+     * @param   topicName   The name of the new Topic.
+     * @param   type        A {@link TypeSupport} representing the type of
+     *                      all samples to be published and subscribed over
+     *                      the new Topic.
      * @param statuses  Of which status changes the listener should be
      *                  notified. A null collection signifies all status
      *                  changes.
@@ -207,70 +342,520 @@
 
     // --- Other operations: -------------------------------------------------
 
+    /**
+     * This operation gives access to an existing (or ready to exist) enabled
+     * Topic, based on its name. The operation takes as arguments the name of
+     * the Topic and a timeout.
+     * 
+     * If a Topic of the same name already exists, it gives access to it,
+     * otherwise it waits (blocks the caller) until another mechanism creates
+     * it (or the specified timeout occurs). This other mechanism can be
+     * another thread, a configuration tool, or some other middleware
+     * service. Note that the Topic is a local object that acts as a 'proxy'
+     * to designate the global concept of topic. Middleware implementations
+     * could choose to propagate topics and make remotely created topics
+     * locally available.
+     * 
+     * A Topic obtained by means of findTopic must also be closed by means of
+     * {@link Topic#close()} so that the local resources can be released. If
+     * a Topic is obtained multiple times by means of findTopic or
+     * {@link #createTopic(String, Class)}, it must also be closed that same
+     * number of times.
+     * 
+     * Regardless of whether the middleware chooses to propagate topics, the
+     * {@link Topic#close()} operation disposes of only the local proxy.
+     * 
+     * @return  a non-null Topic.
+     * 
+     * @throws  TimeoutException    if the specified timeout elapses and no
+     *                              suitable Topic could be found.
+     * 
+     * @see     #findTopic(String, long, TimeUnit)
+     */
     public <TYPE> Topic<TYPE> findTopic(
             String topicName,
             Duration timeout) throws TimeoutException;
+
+    /**
+     * This operation gives access to an existing (or ready to exist) enabled
+     * Topic, based on its name. The operation takes as arguments the name of
+     * the Topic and a timeout.
+     * 
+     * If a Topic of the same name already exists, it gives access to it,
+     * otherwise it waits (blocks the caller) until another mechanism creates
+     * it (or the specified timeout occurs). This other mechanism can be
+     * another thread, a configuration tool, or some other middleware
+     * service. Note that the Topic is a local object that acts as a 'proxy'
+     * to designate the global concept of topic. Middleware implementations
+     * could choose to propagate topics and make remotely created topics
+     * locally available.
+     * 
+     * A Topic obtained by means of findTopic must also be closed by means of
+     * {@link Topic#close()} so that the local resources can be released. If
+     * a Topic is obtained multiple times by means of findTopic or
+     * {@link #createTopic(String, Class)}, it must also be closed that same
+     * number of times.
+     * 
+     * Regardless of whether the middleware chooses to propagate topics, the
+     * {@link Topic#close()} operation disposes of only the local proxy.
+     * 
+     * @return  a non-null Topic.
+     * 
+     * @throws  TimeoutException    if the specified timeout elapses and no
+     *                              suitable Topic could be found.
+     * 
+     * @see     #findTopic(String, Duration)
+     */
     public <TYPE> Topic<TYPE> findTopic(
             String topicName,
             long timeout,
             TimeUnit unit)
             throws TimeoutException;
+
+    /**
+     * This operation gives access to an existing locally-created
+     * TopicDescription based on its name. The operation takes as argument
+     * the name of the TopicDescription.
+     * 
+     * If a TopicDescription of the same name already exists, it gives access
+     * to it, otherwise it returns null. The operation never blocks.
+     * 
+     * The operation may be used to locate any locally-created {@link Topic},
+     * {@link ContentFilteredTopic}, or {@link MultiTopic} object.
+     * 
+     * Unlike {@link #findTopic(String, Duration)}, the operation searches
+     * only among the locally created topics. Therefore, it should never
+     * create a new TopicDescription. The TopicDescription returned does not
+     * require an extra {@link TopicDescription#close()}. It is still
+     * possible to close the TopicDescription returned by this method,
+     * provided it has no readers or writers, but then it is really closed
+     * and subsequent lookups will fail.
+     * 
+     * If the operation fails to locate a TopicDescription, it returns null.
+     * 
+     * @param <TYPE>    The type of all samples subscribed to with the
+     *                  TopicDescription.
+     * @param name      The name of the TopicDescription to look up.
+     */
     public <TYPE> TopicDescription<TYPE> lookupTopicDescription(String name);
 
+    /**
+     * This operation creates a ContentFilteredTopic. A ContentFilteredTopic
+     * can be used to do content-based subscriptions.
+     * 
+     * @param <TYPE>                The type of all samples subscribed to
+     *                              with the new ContentFilteredTopic. It may
+     *                              be the same as the type of the
+     *                              relatedTopic or any supertype of that
+     *                              type.
+     * @param name                  The name of the new ContentFilteredTopic.
+     * @param relatedTopic          The related Topic being subscribed to.
+     *                              The ContentFilteredTopic only relates to
+     *                              samples published under this Topic,
+     *                              filtered according to their content.
+     * @param filterExpression      A logical expression that involves the
+     *                              values of some of the data fields in the
+     *                              sample.
+     * @param expressionParameters  Parameters to the filterExpression.
+     */
     public <TYPE> ContentFilteredTopic<TYPE> createContentFilteredTopic(
             String name,
             Topic<? extends TYPE> relatedTopic,
             String filterExpression,
             List<String> expressionParameters);
 
+    /**
+     * This operation creates a MultiTopic. A MultiTopic can be used to
+     * subscribe to multiple topics and combine/filter the received data into
+     * a resulting type. In particular, MultiTopic provides a content-based
+     * subscription mechanism.
+     * 
+     * @param   <TYPE>  The type of all samples subscribed to with the new
+     *                  MultiTopic.
+     * @param   name    The name of the new MultiTopic.
+     * @param   typeName The resulting type. The Service will attempt to
+     *                  locate an appropriate {@link TypeSupport} instance
+     *                  based on this type.
+     * @param   subscriptionExpression  The list of topics and the logic used
+     *          to combine filter and re-arrange the information from each
+     *          Topic.
+     * @param   expressionParameters    Parameters to the filterExpression.
+     */
     public <TYPE> MultiTopic<TYPE> createMultiTopic(
             String name,
             String typeName,
             String subscriptionExpression,
             List<String> expressionParameters);
 
+    /**
+     * This operation deletes all the entities that were created by means of
+     * the "create" operations on the DomainParticipant. That is, it deletes
+     * all contained {@link Publisher}, {@link Subscriber}, {@link Topic},
+     * {@link ContentFilteredTopic}, and {@link MultiTopic} objects.
+     * 
+     * Prior to deleting each contained entity, this operation will
+     * recursively call the corresponding closeContainedEntities operation on
+     * each contained entity (if applicable). This pattern is applied
+     * recursively. In this manner the operation closeContainedEntities on
+     * the DomainParticipant will end up deleting all the entities
+     * recursively contained in the DomainParticipant, that is also the
+     * {@link DataWriter}, {@link DataReader}, as well as the
+     * {@link QueryCondition} and {@link ReadCondition} objects belonging to
+     * the contained DataReaders.
+     * 
+     * Once closeContainedEntities returns successfully, the application may
+     * delete the DomainParticipant knowing that it has no contained
+     * entities.
+     * 
+     * @throws  PreconditionNotMetException     if any of the contained
+     *          entities is in a state where it cannot be closed.
+     */
     public void closeContainedEntities();
 
+    /**
+     * This operation allows an application to instruct the Service to
+     * locally ignore a remote domain participant. From that point onwards,
+     * the Service will locally behave as if the remote participant did not
+     * exist. This means it will ignore any {@link Topic}, publication, or
+     * subscription that originates on that domain participant.
+     * 
+     * This operation can be used, in conjunction with the discovery of
+     * remote participants offered by means of the "DCPSParticipant" built-in
+     * Topic, to provide, for example, access control. Application data can
+     * be associated with a DomainParticipant by means of the
+     * {@link UserDataQosPolicy}. This application data is propagated as a
+     * field in the built-in topic and can be used by an application to
+     * implement its own access control policy.
+     * 
+     * The domain participant to ignore is identified by the handle argument.
+     * This handle is the one that appears in the {@link Sample} retrieved
+     * when reading the data samples available for the built-in DataReader to
+     * the "DCPSParticipant" topic. The built-in {@link DataReader} is read
+     * with the same read/take operations used for any DataReader.
+     * 
+     * This operation is not required to be reversible. The Service offers no
+     * means to reverse it.
+     * 
+     * @throws  OutOfResourcesException if the Service is unable to ignore
+     *          the indicated participant because an internal resource has
+     *          been exhausted.
+     */
     public void ignoreParticipant(InstanceHandle handle);
+
+    /**
+     * This operation allows an application to instruct the Service to
+     * locally ignore a {@link Topic}. This means it will locally ignore any
+     * publication or subscription to the Topic.
+     * 
+     * This operation can be used to save local resources when the
+     * application knows that it will never publish or subscribe to data
+     * under certain topics.
+     * 
+     * The Topic to ignore is identified by the handle argument. This handle
+     * is the one that appears in the {@link Sample} retrieved when reading
+     * the data samples from the built-in {@link DataReader} to the
+     * "DCPSTopic" topic.
+     * 
+     * This operation is not required to be reversible. The Service offers no
+     * means to reverse it.
+     * 
+     * @throws  OutOfResourcesException if the Service is unable to ignore
+     *          the indicated topic because an internal resource has been
+     *          exhausted.
+     */
     public void ignoreTopic(InstanceHandle handle);
+
+    /**
+     * This operation allows an application to instruct the Service to
+     * locally ignore a remote publication; a publication is defined by the
+     * association of a topic name, and user data and partition set on the
+     * {@link Publisher}. After this call, any data written related to that
+     * publication will be ignored.
+     * 
+     * The {@link DataWriter} to ignore is identified by the handle argument.
+     * This handle is the one that appears in the {@link Sample} retrieved
+     * when reading the data samples from the built-in {@link DataReader} to
+     * the "DCPSPublication" topic.
+     * 
+     * This operation is not required to be reversible. The Service offers no
+     * means to reverse it.
+     * 
+     * @throws  OutOfResourcesException if the Service is unable to ignore
+     *          the indicated publication because an internal resource has
+     *          been exhausted.
+     */
     public void ignorePublication(InstanceHandle handle);
+
+    /**
+     * This operation allows an application to instruct the Service to
+     * locally ignore a remote subscription; a subscription is defined by the
+     * association of a topic name, and user data and partition set on the
+     * {@link Subscriber}. After this call, any data received related to that
+     * subscription will be ignored.
+     * 
+     * The {@link DataReader} to ignore is identified by the handle argument.
+     * This handle is the one that appears in the {@link Sample} retrieved
+     * when reading the data samples from the built-in DataReader to the
+     * "DCPSSubscription" topic.
+     * 
+     * This operation is not required to be reversible. The Service offers no
+     * means to reverse it.
+     * 
+     * @throws  OutOfResourcesException if the Service is unable to ignore
+     *          the indicated subscription because an internal resource has
+     *          been exhausted.
+     */
     public void ignoreSubscription(InstanceHandle handle);
 
+    /**
+     * This operation retrieves the domain ID used to create the
+     * DomainParticipant. The domain ID identifies the DDS domain to which
+     * the DomainParticipant belongs. Each DDS domain represents a separate
+     * data "communication plane" isolated from other domains.
+     */
     public int getDomainId();
 
+    /**
+     * This operation manually asserts the liveliness of the
+     * DomainParticipant. This is used in combination with the
+     * {@link LivelinessQosPolicy} to indicate to the Service that the entity
+     * remains active.
+     * 
+     * This operation needs to only be used if the DomainParticipant contains
+     * {@link DataWriter} entities with the
+     * {@link LivelinessQosPolicy#getKind()} set to
+     * {@link LivelinessQosPolicy.Kind#MANUAL_BY_PARTICIPANT} and it only
+     * affects the liveliness of those DataWriter entities. Otherwise, it has
+     * no effect.
+     * 
+     * <b>Note</b> - Writing data via the {@link DataWriter#write(Object)}
+     * operation on a DataWriter asserts liveliness on the DataWriter itself
+     * and its DomainParticipant. Consequently the use of assertLiveliness is
+     * only needed if the application is not writing data regularly.
+     */
     public void assertLiveliness();
 
+    /**
+     * This operation retrieves the default value of the Publisher QoS, that
+     * is, the QoS policies which will be used for newly created
+     * {@link Publisher} entities in the case where the QoS policies are
+     * defaulted in the {@link #createPublisher()} operation.
+     * 
+     * The values retrieved will match the set of values specified on the
+     * last successful call to {@link #setDefaultPublisherQos(PublisherQos)},
+     * or else, if the call was never made, the default values identified by
+     * the DDS specification.
+     * 
+     * @see     #setDefaultPublisherQos(PublisherQos)
+     */
     public PublisherQos getDefaultPublisherQos();
+
+    /**
+     * This operation sets a default value of the Publisher QoS policies,
+     * which will be used for newly created {@link Publisher} entities in the
+     * case where the QoS policies are defaulted in the
+     * {@link #createPublisher()} operation.
+     * 
+     * @throws  InconsistentPolicyException     if the resulting policies are
+     *          not self consistent; in that case, the operation will have no
+     *          effect.
+     *
+     * @see     #getDefaultPublisherQos()
+     */
     public void setDefaultPublisherQos(PublisherQos qos);
+
+    /**
+     * @see     #setDefaultPublisherQos(PublisherQos)
+     */
     public void setDefaultPublisherQos(
             String qosLibraryName,
             String qosProfileName);
 
+    /**
+     * This operation retrieves the default value of the Subscriber QoS, that
+     * is, the QoS policies which will be used for newly created
+     * {@link Subscriber} entities in the case where the QoS policies are
+     * defaulted in the {@link #createSubscriber()} operation.
+     * 
+     * The values retrieved will match the set of values specified on the
+     * last successful call to
+     * {@link #setDefaultSubscriberQos(SubscriberQos)}, or else, if the call
+     * was never made, the default values identified by the DDS
+     * specification.
+     * 
+     * @see     #setDefaultSubscriberQos(SubscriberQos)
+     */
     public SubscriberQos getDefaultSubscriberQos();
+
+    /**
+     * This operation sets a default value of the Subscriber QoS policies
+     * that will be used for newly created {@link Subscriber} entities in the
+     * case where the QoS policies are defaulted in the
+     * {@link #createSubscriber()} operation.
+     * 
+     * @throws  InconsistentPolicyException     if the resulting policies are
+     *          not self consistent; in that case, the operation will have no
+     *          effect.
+     *
+     * @see     #getDefaultSubscriberQos()
+     */
     public void setDefaultSubscriberQos(SubscriberQos qos);
+
+    /**
+     * @see     #setDefaultSubscriberQos(SubscriberQos)
+     */
     public void setDefaultSubscriberQos(
             String qosLibraryName,
             String qosProfileName);
 
+    /**
+     * This operation retrieves the default value of the Topic QoS, that is,
+     * the QoS policies which will be used for newly created {@link Topic}
+     * entities in the case where the QoS policies are defaulted in the
+     * {@link #createTopic(String, Class)} operation.
+     * 
+     * The values retrieved will match the set of values specified on the
+     * last successful call to {@link #setDefaultTopicQos(TopicQos)}, or
+     * else, if the call was never made, the default values identified by the
+     * DDS specification.
+     * 
+     * @see     #setDefaultTopicQos(TopicQos)
+     */
     public TopicQos getDefaultTopicQos();
+
+    /**
+     * This operation sets a default value of the Topic QoS policies, which
+     * will be used for newly created {@link Topic} entities in the case
+     * where the QoS policies are defaulted in the
+     * {@link #createTopic(String, Class)} operation.
+     * 
+     * @throws  InconsistentPolicyException     if the resulting policies are
+     *          not self consistent; in that case, the operation will have no
+     *          effect.
+     *
+     * @see     #getDefaultTopicQos()
+     */
     public void setDefaultTopicQos(TopicQos qos);
+
+    /**
+     * @see     #setDefaultTopicQos(TopicQos)
+     */
     public void setDefaultTopicQos(
             String qosLibraryName,
             String qosProfileName);
 
+    /**
+     * This operation retrieves the list of DomainParticipants that have been
+     * discovered in the domain and that the application has not indicated
+     * should be "ignored" by means of the
+     * {@link #ignoreParticipant(InstanceHandle)} operation.
+     * 
+     * @param   participantHandles      a container, into which this method
+     *          will place handles to the discovered participants.
+     * 
+     * @return  participantHandles, as a convenience to facilitate chaining.
+     * 
+     * @throws  UnsupportedOperationException   If the infrastructure does
+     *          not locally maintain the connectivity information.
+     */
     public Collection<InstanceHandle> getDiscoveredParticipants(
             Collection<InstanceHandle> participantHandles);
+
+    /**
+     * This operation retrieves information on a DomainParticipant that has
+     * been discovered on the network. The participant must be in the same
+     * domain as the participant on which this operation is invoked and must
+     * not have been "ignored" by means of the
+     * {@link #ignoreParticipant(InstanceHandle)} operation.
+     * 
+     * Use the operation {@link #getDiscoveredParticipants(Collection)} to
+     * find the DomainParticipants that are currently discovered.
+     * 
+     * @param   participantData         a container, into which this method
+     *          will store the participant data.
+     * @param   participantHandle       a handle to the participant, the data
+     *          of which is to be retrieved.
+     * 
+     * @return  participantData, as a convenience to facilitate chaining.
+     * 
+     * @throws  PreconditionNotMetException     if the participantHandle
+     *          does not correspond to a DomainParticipant such as is
+     *          described above.
+     * @throws  UnsupportedOperationException   If the infrastructure does
+     *          not locally maintain the connectivity information.
+     */
     public ParticipantBuiltinTopicData getDiscoveredParticipantData(
             ParticipantBuiltinTopicData participantData,
             InstanceHandle participantHandle);
 
+    /**
+     * This operation retrieves the list of {@link Topic}s that have been
+     * discovered in the domain and that the application has not indicated
+     * should be "ignored" by means of the
+     * {@link #ignoreTopic(InstanceHandle)} operation.
+     * 
+     * @param   topicHandles    a container, into which this method
+     *          will place handles to the discovered topics.
+     * 
+     * @return  topicHandles, as a convenience to facilitate chaining.
+     * 
+     * @throws  UnsupportedOperationException   If the infrastructure does
+     *          not locally maintain the connectivity information.
+     */
     public Collection<InstanceHandle> getDiscoveredTopics(
             Collection<InstanceHandle> topicHandles);
+
+    /**
+     * This operation retrieves information on a {@link Topic} that has
+     * been discovered on the network. The topic must be in the same
+     * domain as the participant on which this operation is invoked and must
+     * not have been "ignored" by means of the
+     * {@link #ignoreTopic(InstanceHandle)} operation.
+     * 
+     * Use the operation {@link #getDiscoveredTopics(Collection)} to
+     * find the Topics that are currently discovered.
+     * 
+     * @param   topicData       a container, into which this method
+     *          will store the participant data.
+     * @param   topicHandle     a handle to the topic, the data
+     *          of which is to be retrieved.
+     * 
+     * @return  topicData, as a convenience to facilitate chaining.
+     * 
+     * @throws  PreconditionNotMetException     if the topicHandle
+     *          does not correspond to a Topic such as is described above.
+     * @throws  UnsupportedOperationException   If the infrastructure does
+     *          not locally maintain the connectivity information or if the
+     *          infrastructure does not hold the information necessary to
+     *          fill in the topicData.
+     */
     public TopicBuiltinTopicData getDiscoveredTopicData(
             TopicBuiltinTopicData topicData,
             InstanceHandle topicHandle);
 
+    /**
+     * This operation checks whether or not the given handle represents an
+     * {@link Entity} that was created from the DomainParticipant. The
+     * containment applies recursively. That is, it applies both to entities
+     * ({@link TopicDescription}, {@link Publisher}, or {@link Subscriber})
+     * created directly using the DomainParticipant as well as entities
+     * created using a contained Publisher or Subscriber as the factory, and
+     * so forth.
+     * 
+     * The instance handle for an Entity may be obtained from built-in topic
+     * data, from various statuses, or from the Entity operation
+     * {@link Entity#getInstanceHandle()}.
+     */
     public boolean containsEntity(InstanceHandle handle);
 
+    /**
+     * This operation returns the current value of the time that the service
+     * uses to time stamp data writes and to set the reception time stamp for
+     * the data updates it receives.
+     * 
+     * @param   currentTime     a container for the current time, which the
+     *          Service will overwrite with the result of this operation.
+     * @return  currentTime, as a convenience to facilitate chaining.
+     */
     public ModifiableTime getCurrentTime(ModifiableTime currentTime);
 }
Index: ftf_vote_01/srcJava/org/omg/dds/domain/DomainParticipantFactory.java
===================================================================
--- ftf_vote_01/srcJava/org/omg/dds/domain/DomainParticipantFactory.java	(revision 139)
+++ ftf_vote_01/srcJava/org/omg/dds/domain/DomainParticipantFactory.java	(working copy)
@@ -22,6 +22,8 @@
 
 import org.omg.dds.core.Bootstrap;
 import org.omg.dds.core.DDSObject;
+import org.omg.dds.core.Entity;
+import org.omg.dds.core.InconsistentPolicyException;
 import org.omg.dds.core.status.Status;
 
 
@@ -39,8 +41,17 @@
     // -----------------------------------------------------------------------
 
     /**
+     * This operation returns the per-Bootstrap DomainParticipantFactory
+     * singleton. The operation is idempotent, that is, it can be called
+     * multiple times without side effects, and each time it will return a
+     * DomainParticipantFactory instance that is equal to the previous
+     * results.
+     * 
      * @param bootstrap Identifies the Service instance to which the
      *                  object will belong.
+     *
+     * @see     Bootstrap
+     * @see     Object#equals(Object)
      */
     public static DomainParticipantFactory getInstance(Bootstrap bootstrap) {
         return bootstrap.getSPI().getParticipantFactory();
@@ -55,18 +66,38 @@
     /**
      * Create a new participant in the domain with ID 0 having default QoS
      * and no listener.
+     * 
+     * @see     #createParticipant(int)
+     * @see     #createParticipant(int, DomainParticipantQos, DomainParticipantListener, Collection)
      */
     public abstract DomainParticipant createParticipant();
 
+    /**
+     * This operation creates a new DomainParticipant object. The
+     * DomainParticipant signifies that the calling application intends to
+     * join the domain identified by the domainId argument.
+     * 
+     * @see     #createParticipant()
+     * @see     #createParticipant(int, DomainParticipantQos, DomainParticipantListener, Collection)
+     */
     public abstract DomainParticipant createParticipant(
             int domainId);
 
     /**
-     * Create a new domain participant.
+     * This operation creates a new DomainParticipant object having default
+     * QoS and no listener. The DomainParticipant signifies that the calling
+     * application intends to join the domain identified by the domainId
+     * argument.
      * 
      * @param statuses  Of which status changes the listener should be
      *                  notified. A null collection signifies all status
      *                  changes.
+     *
+     * @throws  InconsistentPolicyException     if the specified QoS policies
+     *          are not consistent.
+     *
+     * @see     #createParticipant()
+     * @see     #createParticipant(int)
      */
     public abstract DomainParticipant createParticipant(
             int domainId,
@@ -80,6 +111,8 @@
      * @param statuses  Of which status changes the listener should be
      *                  notified. A null collection signifies all status
      *                  changes.
+     *
+     * @see     #createParticipant(int, DomainParticipantQos, DomainParticipantListener, Collection)
      */
     public abstract DomainParticipant createParticipant(
             int domainId,
@@ -88,13 +121,74 @@
             DomainParticipantListener listener,
             Collection<Class<? extends Status<?, ?>>> statuses);
 
+    /**
+     * This operation retrieves a previously created DomainParticipant
+     * belonging to specified domain ID. If no such DomainParticipant exists,
+     * the operation will return null.
+     * 
+     * If multiple DomainParticipant entities belonging to that domain ID
+     * exist, then the operation will return one of them. It is not specified
+     * which one.
+     */
     public abstract DomainParticipant lookupParticipant(int domainId);
 
+    /**
+     * This operation returns the value of the DomainParticipantFactory QoS
+     * policies.
+     * 
+     * @see     #setQos(DomainParticipantFactoryQos)
+     */
     public abstract DomainParticipantFactoryQos getQos();
+
+    /**
+     * This operation sets the value of the DomainParticipantFactory QoS
+     * policies. These policies control the behavior of the object, a factory
+     * for entities.
+     * 
+     * Note that despite having QoS, the DomainParticipantFactory is not an
+     * {@link Entity}.
+     * 
+     * @throws  InconsistentPolicyException     if the resulting policies are
+     *          not self consistent; in that case, the operation will have no
+     *          effect.
+     *
+     * @see     #getQos()
+     */
     public abstract void setQos(DomainParticipantFactoryQos qos);
 
+    /**
+     * This operation retrieves the default value of the DomainParticipant
+     * QoS, that is, the QoS policies which will be used for newly created
+     * {@link DomainParticipant} entities in the case where the QoS policies
+     * are defaulted in the {@link #createParticipant()} operation.
+     * 
+     * The values retrieved will match the set of values specified on the
+     * last successful call to
+     * {@link #setDefaultParticipantQos(DomainParticipantQos)}, or else, if
+     * the call was never made, the default values identified by the DDS
+     * specification.
+     * 
+     * @see     #setDefaultParticipantQos(DomainParticipantQos)
+     */
     public abstract DomainParticipantQos getDefaultParticipantQos();
+
+    /**
+     * This operation sets a default value of the DomainParticipant QoS
+     * policies which will be used for newly created
+     * {@link DomainParticipant} entities in the case where the QoS policies
+     * are defaulted in the {@link #createParticipant()} operation.
+     * 
+     * @throws  InconsistentPolicyException     if the resulting policies are
+     *          not self consistent; in that case, the operation will have no
+     *          effect.
+     *
+     * @see     #getDefaultParticipantQos()
+     */
     public abstract void setDefaultParticipantQos(DomainParticipantQos qos);
+
+    /**
+     * @see     #setDefaultParticipantQos(DomainParticipantQos)
+     */
     public abstract void setDefaultParticipantQos(
             String qosLibraryName,
             String qosProfileName);
Index: ftf_vote_01/srcJava/org/omg/dds/core/EntityQos.java
===================================================================
--- ftf_vote_01/srcJava/org/omg/dds/core/EntityQos.java	(revision 139)
+++ ftf_vote_01/srcJava/org/omg/dds/core/EntityQos.java	(working copy)
@@ -21,11 +21,31 @@
 import java.util.Map;
 
 import org.omg.dds.core.policy.QosPolicy;
+import org.omg.dds.domain.DomainParticipant;
+import org.omg.dds.pub.DataWriter;
+import org.omg.dds.pub.Publisher;
+import org.omg.dds.sub.DataReader;
+import org.omg.dds.sub.Subscriber;
+import org.omg.dds.topic.Topic;
 import org.omg.dds.type.Extensibility;
 
 
 /**
- * A base interface for all entity QoS types.
+ * The Data-Distribution Service (DDS) relies on the use of QoS. A QoS
+ * (Quality of Service) is a set of characteristics that controls some aspect
+ * of the behavior of the DDS Service. QoS is comprised of individual QoS
+ * policies (objects of type deriving from {@link QosPolicy}).
+ * 
+ * QoS (i.e., a collection of QosPolicy objects) may be associated with all
+ * {@link Entity} objects in the system such as {@link Topic},
+ * {@link DataWriter}, {@link DataReader}, {@link Publisher},
+ * {@link Subscriber}, and {@link DomainParticipant}.
+ * 
+ * Some QosPolicy values may not be consistent with other ones. When a set of
+ * QosPolicy is passed ({@link Entity#setQos(EntityQos)} operations), the set
+ * resulting from adding the new policies on top of the previous is checked
+ * for consistency. If the resulting QoS is inconsistent, the change of QoS
+ * operation fails and the previous values are retained.
  */
 @Extensibility(Extensibility.Kind.MUTABLE_EXTENSIBILITY)
 public interface EntityQos<UNMOD_SELF extends EntityQos<UNMOD_SELF, MOD_SELF>,
Index: ftf_vote_01/srcJava/org/omg/dds/core/DDSObject.java
===================================================================
--- ftf_vote_01/srcJava/org/omg/dds/core/DDSObject.java	(revision 139)
+++ ftf_vote_01/srcJava/org/omg/dds/core/DDSObject.java	(working copy)
@@ -19,6 +19,9 @@
 package org.omg.dds.core;
 
 
+/**
+ * A supertype of all DDS classes and interfaces.
+ */
 public interface DDSObject {
     /**
      * @return  the {@link Bootstrap} object that directly or indirectly
Index: ftf_vote_01/srcJava/org/omg/dds/core/status/RequestedDeadlineMissedStatus.java
===================================================================
--- ftf_vote_01/srcJava/org/omg/dds/core/status/RequestedDeadlineMissedStatus.java	(revision 139)
+++ ftf_vote_01/srcJava/org/omg/dds/core/status/RequestedDeadlineMissedStatus.java	(working copy)
@@ -20,9 +20,18 @@
 
 import org.omg.dds.core.Bootstrap;
 import org.omg.dds.core.modifiable.ModifiableInstanceHandle;
+import org.omg.dds.core.policy.DeadlineQosPolicy;
 import org.omg.dds.sub.DataReader;
 
 
+/**
+ * The deadline that the {@link DataReader} was expecting through its
+ * {@link DeadlineQosPolicy} was not respected for a specific instance.
+ *
+ * @param <TYPE>    The data type of the source {@link DataReader}.
+ * 
+ * @see OfferedDeadlineMissedStatus
+ */
 public abstract class RequestedDeadlineMissedStatus<TYPE>
 extends Status<RequestedDeadlineMissedStatus<TYPE>, DataReader<TYPE>> {
     // -----------------------------------------------------------------------
@@ -60,15 +69,23 @@
     // -----------------------------------------------------------------------
 
     /**
-     * @return the totalCount
+     * Total cumulative number of missed deadlines detected for any instance
+     * read by the {@link DataReader}. Missed deadlines accumulate; that is,
+     * each deadline period the totalCount will be incremented by one for
+     * each instance for which data was not received.
      */
     public abstract int getTotalCount();
 
     /**
-     * @return the totalCountChange
+     * The incremental number of deadlines detected since the last time the
+     * listener was called or the status was read.
      */
     public abstract int getTotalCountChange();
 
+    /**
+     * Handle to the last instance in the {@link DataReader} for which a
+     * deadline was detected.
+     */
     public abstract ModifiableInstanceHandle getLastInstanceHandle();
 
 }
Index: ftf_vote_01/srcJava/org/omg/dds/core/status/PublicationMatchedStatus.java
===================================================================
--- ftf_vote_01/srcJava/org/omg/dds/core/status/PublicationMatchedStatus.java	(revision 139)
+++ ftf_vote_01/srcJava/org/omg/dds/core/status/PublicationMatchedStatus.java	(working copy)
@@ -21,8 +21,19 @@
 import org.omg.dds.core.Bootstrap;
 import org.omg.dds.core.modifiable.ModifiableInstanceHandle;
 import org.omg.dds.pub.DataWriter;
+import org.omg.dds.sub.DataReader;
+import org.omg.dds.topic.Topic;
 
 
+/**
+ * The {@link DataWriter} has found a {@link DataReader} that matches the
+ * {@link Topic} and has compatible QoS, or has ceased to be matched with a
+ * DataReader that was previously considered to be matched.
+ *
+ * @param <TYPE>    The data type of the source {@link DataWriter}.
+ * 
+ * @see SubscriptionMatchedStatus
+ */
 public abstract class PublicationMatchedStatus<TYPE>
 extends Status<PublicationMatchedStatus<TYPE>, DataWriter<TYPE>> {
     // -----------------------------------------------------------------------
@@ -60,25 +71,35 @@
     // -----------------------------------------------------------------------
 
     /**
-     * @return the totalCount
+     * Total cumulative count the concerned {@link DataWriter} discovered a
+     * "match" with a {@link DataReader}. That is, it found a DataReader for
+     * the same {@link Topic} with a requested QoS that is compatible with
+     * that offered by the DataWriter.
      */
     public abstract int getTotalCount();
 
     /**
-     * @return the totalCountChange
+     * The change in totalCcount since the last time the listener was called
+     * or the status was read.
      */
     public abstract int getTotalCountChange();
 
     /**
-     * @return the currentCount
+     * The number of {@link DataReader}s currently matched to the concerned
+     * {@link DataWriter}.
      */
     public abstract int getCurrentCount();
 
     /**
-     * @return the currentCountChange
+     * The change in currentCount since the last time the listener was called
+     * or the status was read.
      */
     public abstract int getCurrentCountChange();
 
+    /**
+     * Handle to the last {@link DataReader} that matched the
+     * {@link DataWriter}, causing the status to change.
+     */
     public abstract ModifiableInstanceHandle getLastSubscriptionHandle();
 
 }
Index: ftf_vote_01/srcJava/org/omg/dds/core/status/OfferedDeadlineMissedStatus.java
===================================================================
--- ftf_vote_01/srcJava/org/omg/dds/core/status/OfferedDeadlineMissedStatus.java	(revision 139)
+++ ftf_vote_01/srcJava/org/omg/dds/core/status/OfferedDeadlineMissedStatus.java	(working copy)
@@ -20,9 +20,18 @@
 
 import org.omg.dds.core.Bootstrap;
 import org.omg.dds.core.modifiable.ModifiableInstanceHandle;
+import org.omg.dds.core.policy.DeadlineQosPolicy;
 import org.omg.dds.pub.DataWriter;
 
 
+/**
+ * The deadline that the {@link DataWriter} has committed through its
+ * {@link DeadlineQosPolicy} was not respected for a specific instance.
+ *
+ * @param <TYPE>    The data type of the source {@link DataWriter}.
+ * 
+ * @see RequestedDeadlineMissedStatus
+ */
 public abstract class OfferedDeadlineMissedStatus<TYPE>
 extends Status<OfferedDeadlineMissedStatus<TYPE>, DataWriter<TYPE>> {
     // -----------------------------------------------------------------------
@@ -60,15 +69,23 @@
     // -----------------------------------------------------------------------
 
     /**
-     * @return the totalCount
+     * Total cumulative number of offered deadline periods elapsed during
+     * which a DataWriter failed to provide data. Missed deadlines
+     * accumulate; that is, each deadline period the totalCount will be
+     * incremented by one.
      */
     public abstract int getTotalCount();
 
     /**
-     * @return the totalCountChange
+     * The change in totalCount since the last time the listener was called
+     * or the status was read.
      */
     public abstract int getTotalCountChange();
 
+    /**
+     * Handle to the last instance in the {@link DataWriter} for which an
+     * offered deadline was missed.
+     */
     public abstract ModifiableInstanceHandle getLastInstanceHandle();
 
 }
Index: ftf_vote_01/srcJava/org/omg/dds/core/status/DataAvailableStatus.java
===================================================================
--- ftf_vote_01/srcJava/org/omg/dds/core/status/DataAvailableStatus.java	(revision 139)
+++ ftf_vote_01/srcJava/org/omg/dds/core/status/DataAvailableStatus.java	(working copy)
@@ -22,6 +22,13 @@
 import org.omg.dds.sub.DataReader;
 
 
+/**
+ * New information is available.
+ *
+ * @param <TYPE>    The data type of the source {@link DataReader}.
+ * 
+ * @see DataOnReadersStatus
+ */
 public abstract class DataAvailableStatus<TYPE>
 extends Status<DataAvailableStatus<TYPE>, DataReader<TYPE>> {
     // -----------------------------------------------------------------------
Index: ftf_vote_01/srcJava/org/omg/dds/core/status/SubscriptionMatchedStatus.java
===================================================================
--- ftf_vote_01/srcJava/org/omg/dds/core/status/SubscriptionMatchedStatus.java	(revision 139)
+++ ftf_vote_01/srcJava/org/omg/dds/core/status/SubscriptionMatchedStatus.java	(working copy)
@@ -20,9 +20,20 @@
 
 import org.omg.dds.core.Bootstrap;
 import org.omg.dds.core.modifiable.ModifiableInstanceHandle;
+import org.omg.dds.pub.DataWriter;
 import org.omg.dds.sub.DataReader;
+import org.omg.dds.topic.Topic;
 
 
+/**
+ * The {@link DataReader} has found a {@link DataWriter} that matches the
+ * {@link Topic} and has compatible QoS, or has ceased to be matched with a
+ * DataWriter that was previously considered to be matched.
+ *
+ * @param <TYPE>    The data type of the source {@link DataReader}.
+ * 
+ * @see PublicationMatchedStatus
+ */
 public abstract class SubscriptionMatchedStatus<TYPE>
 extends Status<SubscriptionMatchedStatus<TYPE>, DataReader<TYPE>> {
     // -----------------------------------------------------------------------
@@ -60,25 +71,35 @@
     // -----------------------------------------------------------------------
 
     /**
-     * @return the totalCount
+     * Total cumulative count the concerned {@link DataReader} discovered a
+     * "match" with a {@link DataWriter}. That is, it found a DataWriter for
+     * the same {@link Topic} with a requested QoS that is compatible with
+     * that offered by the DataReader.
      */
     public abstract int getTotalCount();
 
     /**
-     * @return the totalCountChange
+     * The change in totalCount since the last time the listener was called
+     * or the status was read.
      */
     public abstract int getTotalCountChange();
 
     /**
-     * @return the currentCount
+     * The number of {@link DataWriter}s currently matched to the concerned
+     * {@link DataReader}.
      */
     public abstract int getCurrentCount();
 
     /**
-     * @return the currentCountChange
+     * The change in currentCount since the last time the listener was called
+     * or the status was read.
      */
     public abstract int getCurrentCountChange();
 
+    /**
+     * Handle to the last {@link DataWriter} that matched the
+     * {@link DataReader}, causing the status to change.
+     */
     public abstract ModifiableInstanceHandle getLastPublicationHandle();
 
 }
Index: ftf_vote_01/srcJava/org/omg/dds/core/status/RequestedIncompatibleQosStatus.java
===================================================================
--- ftf_vote_01/srcJava/org/omg/dds/core/status/RequestedIncompatibleQosStatus.java	(revision 139)
+++ ftf_vote_01/srcJava/org/omg/dds/core/status/RequestedIncompatibleQosStatus.java	(working copy)
@@ -23,9 +23,18 @@
 import org.omg.dds.core.Bootstrap;
 import org.omg.dds.core.policy.QosPolicy;
 import org.omg.dds.core.policy.QosPolicyCount;
+import org.omg.dds.pub.DataWriter;
 import org.omg.dds.sub.DataReader;
+import org.omg.dds.topic.Topic;
 
 
+/**
+ * A {@link QosPolicy} value was incompatible with what is offered.
+ *
+ * @param <TYPE>    The data type of the source {@link DataReader}.
+ * 
+ * @see OfferedIncompatibleQosStatus
+ */
 public abstract class RequestedIncompatibleQosStatus<TYPE>
 extends Status<RequestedIncompatibleQosStatus<TYPE>, DataReader<TYPE>> {
     // -----------------------------------------------------------------------
@@ -63,21 +72,32 @@
     // -----------------------------------------------------------------------
 
     /**
-     * @return the totalCount
+     * Total cumulative number of times the concerned {@link DataReader}
+     * discovered a {@link DataWriter} for the same {@link Topic} with an
+     * offered QoS that was incompatible with that requested by the
+     * DataReader.
      */
     public abstract int getTotalCount();
 
     /**
-     * @return the totalCountChange
+     * The change in totalCount since the last time the listener was called
+     * or the status was read.
      */
     public abstract int getTotalCountChange();
 
     /**
-     * @return the lastPolicyId
+     * The {@link org.omg.dds.core.policy.QosPolicy.Id} of one of the
+     * policies that was found to be incompatible the last time an
+     * incompatibility was detected.
      */
     public abstract QosPolicy.Id getLastPolicyId();
 
     /**
+     * A list containing for each policy the total number of times that the
+     * concerned {@link DataReader} discovered a {@link DataWriter} for the
+     * same {@link Topic} with an offered QoS that is incompatible with that
+     * requested by the DataReader.
+     * 
      * @return  an unmodifiable set.
      */
     public abstract Set<QosPolicyCount> getPolicies();
Index: ftf_vote_01/srcJava/org/omg/dds/core/status/DataOnReadersStatus.java
===================================================================
--- ftf_vote_01/srcJava/org/omg/dds/core/status/DataOnReadersStatus.java	(revision 139)
+++ ftf_vote_01/srcJava/org/omg/dds/core/status/DataOnReadersStatus.java	(working copy)
@@ -22,6 +22,11 @@
 import org.omg.dds.sub.Subscriber;
 
 
+/**
+ * New information is available.
+ * 
+ * @see DataAvailableStatus
+ */
 public abstract class DataOnReadersStatus
 extends Status<DataOnReadersStatus, Subscriber> {
     // -----------------------------------------------------------------------
Index: ftf_vote_01/srcJava/org/omg/dds/core/status/LivelinessLostStatus.java
===================================================================
--- ftf_vote_01/srcJava/org/omg/dds/core/status/LivelinessLostStatus.java	(revision 139)
+++ ftf_vote_01/srcJava/org/omg/dds/core/status/LivelinessLostStatus.java	(working copy)
@@ -19,9 +19,20 @@
 package org.omg.dds.core.status;
 
 import org.omg.dds.core.Bootstrap;
+import org.omg.dds.core.policy.LivelinessQosPolicy;
 import org.omg.dds.pub.DataWriter;
+import org.omg.dds.sub.DataReader;
 
 
+/**
+ * The liveliness that the {@link DataWriter} has committed through its
+ * {@link LivelinessQosPolicy} was not respected; thus {@link DataReader}
+ * entities will consider the DataWriter as no longer "active."
+ *
+ * @param <TYPE>    The data type of the source {@link DataWriter}.
+ * 
+ * @see SubscriptionMatchedStatus
+ */
 public abstract class LivelinessLostStatus<TYPE>
 extends Status<LivelinessLostStatus<TYPE>, DataWriter<TYPE>> {
     // -----------------------------------------------------------------------
@@ -59,12 +70,17 @@
     // -----------------------------------------------------------------------
 
     /**
-     * @return the totalCount
+     * Total cumulative number of times that a previously-alive
+     * {@link DataWriter} became not alive due to a failure to actively
+     * signal its liveliness within its offered liveliness period. This count
+     * does not change when an already not alive DataWriter simply remains
+     * not alive for another liveliness period.
      */
     public abstract int getTotalCount();
 
     /**
-     * @return the totalCountChange
+     * The change in totalCount since the last time the listener was called
+     * or the status was read.
      */
     public abstract int getTotalCountChange();
 
Index: ftf_vote_01/srcJava/org/omg/dds/core/status/InconsistentTopicStatus.java
===================================================================
--- ftf_vote_01/srcJava/org/omg/dds/core/status/InconsistentTopicStatus.java	(revision 139)
+++ ftf_vote_01/srcJava/org/omg/dds/core/status/InconsistentTopicStatus.java	(working copy)
@@ -22,6 +22,11 @@
 import org.omg.dds.topic.Topic;
 
 
+/**
+ * Another topic exists with the same name but different characteristics.
+ * 
+ * @param <TYPE>    The data type of the source {@link Topic}
+ */
 public abstract class InconsistentTopicStatus<TYPE>
 extends Status<InconsistentTopicStatus<TYPE>, Topic<TYPE>> {
     // -----------------------------------------------------------------------
@@ -59,12 +64,15 @@
     // -----------------------------------------------------------------------
 
     /**
-     * @return the totalCount
+     * Total cumulative count of the {@link Topic}s discovered whose name
+     * matches the Topic to which this status is attached and whose type is
+     * inconsistent with the Topic.
      */
     public abstract int getTotalCount();
 
     /**
-     * @return the totalCountChange
+     * The incremental number of inconsistent topics discovered since the
+     * last time the listener was called or the status was read.
      */
     public abstract int getTotalCountChange();
 
Index: ftf_vote_01/srcJava/org/omg/dds/core/status/SampleLostStatus.java
===================================================================
--- ftf_vote_01/srcJava/org/omg/dds/core/status/SampleLostStatus.java	(revision 139)
+++ ftf_vote_01/srcJava/org/omg/dds/core/status/SampleLostStatus.java	(working copy)
@@ -20,8 +20,14 @@
 
 import org.omg.dds.core.Bootstrap;
 import org.omg.dds.sub.DataReader;
+import org.omg.dds.topic.Topic;
 
 
+/**
+ * A sample has been lost (never received).
+ *
+ * @param <TYPE>    The data type of the source {@link DataReader}.
+ */
 public abstract class SampleLostStatus<TYPE>
 extends Status<SampleLostStatus<TYPE>, DataReader<TYPE>> {
     // -----------------------------------------------------------------------
@@ -59,12 +65,14 @@
     // -----------------------------------------------------------------------
 
     /**
-     * @return the totalCount
+     * Total cumulative count of all samples lost across all instances of
+     * data published under the {@link Topic}.
      */
     public abstract int getTotalCount();
 
     /**
-     * @return the totalCountChange
+     * The incremental number of samples lost since the last time the
+     * listener was called or the status was read.
      */
     public abstract int getTotalCountChange();
 
Index: ftf_vote_01/srcJava/org/omg/dds/core/status/OfferedIncompatibleQosStatus.java
===================================================================
--- ftf_vote_01/srcJava/org/omg/dds/core/status/OfferedIncompatibleQosStatus.java	(revision 139)
+++ ftf_vote_01/srcJava/org/omg/dds/core/status/OfferedIncompatibleQosStatus.java	(working copy)
@@ -24,8 +24,17 @@
 import org.omg.dds.core.policy.QosPolicy;
 import org.omg.dds.core.policy.QosPolicyCount;
 import org.omg.dds.pub.DataWriter;
+import org.omg.dds.sub.DataReader;
+import org.omg.dds.topic.Topic;
 
 
+/**
+ * A {@link QosPolicy} value was incompatible with what was requested.
+ *
+ * @param <TYPE>    The data type of the source {@link DataWriter}.
+ * 
+ * @see RequestedIncompatibleQosStatus
+ */
 public abstract class OfferedIncompatibleQosStatus<TYPE>
 extends Status<OfferedIncompatibleQosStatus<TYPE>, DataWriter<TYPE>> {
     // -----------------------------------------------------------------------
@@ -63,21 +72,31 @@
     // -----------------------------------------------------------------------
 
     /**
-     * @return the totalCount
+     * Total cumulative number of times the concerned {@link DataWriter}
+     * discovered a {@link DataReader} for the same {@link Topic} with a
+     * requested QoS that is incompatible with that offered by the
+     * DataWriter.
      */
     public abstract int getTotalCount();
 
     /**
-     * @return the totalCountChange
+     * The change in totalCount since the last time the listener was called
+     * or the status was read.
      */
     public abstract int getTotalCountChange();
 
     /**
-     * @return the lastPolicyId
+     * The {@link QosPolicy.Id} of one of the policies that was found to be
+     * incompatible the last time an incompatibility was detected.
      */
     public abstract QosPolicy.Id getLastPolicyId();
 
     /**
+     * A list containing for each policy the total number of times that the
+     * concerned {@link DataWriter} discovered a {@link DataReader} for the
+     * same {@link Topic} with a requested QoS that is incompatible with that
+     * offered by the DataWriter.
+     * 
      * @return  an unmodifiable set of policy counts.
      */
     public abstract Set<QosPolicyCount> getPolicies();
Index: ftf_vote_01/srcJava/org/omg/dds/core/status/LivelinessChangedStatus.java
===================================================================
--- ftf_vote_01/srcJava/org/omg/dds/core/status/LivelinessChangedStatus.java	(revision 139)
+++ ftf_vote_01/srcJava/org/omg/dds/core/status/LivelinessChangedStatus.java	(working copy)
@@ -20,9 +20,20 @@
 
 import org.omg.dds.core.Bootstrap;
 import org.omg.dds.core.modifiable.ModifiableInstanceHandle;
+import org.omg.dds.pub.DataWriter;
 import org.omg.dds.sub.DataReader;
+import org.omg.dds.topic.Topic;
 
 
+/**
+ * The liveliness of one or more {@link DataWriter}s that were writing
+ * instances read through the {@link DataReader} has changed. Some
+ * DataWriter(s) have become "active" or "inactive."
+ *
+ * @param <TYPE>    The data type of the source {@link DataReader}.
+ * 
+ * @see LivelinessLostStatus
+ */
 public abstract class LivelinessChangedStatus<TYPE>
 extends Status<LivelinessChangedStatus<TYPE>, DataReader<TYPE>> {
     // -----------------------------------------------------------------------
@@ -60,25 +71,43 @@
     // -----------------------------------------------------------------------
 
     /**
-     * @return the aliveCount
+     * The total number of currently active {@link DataWriter}s that write
+     * the Topic read by the {@link DataReader}. This count increases when a
+     * newly matched DataWriter asserts its liveliness for the first time or
+     * when a DataWriter previously considered to be not alive reasserts its
+     * liveliness. The count decreases when a DataWriter considered alive
+     * fails to assert its liveliness and becomes not alive, whether because
+     * it was deleted normally or for some other reason.
      */
     public abstract int getAliveCount();
 
     /**
-     * @return the notAliveCount
+     * The total count of currently {@link DataWriter}s that write the
+     * {@link Topic} read by the {@link DataReader} that are no longer
+     * asserting their liveliness. This count increases when a DataWriter
+     * considered alive fails to assert its liveliness and becomes not alive
+     * for some reason other than the normal deletion of that DataWriter.
+     * It decreases when a previously not alive DataWriter either reasserts
+     * its liveliness or is deleted normally.
      */
     public abstract int getNotAliveCount();
 
     /**
-     * @return the aliveCountChange
+     * The change in the aliveCount since the last time the listener was
+     * called or the status was read.
      */
     public abstract int getAliveCountChange();
 
     /**
-     * @return the notAliveCountChange
+     * The change in the notAliveCount since the last time the listener was
+     * called or the status was read.
      */
     public abstract int getNotAliveCountChange();
 
+    /**
+     * Handle to the last {@link DataWriter} whose change in liveliness
+     * caused this status to change.
+     */
     public abstract ModifiableInstanceHandle getLastPublicationHandle();
 
-}
\ No newline at end of file
+}
Index: ftf_vote_01/srcJava/org/omg/dds/core/status/SampleRejectedStatus.java
===================================================================
--- ftf_vote_01/srcJava/org/omg/dds/core/status/SampleRejectedStatus.java	(revision 139)
+++ ftf_vote_01/srcJava/org/omg/dds/core/status/SampleRejectedStatus.java	(working copy)
@@ -23,6 +23,11 @@
 import org.omg.dds.sub.DataReader;
 
 
+/**
+ * A (received) sample has been rejected.
+ * 
+ * @param <TYPE>    The data type of the source {@link DataReader}.
+ */
 public abstract class SampleRejectedStatus<TYPE>
 extends Status<SampleRejectedStatus<TYPE>, DataReader<TYPE>> {
     // -----------------------------------------------------------------------
@@ -60,20 +65,26 @@
     // -----------------------------------------------------------------------
 
     /**
-     * @return the totalCount
+     * Total cumulative count of samples rejected by the {@link DataReader}.
      */
     public abstract int getTotalCount();
 
     /**
-     * @return the totalCountChange
+     * The incremental number of samples rejected since the last time the
+     * listener was called or the status was read.
      */
     public abstract int getTotalCountChange();
 
     /**
-     * @return the lastReason
+     * Reason for rejecting the last sample rejected. If no samples have been
+     * rejected, the reason is the special value {@link Kind#NOT_REJECTED}.
      */
     public abstract Kind getLastReason();
 
+    /**
+     * Handle to the instance being updated by the last sample that was
+     * rejected.
+     */
     public abstract ModifiableInstanceHandle getLastInstanceHandle();
 
 
Index: ftf_vote_01/srcJava/org/omg/dds/core/GuardCondition.java
===================================================================
--- ftf_vote_01/srcJava/org/omg/dds/core/GuardCondition.java	(revision 139)
+++ ftf_vote_01/srcJava/org/omg/dds/core/GuardCondition.java	(working copy)
@@ -49,5 +49,15 @@
     // Instance Methods
     // -----------------------------------------------------------------------
 
+    /**
+     * This operation sets the triggerValue of the GuardCondition.
+     * 
+     * {@link WaitSet} objects' behavior depends on the changes of the
+     * triggerValue of their attached conditions. Therefore, any WaitSet
+     * to which the GuardCondition is attached is potentially affected by
+     * this operation.
+     * 
+     * @see     Condition#getTriggerValue()
+     */
     public abstract void setTriggerValue(boolean value);
 }
Index: ftf_vote_01/srcJava/org/omg/dds/core/Entity.java
===================================================================
--- ftf_vote_01/srcJava/org/omg/dds/core/Entity.java	(revision 139)
+++ ftf_vote_01/srcJava/org/omg/dds/core/Entity.java	(working copy)
@@ -21,7 +21,18 @@
 import java.util.Collection;
 import java.util.EventListener;
 
+import org.omg.dds.core.policy.EntityFactoryQosPolicy;
+import org.omg.dds.core.policy.WriterDataLifecycleQosPolicy;
 import org.omg.dds.core.status.Status;
+import org.omg.dds.domain.DomainParticipant;
+import org.omg.dds.pub.DataWriter;
+import org.omg.dds.pub.Publisher;
+import org.omg.dds.sub.DataReader;
+import org.omg.dds.sub.Subscriber;
+import org.omg.dds.topic.ContentFilteredTopic;
+import org.omg.dds.topic.MultiTopic;
+import org.omg.dds.topic.Topic;
+import org.omg.dds.topic.TopicDescription;
 
 
 /**
@@ -38,12 +49,82 @@
                         QOS extends EntityQos<?, ?>>
 extends DDSObject
 {
+    /**
+     * This operation allows access to the existing Listener attached to the
+     * Entity.
+     * 
+     * @see     #setListener(EventListener)
+     * @see     #setListener(EventListener, Collection)
+     */
     public LISTENER getListener();
+
+    /**
+     * This operation installs a Listener on the Entity. The listener will
+     * only be invoked on all communication statuses pertaining to the
+     * concrete type of this entity.
+     * 
+     * It is permitted to use null as the value of the listener. The null
+     * listener behaves as a Listener whose operations perform no action.
+     * 
+     * Only one listener can be attached to each Entity. If a listener was
+     * already set, the operation will replace it with the new one.
+     * Consequently if the value null is passed for the listener parameter,
+     * any existing listener will be removed.
+     * 
+     * @see     #getListener()
+     * @see     #setListener(EventListener, Collection)
+     */
     public void setListener(LISTENER listener);
 
+    /**
+     * This operation allows access to the existing set of QoS policies for
+     * the Entity. This operation must be provided by each of the derived
+     * Entity classes ({@link DomainParticipant}, {@link Topic},
+     * {@link Publisher}, {@link DataWriter}, {@link Subscriber},
+     * {@link DataReader}) so that the policies meaningful to the particular
+     * Entity are retrieved.
+     * 
+     * @see     #setQos(EntityQos)
+     */
     public QOS getQos();
 
     /**
+     * This operation is used to set the QoS policies of the Entity. This
+     * operation must be provided by each of the derived Entity classes
+     * ({@link DomainParticipant}, {@link Topic}, {@link Publisher},
+     * {@link DataWriter}, {@link Subscriber}, {@link DataReader}) so that
+     * the policies that are meaningful to each Entity can be set.
+     * 
+     * The set of policies specified as the parameter are applied on top of
+     * the existing QoS, replacing the values of any policies previously set.
+     * 
+     * Certain policies are "immutable"; they can only be set at Entity
+     * creation time, or before the entity is made enabled. If setQos is
+     * invoked after the Entity is enabled and it attempts to change the
+     * value of an "immutable" policy, the operation will fail with
+     * {@link ImmutablePolicyException}.
+     * 
+     * Certain values of QoS policies can be incompatible with the settings
+     * of the other policies. The setQos operation will also fail if it
+     * specifies a set of values that once combined with the existing values
+     * would result in an inconsistent set of policies. In this case, it
+     * shall fail with {@link InconsistentPolicyException}.
+     * 
+     * If the application supplies a non-default value for a QoS policy that
+     * is not supported by the implementation of the service, the setQos
+     * operation will fail with {@link UnsupportedOperationException}.
+     * 
+     * The existing set of policies are only changed if the setQos operation
+     * succeeds. In all other cases, none of the policies is modified.
+     * 
+     * @throws  ImmutablePolicyException    if an immutable policy changes
+     *                                      its value.
+     * @throws  InconsistentPolicyException if a combination of policies is
+     *                                      inconsistent with one another.
+     * @throws  UnsupportedOperationException   if an unsupported policy
+     *                                          has a non-default value.
+     * 
+     * @see     #getQos()
      * @see     #setQos(String, String)
      */
     public void setQos(QOS qos);
@@ -55,21 +136,126 @@
      * @param qosLibraryName
      * @param qosProfileName
      * 
+     * @see     #getQos()
      * @see     #setQos(EntityQos)
      */
     public void setQos(String qosLibraryName, String qosProfileName);
 
+    /**
+     * This operation enables the Entity. Entity objects can be created
+     * either enabled or disabled. This is controlled by the value of the
+     * {@link EntityFactoryQosPolicy} on the corresponding factory for the
+     * Entity.
+     * 
+     * The default setting of {@link EntityFactoryQosPolicy} is such that, by
+     * default, it is not necessary to explicitly call enable on newly
+     * created entities.
+     * 
+     * The enable operation is idempotent. Calling enable on an already
+     * enabled Entity has no effect.
+     * 
+     * If an Entity has not yet been enabled, the following kinds of
+     * operations may be invoked on it:
+     * 
+     * <ul>
+     *     <li>Operations to set or get an Entity's QoS policies (including
+     *         default QoS policies) and listener</li>
+     *     <li>{@link #getStatusCondition()}</li>
+     *     <li>'factory' operations and {@link #close()}</li>
+     *     <li>{@link #getStatusChanges(Collection)} and other get status
+     *         operations (although the status of a disabled entity never
+     *         changes)</li>
+     *     <li>'lookup' operations</li>
+     * </ul>
+     * 
+     * Other operations may explicitly state that they may be called on
+     * disabled entities; those that do not will fail with
+     *  {@link NotEnabledException}.
+     *  
+     *  It is legal to delete an Entity that has not been enabled by calling
+     *  {@link #close()}. Entities created from a factory that is disabled
+     *  are created disabled regardless of the setting of
+     *  {@link EntityFactoryQosPolicy}.
+     *  
+     *  Calling enable on an Entity whose factory is not enabled will fail
+     *  with {@link PreconditionNotMetException}.
+     *  
+     *  If {@link EntityFactoryQosPolicy#isAutoEnableCreatedEntities()} is
+     *  true, the enable operation on the factory will automatically enable
+     *  all entities created from the factory.
+     *  
+     *  The Listeners associated with an entity are not called until the
+     *  entity is enabled. {@link Condition}s associated with an entity that
+     *  is not enabled are "inactive," that is, have a triggerValue == false.
+     */
     public void enable();
 
+    /**
+     * This operation allows access to the {@link StatusCondition} associated
+     * with the Entity. The returned condition can then be added to a
+     * {@link WaitSet} so that the application can wait for specific status
+     * changes that affect the Entity.
+     */
     public StatusCondition<SELF> getStatusCondition();
 
+    /**
+     * This operation retrieves the list of communication statuses in the
+     * Entity that are 'triggered.' That is, the list of statuses whose value
+     * has changed since the last time the application read the status.
+     * 
+     * When the entity is first created or if the entity is not enabled, all
+     * communication statuses are in the "untriggered" state so the list
+     * returned will be empty.
+     * 
+     * The list of statuses returned refers to the statuses that are
+     * triggered on the Entity itself and does not include statuses that
+     * apply to contained entities.
+     * 
+     * @param   statuses    a container for the resulting statuses; its
+     *                      contents will be overwritten by the result of
+     *                      this operation.
+     * @return  the argument as a convenience in order to facilitate call
+     *          chaining. 
+     */
     public Collection<Class<? extends Status<?, ?>>> getStatusChanges(
             Collection<Class<? extends Status<?, ?>>> statuses);
 
+    /**
+     * @return  the {@link InstanceHandle} that represents the Entity.
+     */
     public InstanceHandle getInstanceHandle();
 
     /**
-     * Halt communication and dispose the resources held by this entity.
+     * Halt communication and dispose the resources held by this Entity.
+     * 
+     * Closing an Entity implicitly closes all of its contained objects, if
+     * any. For example, closing a Publisher also closes all of its contained
+     * DataWriters.
+     * 
+     * An Entity cannot be closed if it has any unclosed dependent objects,
+     * not including contained objects. These include the following:
+     * 
+     * <ul>
+     *     <li>A {@link Topic} cannot be closed if it is still in use by any
+     *         {@link ContentFilteredTopic}s or {@link MultiTopic}s.</li>
+     *     <li>A Topic cannot be closed if any {@link DataWriter}s or
+     *         {@link DataReader} is still using it.</li>
+     *     <li>A DataReader cannot be closed if it has any outstanding loans
+     *         as a result of a call to {@link DataReader#read()},
+     *         {@link DataReader#take()}, or one of the variants thereof.
+     *         </li>
+     * </ul>
+     * 
+     * The deletion of a {@link DataWriter} will automatically unregister all
+     * instances. Depending on the settings of the
+     * {@link WriterDataLifecycleQosPolicy}, the deletion of the DataWriter
+     * may also dispose all instances.
+     * 
+     * @throws  PreconditionNotMetException     if close is called on an
+     *          Entity with unclosed dependent object(s), not including
+     *          contained objects.
+     * 
+     * @see     TopicDescription#close()
      */
     public void close();
 
Index: ftf_vote_01/srcJava/org/omg/dds/core/policy/OwnershipStrengthQosPolicy.java
===================================================================
--- ftf_vote_01/srcJava/org/omg/dds/core/policy/OwnershipStrengthQosPolicy.java	(revision 139)
+++ ftf_vote_01/srcJava/org/omg/dds/core/policy/OwnershipStrengthQosPolicy.java	(working copy)
@@ -19,8 +19,26 @@
 package org.omg.dds.core.policy;
 
 import org.omg.dds.core.policy.modifiable.ModifiableOwnershipStrengthQosPolicy;
+import org.omg.dds.pub.DataWriter;
+import org.omg.dds.topic.Topic;
 
 
+/**
+ * [optional] Specifies the value of the "strength" used to arbitrate among
+ * multiple {@link DataWriter} objects that attempt to modify the same
+ * instance of a data object (identified by {@link Topic} + key). This policy
+ * only applies if the {@link OwnershipQosPolicy#getKind()} is
+ * {@link OwnershipQosPolicy.Kind#EXCLUSIVE}. The default value of the
+ * ownership strength is zero.
+ * 
+ * <b>Concerns:</b> {@link DataWriter}
+ * 
+ * <b>RxO:</b> N/A
+ * 
+ * <b>Changeable:</b> Yes
+ * 
+ * @see OwnershipQosPolicy
+ */
 public interface OwnershipStrengthQosPolicy
 extends QosPolicy<OwnershipStrengthQosPolicy,
                   ModifiableOwnershipStrengthQosPolicy> {
Index: ftf_vote_01/srcJava/org/omg/dds/core/policy/TransportPriorityQosPolicy.java
===================================================================
--- ftf_vote_01/srcJava/org/omg/dds/core/policy/TransportPriorityQosPolicy.java	(revision 139)
+++ ftf_vote_01/srcJava/org/omg/dds/core/policy/TransportPriorityQosPolicy.java	(working copy)
@@ -19,8 +19,37 @@
 package org.omg.dds.core.policy;
 
 import org.omg.dds.core.policy.modifiable.ModifiableTransportPriorityQosPolicy;
+import org.omg.dds.pub.DataWriter;
+import org.omg.dds.topic.Topic;
 
 
+/**
+ * This policy is a hint to the infrastructure as to how to set the priority
+ * of the underlying transport used to send the data. The default value is
+ * zero.
+ * 
+ * <b>Concerns:</b> {@link Topic}, {@link DataWriter}
+ * 
+ * <b>RxO:</b> N/A
+ * 
+ * <b>Changeable:</b> Yes
+ * 
+ * The purpose of this QoS is to allow the application to take advantage of
+ * transports capable of sending messages with different priorities.
+ * 
+ * This policy is considered a hint. The policy depends on the ability of the
+ * underlying transports to set a priority on the messages they send. Any
+ * value within the range of a 32-bit signed integer may be chosen; higher
+ * values indicate higher priority. However, any further interpretation of
+ * this policy is specific to a particular transport and a particular
+ * implementation of the Service. For example, a particular transport is
+ * permitted to treat a range of priority values as equivalent to one
+ * another. It is expected that during transport configuration the
+ * application would provide a mapping between the values of the
+ * TRANSPORT_PRIORITY set on DataWriter and the values meaningful to each
+ * transport. This mapping would then be used by the infrastructure when
+ * propagating the data written by the DataWriter.
+ */
 public interface TransportPriorityQosPolicy
 extends QosPolicy<TransportPriorityQosPolicy,
                   ModifiableTransportPriorityQosPolicy> {
Index: ftf_vote_01/srcJava/org/omg/dds/core/policy/LifespanQosPolicy.java
===================================================================
--- ftf_vote_01/srcJava/org/omg/dds/core/policy/LifespanQosPolicy.java	(revision 139)
+++ ftf_vote_01/srcJava/org/omg/dds/core/policy/LifespanQosPolicy.java	(working copy)
@@ -20,8 +20,41 @@
 
 import org.omg.dds.core.Duration;
 import org.omg.dds.core.policy.modifiable.ModifiableLifespanQosPolicy;
+import org.omg.dds.pub.DataWriter;
+import org.omg.dds.topic.Topic;
 
 
+/**
+ * Specifies the maximum duration of validity of the data written by the
+ * {@link DataWriter}. The default value of the lifespan duration is infinite.
+ * 
+ * <b>Concerns:</b> {@link Topic}, {@link DataWriter}
+ * 
+ * <b>RxO:</b> N/A
+ * 
+ * <b>Changeable:</b> Yes
+ * 
+ * The purpose of this QoS is to avoid delivering "stale" data to the
+ * application.
+ * 
+ * Each data sample written by the DataWriter has an associated "expiration
+ * time" beyond which the data should not be delivered to any application.
+ * Once the sample expires, the data will be removed from the DataReader
+ * caches as well as from the transient and persistent information caches.
+ * 
+ * The "expiration time" of each sample is computed by adding the duration
+ * specified by the LIFESPAN QoS to the source time stamp. As described in
+ * {@link DataWriter#write(Object)} and
+ * {@link DataWriter#write(Object, org.omg.dds.core.Time)}, the source time
+ * stamp is either automatically computed by the Service each time the
+ * write operation is called, or else supplied by the application.
+ * 
+ * This QoS relies on the sender and receiving applications having their
+ * clocks sufficiently synchronized. If this is not the case and the Service
+ * can detect it, the DataReader is allowed to use the reception time stamp
+ * instead of the source time stamp in its computation of the "expiration
+ * time."
+ */
 public interface LifespanQosPolicy
 extends QosPolicy<LifespanQosPolicy, ModifiableLifespanQosPolicy> {
     public Duration getDuration();
Index: ftf_vote_01/srcJava/org/omg/dds/core/policy/HistoryQosPolicy.java
===================================================================
--- ftf_vote_01/srcJava/org/omg/dds/core/policy/HistoryQosPolicy.java	(revision 139)
+++ ftf_vote_01/srcJava/org/omg/dds/core/policy/HistoryQosPolicy.java	(working copy)
@@ -19,8 +19,64 @@
 package org.omg.dds.core.policy;
 
 import org.omg.dds.core.policy.modifiable.ModifiableHistoryQosPolicy;
+import org.omg.dds.pub.DataWriter;
+import org.omg.dds.sub.DataReader;
+import org.omg.dds.topic.Topic;
 
 
+/**
+ * Specifies the behavior of the Service in the case where the value of a
+ * sample changes (one or more times) before it can be successfully
+ * communicated to one or more existing subscribers. This QoS policy controls
+ * whether the Service should deliver only the most recent value, attempt to
+ * deliver all intermediate values, or do something in between. On the
+ * publishing side this policy controls the samples that should be maintained
+ * by the DataWriter on behalf of existing DataReader entities. The behavior
+ * with regards to a DataReader entities discovered after a sample is written
+ * is controlled by the {@link DurabilityQosPolicy}. On the subscribing side
+ * it controls the samples that should be maintained until the application
+ * "takes" them from the Service via {@link DataReader#take()}.
+ * 
+ * <b>Concerns:</b> {@link Topic}, {@link DataReader}, {@link DataWriter}
+ * 
+ * <b>RxO:</b> No
+ * 
+ * <b>Changeable:</b> No
+ * 
+ * <ol>
+ *     <li>This policy controls the behavior of the Service when the value of
+ *         an instance changes before it is finally communicated to some of
+ *         its existing DataReader entities.</li>
+ * 
+ *     <li>If the kind is set to {@link Kind#KEEP_LAST}, then the Service
+ *         will only attempt to keep the latest values of the instance and
+ *         discard the older ones. In this case, the value of depth regulates
+ *         the maximum number of values (up to and including the most current
+ *         one) the Service will maintain and deliver. The default (and most
+ *         common setting) for depth is one, indicating that only the most
+ *         recent value should be delivered.</li>
+ * 
+ *     <li>If the kind is set to {@link Kind#KEEP_ALL}, then the Service will
+ *         attempt to maintain and deliver all the values of the instance to
+ *         existing subscribers. The resources that the Service can use to
+ *         keep this history are limited by the settings of the
+ *         {@link ResourceLimitsQosPolicy}. If the limit is reached, then the
+ *         behavior of the Service will depend on the
+ *         {@link ReliabilityQosPolicy}. If the reliability kind is
+ *         {@link ReliabilityQosPolicy.Kind#BEST_EFFORT}, then the old values
+ *         will be discarded. If reliability is
+ *         {@link ReliabilityQosPolicy.Kind#RELIABLE}, then the Service will
+ *         block the DataWriter until it can deliver the necessary old values
+ *         to all subscribers.</li>
+ * </ol>
+ * 
+ * The setting of HISTORY depth must be consistent with the RESOURCE_LIMITS
+ * maxSamplesPerInstance. For these two QoS to be consistent, they must
+ * verify that depth &lt;= maxSamplesPerInstance.
+ * 
+ * @see ReliabilityQosPolicy
+ * @see ResourceLimitsQosPolicy
+ */
 public interface HistoryQosPolicy
 extends QosPolicy<HistoryQosPolicy, ModifiableHistoryQosPolicy> {
     // -----------------------------------------------------------------------
@@ -44,7 +100,32 @@
     // -----------------------------------------------------------------------
 
     public enum Kind {
+        /**
+         * On the publishing side, the Service will only attempt to keep the
+         * most recent "depth" samples ({@link HistoryQosPolicy#getDepth()})
+         * of each instance of data (identified by its key) managed by the
+         * {@link DataWriter}. On the subscribing side, the DataReader will
+         * only attempt to keep the most recent "depth" samples received for
+         * each instance (identified by its key) until the application
+         * "takes" them via {@link DataReader#take()}. KEEP_LAST is the
+         * default kind. The default value of depth is 1. If a value other
+         * than 1 is specified, it must be consistent with the settings of
+         * the {@link ResourceLimitsQosPolicy}.
+         */
         KEEP_LAST,
+
+        /**
+         * On the publishing side, the Service will attempt to keep all
+         * samples (representing each value written) of each instance of data
+         * (identified by its key) managed by the {@link DataWriter} until
+         * they can be delivered to all subscribers. On the subscribing side,
+         * the Service will attempt to keep all samples of each instance of
+         * data (identified by its key) managed by the {@link DataReader}.
+         * These samples are kept until the application "takes" them from the
+         * Service via {@link DataReader#take()}. The setting of depth has no
+         * effect. Its implied value is
+         * {@link ResourceLimitsQosPolicy#LENGTH_UNLIMITED}.
+         */
         KEEP_ALL
     }
 
Index: ftf_vote_01/srcJava/org/omg/dds/core/policy/TimeBasedFilterQosPolicy.java
===================================================================
--- ftf_vote_01/srcJava/org/omg/dds/core/policy/TimeBasedFilterQosPolicy.java	(revision 139)
+++ ftf_vote_01/srcJava/org/omg/dds/core/policy/TimeBasedFilterQosPolicy.java	(working copy)
@@ -19,9 +19,64 @@
 package org.omg.dds.core.policy;
 
 import org.omg.dds.core.Duration;
+import org.omg.dds.core.Entity;
 import org.omg.dds.core.policy.modifiable.ModifiableTimeBasedFilterQosPolicy;
+import org.omg.dds.pub.DataWriter;
+import org.omg.dds.sub.DataReader;
 
 
+/**
+ * Filter that allows a {@link DataReader} to specify that it is interested
+ * only in (potentially) a subset of the values of the data. The filter
+ * states that the DataReader does not want to receive more than one value
+ * each minimumSeparation, regardless of how fast the changes occur. It is
+ * inconsistent for a DataReader to have a minimumSeparation longer than the
+ * result of its {@link DeadlineQosPolicy#getPeriod()}. By default,
+ * minimumSeparation = 0, indicating that the DataReader is potentially
+ * interested in all values.
+ * 
+ * <b>Concerns:</b> {@link DataReader}
+ * 
+ * <b>RxO:</b> N/A
+ * 
+ * <b>Changeable:</b> Yes
+ * 
+ * The TIME_BASED_FILTER applies to each instance separately, that is, the
+ * constraint is that the DataReader does not want to see more than one
+ * sample of each instance per minumumSeparation period.
+ * 
+ * This setting allows a DataReader to further decouple itself from the
+ * {@link DataWriter} objects. It can be used to protect applications that
+ * are running on a heterogeneous network where some nodes are capable of
+ * generating data much faster than others can consume it. It also
+ * accommodates the fact that for fast-changing data different subscribers
+ * may have different requirements as to how frequently they need to be
+ * notified of the most current values.
+ * 
+ * The setting of a TIME_BASED_FILTER, that is, the selection of a
+ * minimumSeparation with a value greater than zero is compatible with all
+ * settings of the HISTORY and RELIABILITY QoS. The TIME_BASED_FILTER
+ * specifies the samples that are of interest to the DataReader. The HISTORY
+ * and RELIABILITY QoS affect the behavior of the middleware with respect to
+ * the samples that have been determined to be of interest to the DataReader,
+ * that is, they apply after the TIME_BASED_FILTER has been applied.
+ * 
+ * In the case where the reliability QoS kind is RELIABLE then in steady
+ * state, defined as the situation where the DataWriter does not write new
+ * samples for a period "long" compared to the minimumSeparation, the system
+ * should guarantee delivery the last sample to the DataReader.
+ * 
+ * The setting of the TIME_BASED_FILTER minimumSeparation must be consistent
+ * with the DEADLINE period. For these two QoS policies to be consistent they
+ * must verify that "period >= minimumSeparation." An attempt to set these
+ * policies in an inconsistent manner when an entity is created via a
+ * {@link Entity#setQos(org.omg.dds.core.EntityQos)} operation will cause the
+ * operation to fail.
+ * 
+ * @see DeadlineQosPolicy
+ * @see HistoryQosPolicy
+ * @see ReliabilityQosPolicy
+ */
 public interface TimeBasedFilterQosPolicy
 extends QosPolicy<TimeBasedFilterQosPolicy,
                   ModifiableTimeBasedFilterQosPolicy> {
Index: ftf_vote_01/srcJava/org/omg/dds/core/policy/EntityFactoryQosPolicy.java
===================================================================
--- ftf_vote_01/srcJava/org/omg/dds/core/policy/EntityFactoryQosPolicy.java	(revision 139)
+++ ftf_vote_01/srcJava/org/omg/dds/core/policy/EntityFactoryQosPolicy.java	(working copy)
@@ -18,9 +18,52 @@
 
 package org.omg.dds.core.policy;
 
+import org.omg.dds.core.Entity;
 import org.omg.dds.core.policy.modifiable.ModifiableEntityFactoryQosPolicy;
+import org.omg.dds.domain.DomainParticipant;
+import org.omg.dds.domain.DomainParticipantFactory;
+import org.omg.dds.pub.DataWriter;
+import org.omg.dds.pub.Publisher;
+import org.omg.dds.sub.DataReader;
+import org.omg.dds.sub.Subscriber;
+import org.omg.dds.topic.Topic;
 
 
+/**
+ * Controls the behavior of the {@link Entity} when acting as a factory for
+ * other entities. In other words, configures the side-effects of the
+ * <code>create_*</code> operations.
+ * 
+ * <b>Concerns:</b> {@link DomainParticipantFactory},
+ *                  {@link DomainParticipant}, {@link Publisher},
+ *                  {@link Subscriber}
+ * 
+ * <b>RxO:</b> No
+ * 
+ * <b>Changeable:</b> Yes
+ * 
+ * This policy controls the behavior of the Entity as a factory for other entities.
+ * 
+ * This policy concerns only DomainParticipant (as factory for Publisher,
+ * Subscriber, and {@link Topic}), Publisher (as factory for
+ * {@link DataWriter}), and Subscriber (as factory for {@link DataReader}).
+ * 
+ * This policy is mutable. A change in the policy affects only the entities
+ * created after the change; not the previously created entities.
+ *  
+ * The setting of autoenableCreatedEntities to true indicates that the
+ * factory <code>create&lt;<i>entity</i>&gt;</code> operation will
+ * automatically invoke the {@link Entity#enable()} operation each time a new
+ * Entity is created. Therefore, the Entity returned by
+ * <code>create&lt;<i>entity</i>&gt;</code> will already be enabled. A
+ * setting of false indicates that the Entity will not be automatically
+ * enabled. The application will need to enable it explicitly by means of the
+ * enable operation.
+ * 
+ * The default setting of autoenableCreatedEntities = true means that, by
+ * default, it is not necessary to explicitly call enable on newly created
+ * entities.
+ */
 public interface EntityFactoryQosPolicy
 extends QosPolicy<EntityFactoryQosPolicy, ModifiableEntityFactoryQosPolicy> {
     /**
Index: ftf_vote_01/srcJava/org/omg/dds/core/policy/DeadlineQosPolicy.java
===================================================================
--- ftf_vote_01/srcJava/org/omg/dds/core/policy/DeadlineQosPolicy.java	(revision 139)
+++ ftf_vote_01/srcJava/org/omg/dds/core/policy/DeadlineQosPolicy.java	(working copy)
@@ -18,10 +18,56 @@
 
 package org.omg.dds.core.policy;
 
+import org.omg.dds.core.Condition;
 import org.omg.dds.core.Duration;
 import org.omg.dds.core.policy.modifiable.ModifiableDeadlineQosPolicy;
+import org.omg.dds.pub.DataWriter;
+import org.omg.dds.sub.DataReader;
+import org.omg.dds.topic.Topic;
 
 
+/**
+ * {@link DataReader} expects a new sample updating the value of each
+ * instance at least once every deadline period. The {@link DataWriter}
+ * indicates that the application commits to write a new value (using the
+ * DataWriter) for each instance managed by the DataWriter at least once
+ * every deadline period. It is inconsistent for a DataReader to have a
+ * deadline period less than the result of its
+ * {@link TimeBasedFilterQosPolicy#getMinimumSeparation()}. The default value
+ * of the deadline period is infinite.
+ * 
+ * <b>Concerns:</b> {@link Topic}, {@link DataReader}, {@link DataWriter}
+ * 
+ * <b>RxO:</b> Yes
+ * 
+ * <b>Changeable:</b> Yes
+ * 
+ * This policy is useful for cases where a {@link Topic} is expected to have
+ * each instance updated periodically. On the publishing side this setting
+ * establishes a contract that the application must meet. On the subscribing
+ * side the setting establishes a minimum requirement for the remote
+ * publishers that are expected to supply the data values.
+ * 
+ * When the Service "matches" a DataWriter and a DataReader it checks whether
+ * the settings are compatible (i.e., offered deadline period<= requested
+ * deadline period). If they are not, the two entities are informed (via the
+ * listener or {@link Condition} mechanism) of the incompatibility of the QoS
+ * settings and communication will not occur.
+ * 
+ * Assuming that the reader and writer ends have compatible settings, the
+ * fulfillment of this contract is monitored by the Service and the
+ * application is informed of any violations by means of the proper listener
+ * or condition.
+ * 
+ * The value offered is considered compatible with the value requested if and
+ * only if the inequality "offered deadline period <= requested deadline
+ * period" evaluates to true.
+ * 
+ * The setting of the DEADLINE policy must be set consistently with that of
+ * the {@link TimeBasedFilterQosPolicy}. For these two policies to be
+ * consistent the settings must be such that "deadline period >=
+ * minimum_separation."
+ */
 public interface DeadlineQosPolicy
 extends QosPolicy<DeadlineQosPolicy, ModifiableDeadlineQosPolicy> {
     public Duration getPeriod();
Index: ftf_vote_01/srcJava/org/omg/dds/core/policy/UserDataQosPolicy.java
===================================================================
--- ftf_vote_01/srcJava/org/omg/dds/core/policy/UserDataQosPolicy.java	(revision 139)
+++ ftf_vote_01/srcJava/org/omg/dds/core/policy/UserDataQosPolicy.java	(working copy)
@@ -18,9 +18,40 @@
 
 package org.omg.dds.core.policy;
 
+import org.omg.dds.core.Entity;
 import org.omg.dds.core.policy.modifiable.ModifiableUserDataQosPolicy;
+import org.omg.dds.domain.DomainParticipant;
+import org.omg.dds.pub.DataWriter;
+import org.omg.dds.sub.DataReader;
 
 
+/**
+ * User data not known by the middleware, but distributed by means of
+ * built-in topics. The default value is an empty (zero-sized) sequence.
+ * 
+ * <b>Concerns:</b> {@link DomainParticipant}, {@link DataReader},
+ *                 {@link DataWriter}
+ * 
+ * <b>RxO:</b> No
+ * 
+ * <b>Changeable:</b> Yes
+ * 
+ * The purpose of this QoS is to allow the application to attach additional
+ * information to the created {@link Entity} objects such that when a remote
+ * application discovers their existence it can access that information and
+ * use it for its own purposes. One possible use of this QoS is to attach
+ * security credentials or some other information that can be used by the
+ * remote application to authenticate the source. In combination with
+ * operations such as
+ * {@link DomainParticipant#ignoreParticipant(org.omg.dds.core.InstanceHandle)},
+ * {@link DomainParticipant#ignorePublication(org.omg.dds.core.InstanceHandle)},
+ * {@link DomainParticipant#ignoreSubscription(org.omg.dds.core.InstanceHandle)},
+ * and
+ * {@link DomainParticipant#ignoreTopic(org.omg.dds.core.InstanceHandle)}
+ * these QoS can assist an application to define and enforce its own security
+ * policies. The use of this QoS is not limited to security, rather it offers
+ * a simple, yet flexible extensibility mechanism.
+ */
 public interface UserDataQosPolicy
 extends QosPolicy<UserDataQosPolicy, ModifiableUserDataQosPolicy> {
     /**
Index: ftf_vote_01/srcJava/org/omg/dds/core/policy/TopicDataQosPolicy.java
===================================================================
--- ftf_vote_01/srcJava/org/omg/dds/core/policy/TopicDataQosPolicy.java	(revision 139)
+++ ftf_vote_01/srcJava/org/omg/dds/core/policy/TopicDataQosPolicy.java	(working copy)
@@ -19,8 +19,31 @@
 package org.omg.dds.core.policy;
 
 import org.omg.dds.core.policy.modifiable.ModifiableTopicDataQosPolicy;
+import org.omg.dds.domain.DomainParticipant;
+import org.omg.dds.pub.DataWriter;
+import org.omg.dds.sub.DataReader;
+import org.omg.dds.topic.Topic;
 
 
+/**
+ * User data not known by the middleware, but distributed by means of
+ * built-in topics. The default value is an empty (zero-sized) sequence.
+ * 
+ * <b>Concerns:</b> {@link Topic}
+ * 
+ * <b>RxO:</b> No
+ * 
+ * <b>Changeable:</b> Yes
+ * 
+ * The purpose of this QoS is to allow the application to attach additional
+ * information to the created {@link Topic}s such that when a remote
+ * application discovers their existence it can examine the information and
+ * use it in an application-defined way. In combination with the listeners on
+ * the {@link DataReader} and {@link DataWriter} as well as by means of
+ * operations such as
+ * {@link DomainParticipant#ignoreTopic(org.omg.dds.core.InstanceHandle)},
+ * these QoS can assist an application to extend the provided QoS.
+ */
 public interface TopicDataQosPolicy
 extends QosPolicy<TopicDataQosPolicy, ModifiableTopicDataQosPolicy> {
     /**
Index: ftf_vote_01/srcJava/org/omg/dds/core/policy/DurabilityQosPolicy.java
===================================================================
--- ftf_vote_01/srcJava/org/omg/dds/core/policy/DurabilityQosPolicy.java	(revision 139)
+++ ftf_vote_01/srcJava/org/omg/dds/core/policy/DurabilityQosPolicy.java	(working copy)
@@ -18,9 +18,113 @@
 
 package org.omg.dds.core.policy;
 
+import org.omg.dds.core.Condition;
+import org.omg.dds.core.WaitSet;
 import org.omg.dds.core.policy.modifiable.ModifiableDurabilityQosPolicy;
+import org.omg.dds.core.status.OfferedIncompatibleQosStatus;
+import org.omg.dds.core.status.RequestedIncompatibleQosStatus;
+import org.omg.dds.domain.DomainParticipant;
+import org.omg.dds.pub.DataWriter;
+import org.omg.dds.sub.DataReader;
+import org.omg.dds.sub.InstanceState;
+import org.omg.dds.topic.Topic;
 
 
+/**
+ * This policy expresses if the data should "outlive" their writing time.
+ * 
+ * <b>Concerns:</b> {@link Topic}, {@link DataReader}, {@link DataWriter}
+ * 
+ * <b>RxO:</b> Yes
+ * 
+ * <b>Changeable:</b> No
+ * 
+ * The decoupling between {@link DataReader} and {@link DataWriter} offered
+ * by the Publish/Subscribe paradigm allows an application to write data even
+ * if there are no current readers on the network. Moreover, a DataReader
+ * that joins the network after some data has been written could potentially
+ * be interested in accessing the most current values of the data as well as
+ * potentially some history. This QoS policy controls whether the Service
+ * will actually make data available to late-joining readers. Note that
+ * although related, this does not strictly control what data the Service
+ * will maintain internally. That is, the Service may choose to maintain some
+ * data for its own purposes (e.g., flow control) and yet not make it
+ * available to late-joining readers if the {@link DurabilityQosPolicy} is
+ * set to {@link DurabilityQosPolicy.Kind#VOLATILE}.
+ * 
+ * The value offered is considered compatible with the value requested if and
+ * only if the inequality offered kind >= requested kind evaluates to true.
+ * For the purposes of this inequality, the values of
+ * {@link DurabilityQosPolicy.Kind} are considered ordered such that
+ * VOLATILE < TRANSIENT_LOCAL < TRANSIENT < PERSISTENT.
+ * 
+ * For the purpose of implementing the {@link DurabilityQosPolicy.Kind}
+ * TRANSIENT or PERSISTENT, the service behaves "as if" for each {@link Topic}
+ * that has TRANSIENT or PERSISTENT DURABILITY kind there was a corresponding
+ * "built-in" {@link DataReader} and {@link DataWriter} configured to have
+ * the same DURABILITY kind. In other words, it is "as if" somewhere in the
+ * system (possibly on a remote node) there was a "built-in durability
+ * DataReader" that subscribed to that Topic and a "built-in durability
+ * DataWriter" that published that Topic as needed for the new subscribers
+ * that join the system.
+ * 
+ * For each Topic, the built-in fictitious "persistence service" DataReader
+ * and DataWriter has its QoS configured from the Topic QoS of the
+ * corresponding Topic. In other words, it is "as-if" the service first did
+ * {@link DomainParticipant#findTopic(String, org.omg.dds.core.Duration)} to
+ * access the Topic, and then used the QoS from the Topic to configure the
+ * fictitious built-in entities.
+ * 
+ * A consequence of this model is that the transient or persistence service
+ * can be configured by means of setting the proper QoS on the Topic.
+ * 
+ * For a given Topic, the usual request/offered semantics apply to the
+ * matching between any DataWriter in the system that writes the Topic and
+ * the built-in transient/persistent DataReader for that Topic; similarly for
+ * the built-in transient/persistent DataWriter for a Topic and any
+ * DataReader for the Topic. As a consequence, a DataWriter that has an
+ * incompatible QoS with respect to what the Topic specified will not send
+ * its data to the transient/persistent service, and a DataReader that has an
+ * incompatible QoS with respect to the specified in the Topic will not get
+ * data from it.
+ * 
+ * Incompatibilities between local DataReader/DataWriter entities and the
+ * corresponding fictitious "built-in transient/persistent entities" cause
+ * the {@link RequestedIncompatibleQosStatus}/
+ * {@link OfferedIncompatibleQosStatus} to change and the corresponding
+ * Listener invocations and/or signaling of {@link Condition} and
+ * {@link WaitSet} objects as they would with non-fictitious entities.
+ * 
+ * The setting of the serviceCleanupDelay controls when the TRANSIENT or
+ * PERSISTENT service is able to remove all information regarding a data
+ * instances. Information on a data instances is maintained until the
+ * following conditions are met:
+ * 
+ * <ol>
+ *      <li>the instance has been explicitly disposed (instanceState =
+ *          {@link InstanceState#NOT_ALIVE_DISPOSED}),</li>
+ *      <li>and while in the NOT_ALIVE_DISPOSED state the system detects that
+ *          there are no more "alive" {@link DataWriter} entities writing the
+ *          instance, that is, all existing writers either unregister the
+ *          instance (call
+ *          {@link DataWriter#unregisterInstance(org.omg.dds.core.InstanceHandle)})
+ *          or lose their liveliness,</li>
+ *      <li>and a time interval longer that serviceCleanupDelay has elapsed
+ *          since the moment the service detected that the previous two
+ *          conditions were met.</li>
+ * </ol>
+ * 
+ * The utility of the serviceCleanupDelay is apparent in the situation where
+ * an application disposes an instance and it crashes before it has a chance
+ * to complete additional tasks related to the disposition. Upon restart the
+ * application may ask for initial data to regain its state and the delay
+ * introduced by the serviceCleanupDelay will allow the restarted application
+ * to receive the information on the disposed instance and complete the
+ * interrupted tasks.
+ * 
+ * @see DurabilityServiceQosPolicy
+ * @see DurabilityServiceQosPolicy#getServiceCleanupDelay()
+ */
 public interface DurabilityQosPolicy
 extends QosPolicy<DurabilityQosPolicy, ModifiableDurabilityQosPolicy> {
     // -----------------------------------------------------------------------
@@ -39,9 +143,44 @@
     // -----------------------------------------------------------------------
 
     public enum Kind {
+        /**
+         * The Service does not need to keep any samples of data instances on
+         * behalf of any {@link DataReader} that is not known by the
+         * {@link DataWriter} at the time the instance is written. In other
+         * words the Service will only attempt to provide the data to
+         * existing subscribers. This is the default kind.
+         */
         VOLATILE,
+
+        /**
+         * The Service will attempt to keep some samples so that they can be
+         * delivered to any potential late-joining {@link DataReader}. Which
+         * particular samples are kept depends on other QoS such as
+         * {@link HistoryQosPolicy} and {@link ResourceLimitsQosPolicy}.
+         * 
+         * For TRANSIENT_LOCAL, the service is only required to keep the data
+         * in the memory of the {@link DataWriter} that wrote the data and
+         * the data is not required to survive the DataWriter.
+         */
         TRANSIENT_LOCAL,
+
+        /**
+         * The Service will attempt to keep some samples so that they can be
+         * delivered to any potential late-joining {@link DataReader}. Which
+         * particular samples are kept depends on other QoS such as
+         * {@link HistoryQosPolicy} and {@link ResourceLimitsQosPolicy}.
+         * 
+         * For TRANSIENT, the service is only required to keep the data in
+         * memory and not in permanent storage; but the data is not tied to
+         * the life cycle of the {@link DataWriter} and will, in general,
+         * survive it. Support for TRANSIENT kind is optional.
+         */
         TRANSIENT,
+
+        /**
+         * Data is kept on permanent storage, so that they can outlive a
+         * system session. Support for PERSISTENT kind is optional.
+         */
         PERSISTENT
     }
 
Index: ftf_vote_01/srcJava/org/omg/dds/core/policy/PartitionQosPolicy.java
===================================================================
--- ftf_vote_01/srcJava/org/omg/dds/core/policy/PartitionQosPolicy.java	(revision 139)
+++ ftf_vote_01/srcJava/org/omg/dds/core/policy/PartitionQosPolicy.java	(working copy)
@@ -20,9 +20,74 @@
 
 import java.util.Collection;
 
+import org.omg.dds.core.Entity;
 import org.omg.dds.core.policy.modifiable.ModifiablePartitionQosPolicy;
+import org.omg.dds.pub.DataWriter;
+import org.omg.dds.pub.Publisher;
+import org.omg.dds.sub.DataReader;
+import org.omg.dds.sub.Subscriber;
 
 
+/**
+ * This policy allows the introduction of a logical partition concept inside
+ * the "physical" partition induced by a domain. It consists of a set of
+ * strings that introduces a logical partition among the topics
+ * visible by the {@link Publisher} and {@link Subscriber}.
+ * 
+ * <b>Concerns:</b> {@link Publisher}, {@link Subscriber}
+ * 
+ * <b>RxO:</b> No
+ * 
+ * <b>Changeable:</b> Yes
+ * 
+ * A {@link DataWriter} within a Publisher only communicates with a
+ * {@link DataReader} in a Subscriber if (in addition to matching the Topic
+ * and having compatible QoS) the Publisher and Subscriber have a common
+ * partition name string. Each string in the list that defines this QoS
+ * policy defines a partition name. A partition name may contain wild cards.
+ * Sharing a common partition means that one of the partition names matches.
+ * 
+ * Failure to match partitions is not considered an "incompatible" QoS and
+ * does not trigger any listeners nor conditions.
+ * 
+ * This policy is changeable. A change of this policy can potentially modify
+ * the "match" of existing DataReader and DataWriter entities. It may
+ * establish new "matches" that did not exist before, or break existing
+ * matches.
+ * 
+ * The empty string ("") is considered a valid partition that is matched with
+ * other partition names using the same rules of string matching and
+ * regular expression matching used for any other partition name.
+ * 
+ * The default value for is a zero-length sequence. The
+ * zero-length sequence is treated as a special value equivalent to a
+ * sequence containing a single element consisting of the empty string.
+ * 
+ * This policy is changeable. A change of this policy can potentially modify
+ * the "match" of existing DataReader and DataWriter entities. It may
+ * establish new "matches" that did not exist before, or break existing
+ * matches.
+ * 
+ * PARTITION names can be regular expressions and include wild cards as
+ * defined by the POSIX fnmatch API (1003.2-1992 section B.6). Either
+ * {@link Publisher} or {@link Subscriber} may include regular expressions in
+ * partition names, but no two names that both contain wild cards will ever
+ * be considered to match. This means that although regular expressions may
+ * be used both at publisher as well as subscriber side, the service will not
+ * try to match two regular expressions (between publishers and subscribers).
+ * 
+ * Partitions are different from creating {@link Entity} objects in different
+ * domains in several ways. First, entities belonging to different domains
+ * are completely isolated from each other; there is no traffic, meta-traffic
+ * or any other way for an application or the Service itself to see entities
+ * in a domain it does not belong to. Second, an Entity can only belong to
+ * one domain whereas an Entity can be in multiple partitions. Finally, as
+ * far as the DDS Service is concerned, each unique data instance is
+ * identified by the tuple (domainId, Topic, key). Therefore two Entity
+ * objects in different domains cannot refer to the same data instance. On
+ * the other hand, the same data instance can be made available (published)
+ * or requested (subscribed) on one or more partitions.
+ */
 public interface PartitionQosPolicy
 extends QosPolicy<PartitionQosPolicy, ModifiablePartitionQosPolicy> {
     /**
Index: ftf_vote_01/srcJava/org/omg/dds/core/policy/ResourceLimitsQosPolicy.java
===================================================================
--- ftf_vote_01/srcJava/org/omg/dds/core/policy/ResourceLimitsQosPolicy.java	(revision 139)
+++ ftf_vote_01/srcJava/org/omg/dds/core/policy/ResourceLimitsQosPolicy.java	(working copy)
@@ -19,8 +19,56 @@
 package org.omg.dds.core.policy;
 
 import org.omg.dds.core.policy.modifiable.ModifiableResourceLimitsQosPolicy;
+import org.omg.dds.pub.DataWriter;
+import org.omg.dds.sub.DataReader;
+import org.omg.dds.topic.Topic;
 
 
+/**
+ * Specifies the resources that the Service can consume in order to meet the
+ * requested QoS.
+ * 
+ * <b>Concerns:</b> {@link Topic}, {@link DataReader}, {@link DataWriter}
+ * 
+ * <b>RxO:</b> No
+ * 
+ * <b>Changeable:</b> No
+ * 
+ * This policy controls the resources that the Service can use in order to
+ * meet the requirements imposed by the application and other QoS settings.
+ * 
+ * If the DataWriter objects are communicating samples faster than they are
+ * ultimately taken by the DataReader objects, the middleware will eventually
+ * hit against some of the QoS-imposed resource limits. Note that this may
+ * occur when just a single DataReader cannot keep up with its corresponding
+ * DataWriter. The behavior in this case depends on the setting for the
+ * {@link ReliabilityQosPolicy}. If reliability is
+ * {@link ReliabilityQosPolicy.Kind#BEST_EFFORT}, then the Service is allowed
+ * to drop samples. If the reliability is
+ * {@link ReliabilityQosPolicy.Kind#RELIABLE}, the Service will block the
+ * DataWriter or discard the sample at the DataReader in order not to lose
+ * existing samples (so that the sample can be resent at a later time).
+ * 
+ * The constant {@link #LENGTH_UNLIMITED} may be used to indicate the absence
+ * of a particular limit. For example setting maxSamplesPerInstance to
+ * LENGH_UNLIMITED will cause the middleware to not enforce this particular
+ * limit.
+ * 
+ * The setting of RESOURCE_LIMITS maxSamples must be consistent with the
+ * maxSamplesPerInstance. For these two values to be consistent they must
+ * verify that "max_samples &gt;= max_samples_per_instance."
+ * 
+ * The setting of RESOURCE_LIMITS maxSamplesPerInstance must be consistent
+ * with the HISTORY depth. For these two QoS to be consistent, they must
+ * verify that "depth &lt;= maxSamplesPerInstance."
+ * 
+ * An attempt to set this policy to inconsistent values when an entity is
+ * created or via a <code>setQos</code> operation will cause the operation to
+ * fail.
+ * 
+ * @see HistoryQosPolicy
+ * @see ReliabilityQosPolicy
+ */
 public interface ResourceLimitsQosPolicy
 extends QosPolicy<ResourceLimitsQosPolicy,
                   ModifiableResourceLimitsQosPolicy> {
Index: ftf_vote_01/srcJava/org/omg/dds/core/policy/ReliabilityQosPolicy.java
===================================================================
--- ftf_vote_01/srcJava/org/omg/dds/core/policy/ReliabilityQosPolicy.java	(revision 139)
+++ ftf_vote_01/srcJava/org/omg/dds/core/policy/ReliabilityQosPolicy.java	(working copy)
@@ -20,8 +20,53 @@
 
 import org.omg.dds.core.Duration;
 import org.omg.dds.core.policy.modifiable.ModifiableReliabilityQosPolicy;
+import org.omg.dds.pub.DataWriter;
+import org.omg.dds.sub.DataReader;
+import org.omg.dds.topic.Topic;
 
 
+/**
+ * This policy indicates the level of reliability requested by a
+ * {@link DataReader} or offered by a {@link DataWriter}. These levels are
+ * ordered, {@link Kind#BEST_EFFORT} being lower than {@link Kind#RELIABLE}.
+ * A DataWriter offering a level is implicitly offering all levels below.
+ * 
+ * <b>Concerns:</b> {@link Topic}, {@link DataReader}, {@link DataWriter}
+ * 
+ * <b>RxO:</b> Yes
+ * 
+ * <b>Changeable:</b> No
+ * 
+ * The setting of this policy has a dependency on the setting of the
+ * {@link ResourceLimitsQosPolicy}. In case the RELIABILITY kind is set to
+ * RELIABLE the {@link DataWriter#write(Object)} operation may block if the
+ * modification would cause data to be lost or else cause one of the limits
+ * specified in the RESOURCE_LIMITS to be exceeded. Under these circumstances,
+ * the RELIABILITY maxBlockingTime configures the maximum duration the write
+ * operation may block.
+ * 
+ * If the RELIABILITY kind is set to RELIABLE, data samples originating from
+ * a single DataWriter cannot be made available to the DataReader if there
+ * are previous data samples that have not been received yet due to a
+ * communication error. In other words, the service will repair the error and
+ * retransmit data samples as needed in order to reconstruct a correct
+ * snapshot of the DataWriter history before it is accessible by the
+ * DataReader.
+ * 
+ * If the RELIABILITY kind is set to BEST_EFFORT, the service will not
+ * retransmit missing data samples. However, for data samples originating
+ * from any one DataWriter the service will ensure they are stored in the
+ * DataReader history in the same order they originated in the DataWriter. In
+ * other words, the DataReader may miss some data samples but it will never
+ * see the value of a data object change from a newer value to an older value.
+ * 
+ * The value offered is considered compatible with the value requested if and
+ * only if the inequality "offered kind &gt;= requested kind" evaluates to
+ * true. For the purposes of this inequality, the values of RELIABILITY kind
+ * are considered ordered such that BEST_EFFORT &lt; RELIABLE.
+ * 
+ * @see ResourceLimitsQosPolicy
+ */
 public interface ReliabilityQosPolicy
 extends QosPolicy<ReliabilityQosPolicy, ModifiableReliabilityQosPolicy> {
     // -----------------------------------------------------------------------
@@ -42,7 +87,26 @@
     // -----------------------------------------------------------------------
 
     public enum Kind {
+        /**
+         * Indicates that it is acceptable to not retry propagation of any
+         * samples. Presumably new values for the samples are generated often
+         * enough that it is not necessary to re-send or acknowledge any
+         * samples. This is the default value for {@link DataReader}s and
+         * {@link Topic}s.
+         */
         BEST_EFFORT,
+
+        /**
+         * Specifies the Service will attempt to deliver all samples in its
+         * history. Missed samples may be retried. In steady-state (no
+         * modifications communicated via the {@link DataWriter}) the
+         * middleware guarantees that all samples in the DataWriter history
+         * will eventually be delivered to all the {@link DataReader} objects.
+         * Outside steady state the {@link HistoryQosPolicy} and
+         * {@link ResourceLimitsQosPolicy} will determine how samples become
+         * part of the history and whether samples can be discarded from it.
+         * This is the default value for DataWriters.
+         */
         RELIABLE
     }
 
Index: ftf_vote_01/srcJava/org/omg/dds/core/policy/PresentationQosPolicy.java
===================================================================
--- ftf_vote_01/srcJava/org/omg/dds/core/policy/PresentationQosPolicy.java	(revision 139)
+++ ftf_vote_01/srcJava/org/omg/dds/core/policy/PresentationQosPolicy.java	(working copy)
@@ -19,8 +19,63 @@
 package org.omg.dds.core.policy;
 
 import org.omg.dds.core.policy.modifiable.ModifiablePresentationQosPolicy;
+import org.omg.dds.pub.DataWriter;
+import org.omg.dds.pub.Publisher;
+import org.omg.dds.sub.DataReader;
+import org.omg.dds.sub.Subscriber;
 
 
+/**
+ * Specifies how the samples representing changes to data instances are
+ * presented to the subscribing application. This policy affects the
+ * application's ability to specify and receive coherent changes and to see
+ * the relative order of changes. The accessScope determines the largest
+ * scope spanning the entities for which the order and coherency of changes
+ * can be preserved. The two booleans control whether coherent access and
+ * ordered access are supported within the scope accessScope.
+ * 
+ * <b>Concerns:</b> {@link Publisher}, {@link Subscriber}
+ * 
+ * <b>RxO:</b> Yes
+ * 
+ * <b>Changeable:</b> No
+ * 
+ * This QoS policy controls the extent to which changes to data instances can
+ * be made dependent on each other and also the kind of dependencies that can
+ * be propagated and maintained by the Service.
+ * 
+ * The setting of coherentAccess controls whether the Service will
+ * preserve the groupings of changes made by the publishing application
+ * by means of the operations {@link Publisher#beginCoherentChanges()} and
+ * {@link Publisher#endCoherentChanges()}.
+ * 
+ * The setting of orderedAccess controls whether the Service will preserve
+ * the order of changes.
+ * 
+ * The granularity is controlled by the setting of the accessScope.
+ * 
+ * Note that this QoS policy controls the scope at which related changes are
+ * made available to the subscriber. This means the subscriber <em>can</em>
+ * access the changes in a coherent manner and in the proper order; however,
+ * it does not necessarily imply that the Subscriber <em>will</em> indeed
+ * access the changes in the correct order. For that to occur, the
+ * application at the subscriber end must use the proper logic in reading the
+ * DataReader objects.
+ * 
+ * The value offered is considered compatible with the value requested if and
+ * only if the following conditions are met:
+ * 
+ * <ol>
+ *      <li>The inequality "offered access_scope >= requested access_scope"
+ *          evaluates to true. For the purposes of this inequality, the
+ *          values of {@link PresentationQosPolicy.AccessScopeKind} are
+ *          considered ordered such that INSTANCE < TOPIC < GROUP.</li>
+ *      <li>Requested coherentAccess is false, or else both offered and
+ *          requested coherentAccess are true.</li>
+ *      <li>Requested orderedAccess is false, or else both offered and
+ *          requested orderedAccess are true.</li>
+ * </ol>
+ */
 public interface PresentationQosPolicy
 extends QosPolicy<PresentationQosPolicy, ModifiablePresentationQosPolicy> {
     // -----------------------------------------------------------------------
@@ -33,12 +88,70 @@
     public AccessScopeKind getAccessScope();
 
     /**
-     * @return the coherentAccess
+     * If coherentAccess is set, then the accessScope controls the maximum
+     * extent of coherent changes. The behavior is as follows:
+     * 
+     * <ul>
+     *      <li>If accessAcope is set to
+     *          {@link PresentationQosPolicy.AccessScopeKind#INSTANCE}, the
+     *          use of {@link Publisher#beginCoherentChanges()} and
+     *          {@link Publisher#endCoherentChanges()} has no effect on how
+     *          the subscriber can access the data because with the scope
+     *          limited to each instance, changes to separate instances are
+     *          considered independent and thus cannot be grouped by a
+     *          coherent change.
+     *      <li>If accessScope is set to
+     *          {@link PresentationQosPolicy.AccessScopeKind#TOPIC}, then
+     *          coherent changes (indicated by their enclosure within calls to
+     *          {@link Publisher#beginCoherentChanges()} and
+     *          {@link Publisher#endCoherentChanges()}) will be made available
+     *          as such to each remote {@link DataReader} independently. That
+     *          is, changes made to instances within each individual
+     *          {@link DataWriter} will be available as coherent with respect
+     *          to other changes to instances in that same DataWriter, but
+     *          will not be grouped with changes made to instances belonging
+     *          to a different DataWriter.
+     *      <li>If accessScope is set to
+     *          {@link PresentationQosPolicy.AccessScopeKind#GROUP}, then
+     *          coherent changes made to instances through a DataWriter
+     *          attached to a common {@link Publisher} are made available as
+     *          a unit to remote subscribers.</li>
+     * </ul>
+     * 
+     * @see #getAccessScope()
      */
     public boolean isCoherentAccess();
 
     /**
-     * @return the orderedAccess
+     * If orderedAccess is set, then the accessScope controls the maximum
+     * extent for which order will be preserved by the Service.
+     * 
+     * <ul>
+     *  <li>If accessScope is set to
+     *      {@link PresentationQosPolicy.AccessScopeKind#INSTANCE} (the
+     *      lowest level), then changes to each instance are considered
+     *      unordered relative to changes to any other instance. That means
+     *      that changes (creations, deletions, modifications) made to two
+     *      instances are not necessarily seen in the order they occur. This
+     *      is the case even if it is the same application thread making the
+     *      changes using the same {@link DataWriter}.</li>
+     *  <li>If accessScope is set to
+     *      {@link PresentationQosPolicy.AccessScopeKind#TOPIC}, changes
+     *      (creations, deletions, modifications) made by a single
+     *      {@link DataWriter} are made available to subscribers in the same
+     *      order they occur. Changes made to instances through different
+     *      DataWriter entities are not necessarily seen in the order they
+     *      occur. This is the case, even if the changes are made by a single
+     *      application thread using DataWriter objects attached to the same
+     *      {@link Publisher}.</li>
+     *  <li>Finally, if accessScope is set to
+     *      {@link PresentationQosPolicy.AccessScopeKind#GROUP}, changes made
+     *      to instances via DataWriter entities attached to the same
+     *      Publisher object are made available to subscribers on the same
+     *      order they occur.</li>
+     * </ul>
+     * 
+     * @see #getAccessScope()
      */
     public boolean isOrderedAccess();
 
@@ -49,8 +162,26 @@
     // -----------------------------------------------------------------------
 
     public enum AccessScopeKind {
+        /**
+         * Scope spans only a single instance. Indicates that changes to one
+         * instance need not be coherent nor ordered with respect to changes
+         * to any other instance. In other words, order and coherent changes
+         * apply to each instance separately. This is the default accessScope.
+         */
         INSTANCE,
+
+        /**
+         * Scope spans to all instances within the same {@link DataWriter}
+         * (or {@link DataReader}), but not across instances in different
+         * DataWriter (or DataReader).
+         */
         TOPIC,
+
+        /**
+         * [optional] Scope spans to all instances belonging to
+         * {@link DataWriter} (or {@link DataReader}) entities within the
+         * same {@link Publisher} (or {@link Subscriber}).
+         */
         GROUP
     }
 
Index: ftf_vote_01/srcJava/org/omg/dds/core/policy/ReaderDataLifecycleQosPolicy.java
===================================================================
--- ftf_vote_01/srcJava/org/omg/dds/core/policy/ReaderDataLifecycleQosPolicy.java	(revision 139)
+++ ftf_vote_01/srcJava/org/omg/dds/core/policy/ReaderDataLifecycleQosPolicy.java	(working copy)
@@ -20,8 +20,62 @@
 
 import org.omg.dds.core.Duration;
 import org.omg.dds.core.policy.modifiable.ModifiableReaderDataLifecycleQosPolicy;
+import org.omg.dds.sub.DataReader;
+import org.omg.dds.sub.InstanceState;
+import org.omg.dds.sub.ViewState;
 
 
+/**
+ * Specifies the behavior of the {@link DataReader} with regards to the life
+ * cycle of the data instances it manages.
+ * 
+ * <b>Concerns:</b> {@link DataReader}
+ * 
+ * <b>RxO:</b> N/A
+ * 
+ * <b>Changeable:</b> Yes
+ * 
+ * This policy controls the behavior of the DataReader with regards to the
+ * lifecycle of the data instances it manages, that is, the data instance
+ * that have been received and for which the DataReader maintains some
+ * internal resources.
+ * 
+ * The DataReader internally maintains the samples that have not been taken
+ * by the application, subject to the constraints imposed by other QoS
+ * policies such as {@link HistoryQosPolicy} and
+ * {@link ResourceLimitsQosPolicy}.
+ * 
+ * The DataReader also maintains information regarding the identity,
+ * {@link ViewState} and {@link InstanceState} of data instances even after
+ * all samples have been 'taken.' This is needed to properly compute the
+ * states when future samples arrive.
+ * 
+ * Under normal circumstances the DataReader can only reclaim all resources
+ * for instances for which there are no writers and for which all samples
+ * have been 'taken.' The last sample the DataReader will have taken for that
+ * instance will have an instance state of either
+ * {@link InstanceState#NOT_ALIVE_NO_WRITERS} or
+ * {@link InstanceState#NOT_ALIVE_DISPOSED} depending on whether the last
+ * writer that had ownership of the instance disposed it or not. In the
+ * absence of the READER_DATA_LIFECYCLE QoS this behavior could cause
+ * problems if the application "forgets" to 'take' those samples. The
+ * 'untaken' samples will prevent the DataReader from reclaiming the
+ * resources and they would remain in the DataReader indefinitely.
+ * 
+ * The autoPurgeNoWriterSamplesDelay defines the maximum duration for which
+ * the DataReader will maintain information regarding an instance once its
+ * instance state becomes NOT_ALIVE_NO_WRITERS. After this time elapses, the
+ * DataReader will purge all internal information regarding the instance; any
+ * untaken samples will also be lost.
+ * 
+ * The autoPurgeDisposedSamplesDelay defines the maximum duration for which
+ * the DataReader will maintain samples for an instance once its instance
+ * state becomes NOT_ALIVE_DISPOSED. After this time elapses, the DataReader
+ * will purge all samples for the instance.
+ * 
+ * @see HistoryQosPolicy
+ * @see ResourceLimitsQosPolicy
+ */
 public interface ReaderDataLifecycleQosPolicy
 extends QosPolicy<ReaderDataLifecycleQosPolicy,
                   ModifiableReaderDataLifecycleQosPolicy> {
Index: ftf_vote_01/srcJava/org/omg/dds/core/policy/LivelinessQosPolicy.java
===================================================================
--- ftf_vote_01/srcJava/org/omg/dds/core/policy/LivelinessQosPolicy.java	(revision 139)
+++ ftf_vote_01/srcJava/org/omg/dds/core/policy/LivelinessQosPolicy.java	(working copy)
@@ -19,9 +19,90 @@
 package org.omg.dds.core.policy;
 
 import org.omg.dds.core.Duration;
+import org.omg.dds.core.Entity;
+import org.omg.dds.core.WaitSet;
 import org.omg.dds.core.policy.modifiable.ModifiableLivelinessQosPolicy;
+import org.omg.dds.core.status.LivelinessChangedStatus;
+import org.omg.dds.core.status.Status;
+import org.omg.dds.domain.DomainParticipant;
+import org.omg.dds.pub.DataWriter;
+import org.omg.dds.sub.DataReader;
+import org.omg.dds.topic.Topic;
 
 
+/**
+ * Determines the mechanism and parameters used by the application to
+ * determine whether an {@link Entity} is "active" (alive). The "liveliness"
+ * status of an Entity is used to maintain instance ownership in combination
+ * with the setting of the {@link OwnershipQosPolicy}. The application is
+ * also informed via an Entity {@link Status} change when an Entity is no
+ * longer alive. The {@link DataReader} requests that liveliness of the
+ * writers is maintained by the requested means and loss of liveliness is
+ * detected with delay not to exceed the leaseDuration. The {@link DataWriter}
+ * commits to signaling its liveliness using the stated means at intervals
+ * not to exceed the leaseDuration. The default kind is
+ * {@link LivelinessQosPolicy.Kind#AUTOMATIC} and the default value of the
+ * leaseDuration is infinite.
+ * 
+ * <b>Concerns:</b> {@link Topic}, {@link DataReader}, {@link DataWriter}
+ * 
+ * <b>RxO:</b> Yes
+ * 
+ * <b>Changeable:</b> No
+ * 
+ * This policy has several settings to support both data objects that are
+ * updated periodically as well as those that are changed sporadically. It
+ * also allows customizing for different application requirements in terms of
+ * the kinds of failures that will be detected by the liveliness mechanism.
+ * 
+ * The {@link Kind#AUTOMATIC} liveliness setting is most appropriate for
+ * applications that only need to detect failures at the process level, but
+ * not application-logic failures within a process. The Service takes
+ * responsibility for renewing the leases at the required rates and thus, as
+ * long as the local process where a {@link DomainParticipant} is running and
+ * the link connecting it to remote participants remains connected, the
+ * entities within the DomainParticipant will be considered alive. This
+ * requires the lowest overhead.
+ * 
+ * The MANUAL settings ({@link Kind#MANUAL_BY_PARTICIPANT},
+ * {@link Kind#MANUAL_BY_TOPIC}) require the application on the publishing
+ * side to periodically assert the liveliness before the lease expires to
+ * indicate the corresponding Entity is still alive. The action can be
+ * explicit by calling the <code>assertLiveliness</code> operations
+ * ({@link DataWriter#assertLiveliness()},
+ * {@link DomainParticipant#assertLiveliness()}) or implicit by writing some
+ * data.
+ * 
+ * The two possible manual settings control the granularity at which the
+ * application must assert liveliness.
+ * 
+ * <ul>
+ *      <li>The setting MANUAL_BY_PARTICIPANT requires only that one Entity
+ *          within the publisher is asserted to be alive to deduce all other
+ *          Entity objects within the same DomainParticipant are also alive.
+ *      <li>The setting MANUAL_BY_TOPIC requires that at least one instance
+ *          within the DataWriter is asserted.</li>
+ * </ul>
+ * 
+ * The value offered is considered compatible with the value requested if and
+ * only if the following conditions are met:
+ * 
+ * <ol>
+ *      <li>the inequality "offered kind &gt;= requested kind" evaluates to
+ *          true. For the purposes of this inequality, the values of
+ *          LIVELINESS kind are considered ordered such that:
+ *          <code>AUTOMATIC &lt; MANUAL_BY_PARTICIPANT &lt; MANUAL_BY_TOPIC
+ *          </code>.</li>
+ *      <li>the inequality "offered leaseDuration <= requested
+ *          leaseDuration" evaluates to true.</li>
+ * </ol>
+ * 
+ * Changes in LIVELINESS must be detected by the Service with a
+ * time granularity greater or equal to the leaseDuration. This ensures that
+ * the value of the {@link LivelinessChangedStatus} is updated at least once
+ * during each leaseDuration and the related Listeners and {@link WaitSet}s
+ * are notified within a leaseDuration from the time the LIVELINESS changed.
+ */
 public interface LivelinessQosPolicy
 extends QosPolicy<LivelinessQosPolicy, ModifiableLivelinessQosPolicy> {
     // -----------------------------------------------------------------------
@@ -42,8 +123,35 @@
     // -----------------------------------------------------------------------
 
     public enum Kind {
+        /**
+         * The infrastructure will automatically signal liveliness for the
+         * {@link DataWriter}s at least as often as required by the
+         * leaseDuration.
+         */
         AUTOMATIC,
+
+        /**
+         * The user application takes responsibility to signal liveliness to
+         * the Service. Liveliness must be asserted at least once every
+         * leaseDuration otherwise the Service will assume the corresponding
+         * {@link Entity} is no longer "active/alive."
+         * 
+         * The Service will assume that as long as at least one {@link Entity}
+         * within the {@link DomainParticipant} has asserted its liveliness
+         * the other Entities in that same DomainParticipant are also alive.
+         */
         MANUAL_BY_PARTICIPANT,
+
+        /**
+         * The user application takes responsibility to signal liveliness to
+         * the Service. Liveliness must be asserted at least once every
+         * leaseDuration otherwise the Service will assume the corresponding
+         * {@link Entity} is no longer "active/alive."
+         * 
+         * The Service will only assume liveliness of the {@link DataWriter}
+         * if the application has asserted liveliness of that DataWriter
+         * itself.
+         */
         MANUAL_BY_TOPIC
     }
 
Index: ftf_vote_01/srcJava/org/omg/dds/core/policy/DestinationOrderQosPolicy.java
===================================================================
--- ftf_vote_01/srcJava/org/omg/dds/core/policy/DestinationOrderQosPolicy.java	(revision 139)
+++ ftf_vote_01/srcJava/org/omg/dds/core/policy/DestinationOrderQosPolicy.java	(working copy)
@@ -19,8 +19,49 @@
 package org.omg.dds.core.policy;
 
 import org.omg.dds.core.policy.modifiable.ModifiableDestinationOrderQosPolicy;
+import org.omg.dds.pub.DataWriter;
+import org.omg.dds.pub.Publisher;
+import org.omg.dds.sub.DataReader;
+import org.omg.dds.sub.Subscriber;
+import org.omg.dds.topic.Topic;
 
 
+/**
+ * Controls the criteria used to determine the logical order among changes
+ * made by {@link Publisher} entities to the same instance of data (i.e.,
+ * matching Topic and key). The default kind is
+ * {@link DestinationOrderQosPolicy.Kind#BY_RECEPTION_TIMESTAMP}.
+ * 
+ * <b>Concerns:</b> {@link Topic}, {@link DataReader}, {@link DataWriter}
+ * 
+ * <b>RxO:</b> Yes
+ * 
+ * <b>Changeable:</b> No
+ * 
+ * This policy controls how each subscriber resolves the final value of a
+ * data instance that is written by multiple DataWriter objects (which may be
+ * associated with different Publisher objects) running on different nodes.
+ * 
+ * The setting {@link Kind#BY_RECEPTION_TIMESTAMP} indicates that, assuming
+ * the {@link OwnershipQosPolicy} allows it, the latest received value for
+ * the instance should be the one whose value is kept. This is the default
+ * value.
+ * 
+ * The setting {@link Kind#BY_SOURCE_TIMESTAMP} indicates that, assuming the
+ * {@link OwnershipQosPolicy} allows it, a time stamp placed at the source
+ * should be used. This is the only setting that, in the case of concurrent
+ * same-strength DataWriter objects updating the same instance, ensures all
+ * subscribers will end up with the same final value for the instance. The
+ * mechanism to set the source time stamp is middleware dependent.
+ * 
+ * The value offered is considered compatible with the value requested if and
+ * only if the inequality "offered kind &gt;= requested kind" evaluates to
+ * true. For the purposes of this inequality, the values of DESTINATION_ORDER
+ * kind are considered ordered such that BY_RECEPTION_TIMESTAMP &lt;
+ * BY_SOURCE_TIMESTAMP.
+ * 
+ * @see OwnershipQosPolicy
+ */
 public interface DestinationOrderQosPolicy
 extends QosPolicy<DestinationOrderQosPolicy,
         ModifiableDestinationOrderQosPolicy> {
@@ -40,7 +81,21 @@
     // -----------------------------------------------------------------------
 
     public enum Kind {
+        /**
+         * Indicates that data is ordered based on the reception time at each
+         * {@link Subscriber}. Since each subscriber may receive the data at
+         * different times there is no guaranteed that the changes will be
+         * seen in the same order. Consequently, it is possible for each
+         * subscriber to end up with a different final value for the data.
+         */
         BY_RECEPTION_TIMESTAMP,
+
+        /**
+         * Indicates that data is ordered based on a time stamp placed at the
+         * source (by the Service or by the application). In any case this
+         * guarantees a consistent final value for the data in all
+         * subscribers.
+         */
         BY_SOURCE_TIMESTAMP
     }
 
Index: ftf_vote_01/srcJava/org/omg/dds/core/policy/OwnershipQosPolicy.java
===================================================================
--- ftf_vote_01/srcJava/org/omg/dds/core/policy/OwnershipQosPolicy.java	(revision 139)
+++ ftf_vote_01/srcJava/org/omg/dds/core/policy/OwnershipQosPolicy.java	(working copy)
@@ -19,8 +19,24 @@
 package org.omg.dds.core.policy;
 
 import org.omg.dds.core.policy.modifiable.ModifiableOwnershipQosPolicy;
+import org.omg.dds.pub.DataWriter;
+import org.omg.dds.sub.DataReader;
+import org.omg.dds.topic.Topic;
 
 
+/**
+ * [optional] Specifies whether it is allowed for multiple {@link DataWriter}s
+ * to write the same instance of the data and if so, how these modifications
+ * should be arbitrated.
+ * 
+ * <b>Concerns:</b> {@link Topic}, {@link DataReader}, {@link DataWriter}
+ * 
+ * <b>RxO:</b> Yes
+ * 
+ * <b>Changeable:</b> No
+ * 
+ * @see OwnershipStrengthQosPolicy
+ */
 public interface OwnershipQosPolicy
 extends QosPolicy<OwnershipQosPolicy, ModifiableOwnershipQosPolicy> {
     // -----------------------------------------------------------------------
@@ -39,7 +55,23 @@
     // -----------------------------------------------------------------------
 
     public enum Kind {
+        /**
+         * Indicates shared ownership for each instance. Multiple writers are
+         * allowed to update the same instance and all the updates are made
+         * available to the readers. In other words there is no concept of an
+         * "owner" for the instances. This is the default behavior.
+         */
         SHARED,
+
+        /**
+         * Indicates each instance can only be owned by one
+         * {@link DataWriter}, but the owner of an instance can change
+         * dynamically. The selection of the owner is controlled by the
+         * setting of the {@link OwnershipStrengthQosPolicy}. The owner is
+         * always set to be the highest-strength DataWriter object among the
+         * ones currently "active" (as determined by the
+         * {@link LivelinessQosPolicy}).
+         */
         EXCLUSIVE
     }
 
Index: ftf_vote_01/srcJava/org/omg/dds/core/policy/QosPolicy.java
===================================================================
--- ftf_vote_01/srcJava/org/omg/dds/core/policy/QosPolicy.java	(revision 139)
+++ ftf_vote_01/srcJava/org/omg/dds/core/policy/QosPolicy.java	(working copy)
@@ -19,10 +19,17 @@
 package org.omg.dds.core.policy;
 
 import org.omg.dds.core.Bootstrap;
+import org.omg.dds.core.Condition;
 import org.omg.dds.core.Entity;
 import org.omg.dds.core.Value;
+import org.omg.dds.core.status.OfferedIncompatibleQosStatus;
+import org.omg.dds.core.status.RequestedIncompatibleQosStatus;
 import org.omg.dds.domain.DomainParticipant;
+import org.omg.dds.pub.DataWriter;
+import org.omg.dds.pub.DataWriterListener;
 import org.omg.dds.pub.Publisher;
+import org.omg.dds.sub.DataReader;
+import org.omg.dds.sub.DataReaderListener;
 import org.omg.dds.topic.Topic;
 import org.omg.dds.type.Extensibility;
 import org.omg.dds.type.Nested;
@@ -57,9 +64,57 @@
  * When a policy is changed after being set to a given value, it is not
  * required that the new value be applied instantaneously; the Service is
  * allowed to apply it after a transition phase. In addition, some QosPolicy
- * have immutable semantics meaning that they can only be specified either
+ * have "immutable" semantics meaning that they can only be specified either
  * at Entity creation time or else prior to calling the
  * {@link Entity#enable()} operation on the Entity.
+ * 
+ * <b>Properties of QoS Policies</b>
+ * 
+ * In several cases, for communications to occur properly (or efficiently), a
+ * QosPolicy on the publisher side must be compatible with a corresponding
+ * policy on the subscriber side. For example, if a {@link DataReader}
+ * requests to receive data reliably while the corresponding
+ * {@link DataWriter} defines a best-effort policy, communication will not
+ * happen as requested. To address this issue and maintain the desirable
+ * decoupling of publication and subscription as much as possible, the
+ * specification for QosPolicy follows the subscriber-requested,
+ * publisher-offered pattern. In this pattern, the subscriber side can
+ * specify a "requested" value for a particular QosPolicy. The publisher side
+ * specifies an "offered" value for that QosPolicy. The Service will then
+ * determine whether the value requested by the subscriber side is compatible
+ * with what is offered by the publisher side. If the two policies are
+ * compatible, then communication will be established. If the two policies
+ * are not compatible, the Service will not establish communications between
+ * the two {@link Entity} objects and will record this fact by means of the
+ * {@link OfferedIncompatibleQosStatus} status on the publisher end and
+ * {@link RequestedIncompatibleQosStatus} status on the subscriber end. The
+ * application can detect this fact by means of a listener (e.g.
+ * {@link DataReaderListener} or {@link DataWriterListener}) or
+ * {@link Condition}s.
+ * 
+ * The QosPolicy objects that need to be set in a compatible manner between
+ * the publisher and subscriber ends are indicated by the setting of the
+ * "RxO" (Requested/Offered) property:
+ * 
+ * <ul>
+ *      <li>An "RxO" setting of "Yes" indicates that the policy can be set
+ *          both at the publishing and subscribing ends and the values must
+ *          be set in a compatible manner. In this case the compatible values
+ *          are explicitly defined.</li>
+ *      <li>An "RxO" setting of "No" indicates that the policy can be set
+ *          both at the publishing and subscribing ends but the two settings
+ *          are independent. That is, all combinations of values are
+ *          compatible.</li>
+ *      <li>An "RxO" setting of "N/A" indicates that the policy can only be
+ *          specified at either the publishing or the subscribing end, but
+ *          not at both ends. So compatibility does not apply.</li>
+ * </ul>
+ * 
+ * The "changeable" property determines whether the QosPolicy can be changed
+ * after the Entity is enabled. In other words, a policy with "changeable"
+ * setting of "NO" is considered "immutable" and can only be specified either
+ * at {@link Entity} creation time or else prior to calling the
+ * {@link Entity#enable()} operation.
  */
 @Extensibility(Extensibility.Kind.EXTENSIBLE_EXTENSIBILITY)
 @Nested
Index: ftf_vote_01/srcJava/org/omg/dds/core/policy/WriterDataLifecycleQosPolicy.java
===================================================================
--- ftf_vote_01/srcJava/org/omg/dds/core/policy/WriterDataLifecycleQosPolicy.java	(revision 139)
+++ ftf_vote_01/srcJava/org/omg/dds/core/policy/WriterDataLifecycleQosPolicy.java	(working copy)
@@ -19,8 +19,59 @@
 package org.omg.dds.core.policy;
 
 import org.omg.dds.core.policy.modifiable.ModifiableWriterDataLifecycleQosPolicy;
+import org.omg.dds.domain.DomainParticipant;
+import org.omg.dds.pub.DataWriter;
+import org.omg.dds.pub.Publisher;
 
 
+/**
+ * Specifies the behavior of the {@link DataWriter} with regards to the life
+ * cycle of the data instances it manages.
+ * 
+ * <b>Concerns:</b> {@link DataWriter}
+ * 
+ * <b>RxO:</b> N/A
+ * 
+ * <b>Changeable:</b> Yes
+ * 
+ * This policy controls the behavior of the DataWriter with regards to the
+ * lifecycle of the data instances it manages, that is, the data instances
+ * that have been either explicitly registered with the DataWriter using the
+ * {@link DataWriter#registerInstance(Object)} operations or implicitly by
+ * directly writing the data (see {@link DataWriter#write(Object)}).
+ * 
+ * The autodisposeUnregisteredInstances flag controls the behavior when the
+ * DataWriter unregisters an instance by means of the
+ * {@link DataWriter#unregisterInstance(org.omg.dds.core.InstanceHandle)}
+ * operations:
+ * 
+ * <ul>
+ *     <li>The setting "autodisposeUnregisteredInstances = true' causes the
+ *         DataWriter to dispose the instance each time it is unregistered.
+ *         The behavior is identical to explicitly calling one of the
+ *         {@link DataWriter#dispose(org.omg.dds.core.InstanceHandle)}
+ *         operations on the instance prior to calling the unregister
+ *         operation.</li>
+ * 
+ *     <li>The setting 'autodisposeUnregisteredInstances = false' will not
+ *         cause this automatic disposition upon unregistering. The
+ *         application can still call one of the dispose operations prior to
+ *         unregistering the instance and accomplish the same effect.
+ *         Refer to Section 7.1.3.23.3 of the DDS specification, "Semantic
+ *         difference between unregister_instance and dispose", for a
+ *         description of the consequences of disposing and unregistering
+ *         instances.</li>
+ * </ul>
+ * 
+ * Note that the deletion of a DataWriter automatically unregisters all data
+ * instances it manages (see {@link DataWriter#close()}). Therefore the
+ * setting of the autodisposeUnregisteredInstances flag will determine
+ * whether instances are ultimately disposed when the DataWriter is deleted
+ * either directly by means of the {@link DataWriter#close()} operation or
+ * indirectly as a consequence of calling
+ * {@link Publisher#closeContainedEntities()} or
+ * {@link DomainParticipant#closeContainedEntities()}.
+ */
 public interface WriterDataLifecycleQosPolicy
 extends QosPolicy<WriterDataLifecycleQosPolicy,
                   ModifiableWriterDataLifecycleQosPolicy> {
Index: ftf_vote_01/srcJava/org/omg/dds/core/policy/GroupDataQosPolicy.java
===================================================================
--- ftf_vote_01/srcJava/org/omg/dds/core/policy/GroupDataQosPolicy.java	(revision 139)
+++ ftf_vote_01/srcJava/org/omg/dds/core/policy/GroupDataQosPolicy.java	(working copy)
@@ -19,8 +19,35 @@
 package org.omg.dds.core.policy;
 
 import org.omg.dds.core.policy.modifiable.ModifiableGroupDataQosPolicy;
+import org.omg.dds.pub.DataWriter;
+import org.omg.dds.pub.DataWriterListener;
+import org.omg.dds.pub.Publisher;
+import org.omg.dds.sub.DataReader;
+import org.omg.dds.sub.DataReaderListener;
+import org.omg.dds.sub.Subscriber;
 
 
+/**
+ * User data not known by the middleware, but distributed by means of
+ * built-in topics. The default value is an empty (zero-sized) sequence.
+ * 
+ * <b>Concerns:</b> {@link Publisher}, {@link Subscriber}
+ * 
+ * <b>RxO:</b> No
+ * 
+ * <b>Changeable:</b> Yes
+ * 
+ * The purpose of this QoS is to allow the application to attach additional
+ * information to the created {@link Publisher} or {@link Subscriber}. The
+ * value of the GROUP_DATA is available to the application on the
+ * {@link DataReader} and {@link DataWriter} entities and is propagated by
+ * means of the built-in topics.
+ * 
+ * This QoS can be used by an application combination with the
+ * {@link DataReaderListener} and {@link DataWriterListener} to implement
+ * matching policies similar to those of the {@link PartitionQosPolicy}
+ * except the decision can be made based on an application-defined policy.
+ */
 public interface GroupDataQosPolicy
 extends QosPolicy<GroupDataQosPolicy, ModifiableGroupDataQosPolicy> {
     /**
Index: ftf_vote_01/srcJava/org/omg/dds/core/policy/DurabilityServiceQosPolicy.java
===================================================================
--- ftf_vote_01/srcJava/org/omg/dds/core/policy/DurabilityServiceQosPolicy.java	(revision 139)
+++ ftf_vote_01/srcJava/org/omg/dds/core/policy/DurabilityServiceQosPolicy.java	(working copy)
@@ -20,8 +20,32 @@
 
 import org.omg.dds.core.Duration;
 import org.omg.dds.core.policy.modifiable.ModifiableDurabilityServiceQosPolicy;
+import org.omg.dds.pub.DataWriter;
+import org.omg.dds.sub.DataReader;
+import org.omg.dds.topic.Topic;
 
 
+/**
+ * Specifies the configuration of the durability service. That is, the
+ * service that implements the {@link DurabilityQosPolicy.Kind} of
+ * {@link DurabilityQosPolicy.Kind#TRANSIENT} and
+ * {@link DurabilityQosPolicy.Kind#PERSISTENT}.
+ * 
+ * <b>Concerns:</b> {@link Topic}, {@link DataWriter}
+ * 
+ * <b>RxO:</b> No
+ * 
+ * <b>Changeable:</b> No
+ * 
+ * This policy is used to configure the {@link HistoryQosPolicy} and the
+ * {@link ResourceLimitsQosPolicy} used by the fictitious {@link DataReader}
+ * and {@link DataWriter} used by the "persistence service." The "persistence
+ * service" is the one responsible for implementing
+ * {@link DurabilityQosPolicy.Kind#TRANSIENT} and
+ * {@link DurabilityQosPolicy.Kind#PERSISTENT}.
+ * 
+ * @see DurabilityQosPolicy
+ */
 public interface DurabilityServiceQosPolicy
 extends QosPolicy<DurabilityServiceQosPolicy,
                   ModifiableDurabilityServiceQosPolicy> {
Index: ftf_vote_01/srcJava/org/omg/dds/core/policy/LatencyBudgetQosPolicy.java
===================================================================
--- ftf_vote_01/srcJava/org/omg/dds/core/policy/LatencyBudgetQosPolicy.java	(revision 139)
+++ ftf_vote_01/srcJava/org/omg/dds/core/policy/LatencyBudgetQosPolicy.java	(working copy)
@@ -20,8 +20,37 @@
 
 import org.omg.dds.core.Duration;
 import org.omg.dds.core.policy.modifiable.ModifiableLatencyBudgetQosPolicy;
+import org.omg.dds.pub.DataWriter;
+import org.omg.dds.sub.DataReader;
+import org.omg.dds.topic.Topic;
 
 
+/**
+ * Specifies the maximum acceptable delay from the time the data is written
+ * until the data is inserted in the receiver's application cache and the
+ * receiving application is notified of the fact. This policy is a hint to
+ * the Service, not something that must be monitored or enforced. The Service
+ * is not required to track or alert the user of any violation. The default
+ * value of the duration is zero indicating that the delay should be
+ * minimized.
+ * 
+ * <b>Concerns:</b> {@link Topic}, {@link DataReader}, {@link DataWriter}
+ * 
+ * <b>RxO:</b> Yes
+ * 
+ * <b>Changeable:</b> Yes
+ * 
+ * This policy provides a means for the application to indicate to the
+ * middleware the "urgency" of the data communication. By having a non-zero
+ * duration the Service can optimize its internal operation.
+ * 
+ * This policy is considered a hint. There is no specified mechanism as to
+ * how the service should take advantage of this hint.
+ * 
+ * The value offered is considered compatible with the value requested if and
+ * only if the inequality "offered duration <= requested duration" evaluates
+ * to true.
+ */
 public interface LatencyBudgetQosPolicy
 extends QosPolicy<LatencyBudgetQosPolicy, ModifiableLatencyBudgetQosPolicy> {
     public Duration getDuration();
Index: ftf_vote_01/srcJava/org/omg/dds/core/InstanceHandle.java
===================================================================
--- ftf_vote_01/srcJava/org/omg/dds/core/InstanceHandle.java	(revision 139)
+++ ftf_vote_01/srcJava/org/omg/dds/core/InstanceHandle.java	(working copy)
@@ -21,6 +21,9 @@
 import org.omg.dds.core.modifiable.ModifiableInstanceHandle;
 
 
+/**
+ * An opaque handle that can be used to refer to a local or remote entity.
+ */
 public abstract class InstanceHandle
 implements Value<InstanceHandle, ModifiableInstanceHandle>
 {
Index: ftf_vote_01/srcJava/org/omg/dds/core/WaitSet.java
===================================================================
--- ftf_vote_01/srcJava/org/omg/dds/core/WaitSet.java	(revision 139)
+++ ftf_vote_01/srcJava/org/omg/dds/core/WaitSet.java	(working copy)
@@ -23,6 +23,10 @@
 import java.util.concurrent.TimeoutException;
 
 import org.omg.dds.domain.DomainParticipant;
+import org.omg.dds.sub.DataReader;
+import org.omg.dds.sub.QueryCondition;
+import org.omg.dds.sub.ReadCondition;
+import org.omg.dds.sub.Subscriber;
 
 
 /**
@@ -33,6 +37,58 @@
  * WaitSet is not necessarily associated with a single
  * {@link DomainParticipant} and could be used to wait on Condition objects
  * associated with different DomainParticipant objects.
+ * 
+ * This mechanism is wait-based. Its general use pattern is as follows:
+ * 
+ * <ul>
+ *     <li>The application indicates which relevant information it wants to
+ *         get by creating {@link Condition} objects
+ *         ({@link StatusCondition}, {@link ReadCondition} or
+ *         {@link QueryCondition}) and attaching them to a WaitSet.</li>
+ *     <li>It then waits on that WaitSet until the triggerValue of one or
+ *         several Condition objects become true.</li>
+ *     <li>It then uses the result of the wait (i.e., the list of Condition
+ *         objects with triggerValue == true) to actually get the information
+ *         by calling:<ul>
+ *         <li>{@link Entity#getStatusChanges(Collection)} and then
+ *             <code>get&lt;<i>CommunicationStatus</i>&gt;</code> on the
+ *             relevant Entity.</li>
+ *         <li>{@link Entity#getStatusChanges(Collection)} and then
+ *             {@link Subscriber#getDataReaders(Collection)} on the relevant
+ *             Subscriber.</li>
+ *         <li>{@link Entity#getStatusChanges(Collection)} and then
+ *             {@link DataReader#read()}/{@link DataReader#take()} on the
+ *             relevant DataReader.</li>
+ *         <li>Directly call {@link DataReader#read(ReadCondition)}/
+ *             {@link DataReader#read(ReadCondition)} with the Condition as a
+ *             parameter if it is a ReadCondition or a QueryCondition.</li>
+ *         </ul></li>
+ * </ul>
+ * 
+ * Usually the first step is done in an initialization phase, while the
+ * others are put in the application main loop.
+ * 
+ * As there is no extra information passed from the middleware to the
+ * application when a wait returns (only the list of triggered Condition
+ * objects), Condition objects are meant to embed all that is needed to react
+ * properly when enabled. In particular, Entity-related conditions are
+ * related to exactly one Entity and cannot be shared.
+ * 
+ * The blocking behavior of the WaitSet is described below. The result of a
+ * {@link #waitForConditions()} operation depends on the state of the
+ * WaitSet, which in turn depends on whether at least one attached Condition
+ * has a triggerValue of true. If the {@link #waitForConditions()} operation
+ * is called on WaitSet that is blocked, it will block the calling thread.
+ * If {@link #waitForConditions()} is called on a WaitSet that is unblocked,
+ * it will return immediately. In addition, when the WaitSet transitions from
+ * BLOCKED to UNBLOCKED it wakes up any threads that had called
+ * {@link #waitForConditions()} on it.
+ * 
+ * Similar to the invocation of listeners, there is no implied "event
+ * queuing" in the awakening of a WaitSet in the sense that, if several
+ * Conditions attached to the WaitSet have their triggerValue transition to
+ * true in sequence the DCPS implementation needs to only unblock the WaitSet
+ * once.
  */
 public abstract class WaitSet implements DDSObject {
     // -----------------------------------------------------------------------
@@ -53,33 +109,162 @@
     // Instance Methods
     // -----------------------------------------------------------------------
 
+    /**
+     * This operation allows an application thread to wait for the occurrence
+     * of certain conditions. If none of the conditions attached to the
+     * WaitSet have a triggerValue of true, the operation will block
+     * suspending the calling thread.
+     * 
+     * The result of the wait operation is the list of all the attached
+     * conditions that have a triggerValue of true (i.e., the conditions that
+     * unblocked the wait).
+     * 
+     * It is not allowed for more than one application thread to be waiting
+     * on the same WaitSet. If the operation is invoked on a WaitSet that
+     * already has a thread blocking on it, the operation will fail with the
+     * value {@link PreconditionNotMetException}.
+     */
     public abstract void waitForConditions() throws TimeoutException;
 
+    /**
+     * This operation allows an application thread to wait for the occurrence
+     * of certain conditions. If none of the conditions attached to the
+     * WaitSet have a triggerValue of true, the operation will block
+     * suspending the calling thread.
+     * 
+     * The result of the wait operation is the list of all the attached
+     * conditions that have a triggerValue of true (i.e., the conditions that
+     * unblocked the wait).
+     * 
+     * It is not allowed for more than one application thread to be waiting
+     * on the same WaitSet. If the operation is invoked on a WaitSet that
+     * already has a thread blocking on it, the operation will fail with the
+     * value {@link PreconditionNotMetException}.
+     */
     public abstract void waitForConditions(
             Collection<Condition> activeConditions)
     throws TimeoutException;
 
+    /**
+     * This operation allows an application thread to wait for the occurrence
+     * of certain conditions. If none of the conditions attached to the
+     * WaitSet have a triggerValue of true, the operation will block
+     * suspending the calling thread.
+     * 
+     * The result of the wait operation is the list of all the attached
+     * conditions that have a triggerValue of true (i.e., the conditions that
+     * unblocked the wait).
+     * 
+     * It is not allowed for more than one application thread to be waiting
+     * on the same WaitSet. If the operation is invoked on a WaitSet that
+     * already has a thread blocking on it, the operation will fail with the
+     * value {@link PreconditionNotMetException}.
+     * 
+     * @throws  TimeoutException    if the timeout argument, which specifies
+     *          the maximum duration for the wait, is exceeded and none of
+     *          the attached Condition objects is true.
+     */
     public abstract void waitForConditions(Duration timeout)
     throws TimeoutException;
 
+    /**
+     * This operation allows an application thread to wait for the occurrence
+     * of certain conditions. If none of the conditions attached to the
+     * WaitSet have a triggerValue of true, the operation will block
+     * suspending the calling thread.
+     * 
+     * The result of the wait operation is the list of all the attached
+     * conditions that have a triggerValue of true (i.e., the conditions that
+     * unblocked the wait).
+     * 
+     * It is not allowed for more than one application thread to be waiting
+     * on the same WaitSet. If the operation is invoked on a WaitSet that
+     * already has a thread blocking on it, the operation will fail with the
+     * value {@link PreconditionNotMetException}.
+     * 
+     * @throws  TimeoutException    if the timeout argument, which specifies
+     *          the maximum duration for the wait, is exceeded and none of
+     *          the attached Condition objects is true.
+     */
     public abstract void waitForConditions(long timeout, TimeUnit unit)
     throws TimeoutException;
 
+    /**
+     * This operation allows an application thread to wait for the occurrence
+     * of certain conditions. If none of the conditions attached to the
+     * WaitSet have a triggerValue of true, the operation will block
+     * suspending the calling thread.
+     * 
+     * The result of the wait operation is the list of all the attached
+     * conditions that have a triggerValue of true (i.e., the conditions that
+     * unblocked the wait).
+     * 
+     * It is not allowed for more than one application thread to be waiting
+     * on the same WaitSet. If the operation is invoked on a WaitSet that
+     * already has a thread blocking on it, the operation will fail with the
+     * value {@link PreconditionNotMetException}.
+     * 
+     * @throws  TimeoutException    if the timeout argument, which specifies
+     *          the maximum duration for the wait, is exceeded and none of
+     *          the attached Condition objects is true.
+     */
     public abstract void waitForConditions(
             Collection<Condition> activeConditions,
             Duration timeout)
     throws TimeoutException;
 
+    /**
+     * This operation allows an application thread to wait for the occurrence
+     * of certain conditions. If none of the conditions attached to the
+     * WaitSet have a triggerValue of true, the operation will block
+     * suspending the calling thread.
+     * 
+     * The result of the wait operation is the list of all the attached
+     * conditions that have a triggerValue of true (i.e., the conditions that
+     * unblocked the wait).
+     * 
+     * It is not allowed for more than one application thread to be waiting
+     * on the same WaitSet. If the operation is invoked on a WaitSet that
+     * already has a thread blocking on it, the operation will fail with the
+     * value {@link PreconditionNotMetException}.
+     * 
+     * @throws  TimeoutException    if the timeout argument, which specifies
+     *          the maximum duration for the wait, is exceeded and none of
+     *          the attached Condition objects is true.
+     */
     public abstract void waitForConditions(
             Collection<Condition> activeConditions,
             long timeout,
             TimeUnit unit)
     throws TimeoutException;
 
+    /**
+     * Attaches a Condition to the WaitSet.
+     * 
+     * It is possible to attach a Condition on a WaitSet that is currently
+     * being waited upon (via the {@link #waitForConditions()} operation).
+     * In this case, if the Condition has a triggerValue of true, then
+     * attaching the condition will unblock the WaitSet.
+     * 
+     * Adding a Condition that is already attached to the WaitSet has no
+     * effect.
+     * 
+     * @throws  OutOfResourcesException if attaching the condition requires
+     *          the allocation of unavailable middleware or OS resources.
+     */
     public abstract void attachCondition(Condition cond);
+
+    /**
+     * Detaches a Condition from the WaitSet.
+     * 
+     * @throws  PreconditionNotMetException     if the Condition was not
+     *          attached to the WaitSet.
+     */
     public abstract void detachCondition(Condition cond);
 
     /**
+     * This operation retrieves the list of attached conditions.
+     * 
      * @return  an unmodifiable collection of the conditions attached to this
      *          wait set.
      */
Index: ftf_vote_01/srcJava/org/omg/dds/core/Condition.java
===================================================================
--- ftf_vote_01/srcJava/org/omg/dds/core/Condition.java	(revision 139)
+++ ftf_vote_01/srcJava/org/omg/dds/core/Condition.java	(working copy)
@@ -32,5 +32,8 @@
  * automatically by the Service.
  */
 public interface Condition extends DDSObject {
+    /**
+     * @return  the triggerValue of the Condition.
+     */
     public boolean getTriggerValue();
 }
Index: ftf_vote_01/srcJava/org/omg/dds/core/StatusCondition.java
===================================================================
--- ftf_vote_01/srcJava/org/omg/dds/core/StatusCondition.java	(revision 139)
+++ ftf_vote_01/srcJava/org/omg/dds/core/StatusCondition.java	(working copy)
@@ -30,20 +30,59 @@
  * information, etc.), "filtered" by the set of enabledStatuses on the
  * StatusCondition.
  * 
+ * The triggerValue of a StatusCondition is the Boolean OR of the
+ * ChangedStatusFlag of all the communication statuses to which it is
+ * sensitive. That is, triggerValue == false only if all the values of the
+ * ChangedStatusFlags are false.
+ * 
+ * The sensitivity of the StatusCondition to a particular communication
+ * status is controlled by the list of enabledStatuses set on the condition
+ * by means of {@link #setEnabledStatuses(Collection)}.
+ * 
  * @param <ENTITY>      The type of the entity with which this condition is
  *                      associated.
  */
 public interface StatusCondition<ENTITY extends Entity<ENTITY, ?, ?>>
 extends Condition {
+    /**
+     * This operation retrieves the list of communication statuses that are
+     * taken into account to determine the triggerValue of the
+     * StatusCondition. This operation returns the statuses that were
+     * explicitly set on the last call to
+     * {@link #setEnabledStatuses(Collection)} or, if it was never called,
+     * the default list.
+     * 
+     * @see     #setEnabledStatuses(Collection)
+     */
     public Collection<Class<? extends Status<?, ?>>> getEnabledStatuses(
             Collection<Class<? extends Status<?, ?>>> statuses);
 
     /**
+     * This operation defines the list of communication statuses that are
+     * taken into account to determine the triggerValue of the
+     * StatusCondition. This operation may change the triggerValue of the
+     * StatusCondition.
+     * 
+     * {@link WaitSet} objects behavior depend on the changes of the
+     * triggerValue of their attached conditions. Therefore, any WaitSet to
+     * which the StatusCondition is attached is potentially affected by this
+     * operation.
+     * 
+     * If this function is not invoked, the default list of enabled statuses
+     * includes all the statuses.
+     *
      * @param statuses  For which status changes the condition should trigger.
      *                  A null collection signifies all status changes.
+     * 
+     * @see     #getEnabledStatuses(Collection)
      */
     public void setEnabledStatuses(
             Collection<Class<? extends Status<?, ?>>> statuses);
 
+    /**
+     * @return  the Entity associated with the StatusCondition. Note that
+     *          there is exactly one Entity associated with each
+     *          StatusCondition.
+     */
     public ENTITY getEntity();
 }
Index: ftf_vote_01/srcJava/org/omg/dds/sub/DataReaderListener.java
===================================================================
--- ftf_vote_01/srcJava/org/omg/dds/sub/DataReaderListener.java	(revision 139)
+++ ftf_vote_01/srcJava/org/omg/dds/sub/DataReaderListener.java	(working copy)
@@ -20,6 +20,7 @@
 
 import java.util.EventListener;
 
+import org.omg.dds.core.Entity;
 import org.omg.dds.core.status.DataAvailableStatus;
 import org.omg.dds.core.status.LivelinessChangedStatus;
 import org.omg.dds.core.status.RequestedDeadlineMissedStatus;
@@ -27,8 +28,23 @@
 import org.omg.dds.core.status.SampleLostStatus;
 import org.omg.dds.core.status.SampleRejectedStatus;
 import org.omg.dds.core.status.SubscriptionMatchedStatus;
+import org.omg.dds.pub.DataWriter;
 
 
+/**
+ * Since a {@link DataReader} is a kind of {@link Entity}, it has the ability
+ * to have an associated listener. In this case, the associated listener must
+ * be of concrete type DataReaderListener.
+ * 
+ * The operation {@link #onSubscriptionMatched(SubscriptionMatchedStatus)} is
+ * intended to inform the application of the discovery of {@link DataWriter}
+ * entities that match the DataReader. Some implementations of the service
+ * may not propagate this information. In that case the DDS specification
+ * does not require this listener operation to be called.
+ * 
+ * @param <TYPE>    The concrete type of the data that can be delivered by
+ *                  the {@link DataReader}.
+ */
 public interface DataReaderListener<TYPE> extends EventListener {
     public void onRequestedDeadlineMissed(
             RequestedDeadlineMissedStatus<TYPE> status);
Index: ftf_vote_01/srcJava/org/omg/dds/sub/Subscriber.java
===================================================================
--- ftf_vote_01/srcJava/org/omg/dds/sub/Subscriber.java	(revision 139)
+++ ftf_vote_01/srcJava/org/omg/dds/sub/Subscriber.java	(working copy)
@@ -19,10 +19,18 @@
 package org.omg.dds.sub;
 
 import java.util.Collection;
+import java.util.List;
+import java.util.Set;
 
 import org.omg.dds.core.DomainEntity;
+import org.omg.dds.core.InconsistentPolicyException;
+import org.omg.dds.core.NotEnabledException;
+import org.omg.dds.core.PreconditionNotMetException;
+import org.omg.dds.core.policy.PresentationQosPolicy;
+import org.omg.dds.core.status.DataAvailableStatus;
 import org.omg.dds.core.status.Status;
 import org.omg.dds.domain.DomainParticipant;
+import org.omg.dds.topic.Topic;
 import org.omg.dds.topic.TopicDescription;
 import org.omg.dds.topic.TopicQos;
 import org.omg.dds.type.builtin.BytesDataReader;
@@ -33,6 +41,26 @@
 import org.omg.dds.type.builtin.StringDataReader;
 
 
+/**
+ * A Subscriber is the object responsible for the actual reception of the
+ * data resulting from its subscriptions.
+ * 
+ * A Subscriber acts on the behalf of one or several {@link DataReader}
+ * objects that are related to it. When it receives data (from the other
+ * parts of the system), it builds the list of concerned DataReader objects,
+ * and then indicates to the application that data is available, through its
+ * listener or by enabling related conditions. The application can access the
+ * list of concerned DataReader objects through the operation
+ * {@link #getDataReaders(Collection)} and then access the data available
+ * through operations on the DataReaders.
+ * 
+ * All operations except for the inherited operations
+ * {@link #setQos(SubscriberQos)}, {@link #getQos()},
+ * {@link #setListener(SubscriberListener)}, {@link #getListener()},
+ * {@link #enable()}, {@link #getStatusCondition()}, and
+ * {@link #createDataReader(TopicDescription)} may fail with the exception
+ * {@link NotEnabledException}.
+ */
 public interface Subscriber
 extends DomainEntity<Subscriber,
                      DomainParticipant,
@@ -41,15 +69,60 @@
 {
     // --- Create (any) DataReader: ------------------------------------------
 
+    /**
+     * This operation creates a {@link DataReader}. The returned DataReader
+     * will be attached and belong to the Subscriber.
+     * 
+     * Note that a common application pattern to construct the QoS for the
+     * DataReader is to:
+     * 
+     * <ul>
+     *     <li>Retrieve the QoS policies on the associated {@link Topic} by
+     *         means of {@link Topic#getQos()}.</li>
+     *     <li>Retrieve the default DataReader QoS by means of
+     *         {@link #getDefaultDataReaderQos()}.
+     *     <li>Combine those two QoS policies and selectively modify policies
+     *         as desired.</li>
+     *     <li>Use the resulting QoS policies to construct the DataReader.
+     * </ul>
+     * 
+     * The {@link TopicDescription} passed to this operation must have been
+     * created from the same {@link DomainParticipant} that was used to
+     * create this Subscriber. If the TopicDescription was created from a
+     * different DomainParticipant, the operation will fail.
+     * 
+     * @see     #createDataReader(TopicDescription, DataReaderQos, DataReaderListener, Collection)
+     */
     public <TYPE> DataReader<TYPE> createDataReader(
             TopicDescription<TYPE> topic);
 
     /**
-     * Create a new data reader.
+     * This operation creates a {@link DataReader}. The returned DataReader
+     * will be attached and belong to the Subscriber.
      * 
+     * Note that a common application pattern to construct the QoS for the
+     * DataReader is to:
+     * 
+     * <ul>
+     *     <li>Retrieve the QoS policies on the associated {@link Topic} by
+     *         means of {@link Topic#getQos()}.</li>
+     *     <li>Retrieve the default DataReader QoS by means of
+     *         {@link #getDefaultDataReaderQos()}.
+     *     <li>Combine those two QoS policies and selectively modify policies
+     *         as desired.</li>
+     *     <li>Use the resulting QoS policies to construct the DataReader.
+     * </ul>
+     * 
+     * The {@link TopicDescription} passed to this operation must have been
+     * created from the same {@link DomainParticipant} that was used to
+     * create this Subscriber. If the TopicDescription was created from a
+     * different DomainParticipant, the operation will fail.
+     * 
      * @param statuses  Of which status changes the listener should be
      *                  notified. A null collection signifies all status
      *                  changes.
+     *
+     * @see     #createDataReader(TopicDescription)
      */
     public <TYPE> DataReader<TYPE> createDataReader(
             TopicDescription<TYPE> topic,
@@ -63,6 +136,8 @@
      * @param statuses  Of which status changes the listener should be
      *                  notified. A null collection signifies all status
      *                  changes.
+     *
+     * @see     #createDataReader(TopicDescription, DataReaderQos, DataReaderListener, Collection)
      */
     public <TYPE> DataReader<TYPE> createDataReader(
             TopicDescription<TYPE> topic,
@@ -74,15 +149,22 @@
 
     // --- Create DataReader of built-in bytes type: -------------------------
 
+    /**
+     * Create a new data reader for this built-in type.
+     * 
+     * @see     #createDataReader(TopicDescription)
+     */
     public BytesDataReader createBytesDataReader(
             TopicDescription<byte[]> topic);
 
     /**
-     * Create a new data reader.
+     * Create a new data reader for this built-in type.
      * 
      * @param statuses  Of which status changes the listener should be
      *                  notified. A null collection signifies all status
      *                  changes.
+     * 
+     * @see     #createDataReader(TopicDescription, DataReaderQos, DataReaderListener, Collection)
      */
     public BytesDataReader createBytesDataReader(
             TopicDescription<byte[]> topic,
@@ -91,11 +173,13 @@
             Collection<Class<? extends Status<?, ?>>> statuses);
 
     /**
-     * Create a new data reader.
+     * Create a new data reader for this built-in type.
      * 
      * @param statuses  Of which status changes the listener should be
      *                  notified. A null collection signifies all status
      *                  changes.
+     * 
+     * @see     #createDataReader(TopicDescription, DataReaderQos, DataReaderListener, Collection)
      */
     public BytesDataReader createBytesDataReader(
             TopicDescription<byte[]> topic,
@@ -107,15 +191,22 @@
 
     // --- Create DataReader of built-in KeyedBytes type: --------------------
 
+    /**
+     * Create a new data reader for this built-in type.
+     * 
+     * @see     #createDataReader(TopicDescription)
+     */
     public KeyedBytesDataReader createKeyedBytesDataReader(
             TopicDescription<KeyedBytes> topic);
 
     /**
-     * Create a new data reader.
+     * Create a new data reader for this built-in type.
      * 
      * @param statuses  Of which status changes the listener should be
      *                  notified. A null collection signifies all status
      *                  changes.
+     * 
+     * @see     #createDataReader(TopicDescription, DataReaderQos, DataReaderListener, Collection)
      */
     public KeyedBytesDataReader createKeyedBytesDataReader(
             TopicDescription<KeyedBytes> topic,
@@ -124,11 +215,13 @@
             Collection<Class<? extends Status<?, ?>>> statuses);
 
     /**
-     * Create a new data reader.
+     * Create a new data reader for this built-in type.
      * 
      * @param statuses  Of which status changes the listener should be
      *                  notified. A null collection signifies all status
      *                  changes.
+     * 
+     * @see     #createDataReader(TopicDescription, DataReaderQos, DataReaderListener, Collection)
      */
     public KeyedBytesDataReader createKeyedBytesDataReader(
             TopicDescription<KeyedBytes> topic,
@@ -140,15 +233,22 @@
 
     // --- Create DataReader of built-in string type: ------------------------
 
+    /**
+     * Create a new data reader for this built-in type.
+     * 
+     * @see     #createDataReader(TopicDescription)
+     */
     public StringDataReader createStringDataReader(
             TopicDescription<String> topic);
 
     /**
-     * Create a new data reader.
+     * Create a new data reader for this built-in type.
      * 
      * @param statuses  Of which status changes the listener should be
      *                  notified. A null collection signifies all status
      *                  changes.
+     * 
+     * @see     #createDataReader(TopicDescription, DataReaderQos, DataReaderListener, Collection)
      */
     public StringDataReader createStringDataReader(
             TopicDescription<String> topic,
@@ -157,11 +257,13 @@
             Collection<Class<? extends Status<?, ?>>> statuses);
 
     /**
-     * Create a new data reader.
+     * Create a new data reader for this built-in type.
      * 
      * @param statuses  Of which status changes the listener should be
      *                  notified. A null collection signifies all status
      *                  changes.
+     * 
+     * @see     #createDataReader(TopicDescription, DataReaderQos, DataReaderListener, Collection)
      */
     public StringDataReader createStringDataReader(
             TopicDescription<String> topic,
@@ -173,15 +275,22 @@
 
     // --- Create DataReader of built-in KeyedString type: -------------------
 
+    /**
+     * Create a new data reader for this built-in type.
+     * 
+     * @see     #createDataReader(TopicDescription)
+     */
     public KeyedStringDataReader createKeyedStringDataReader(
             TopicDescription<KeyedString> topic);
 
     /**
-     * Create a new data reader.
+     * Create a new data reader for this built-in type.
      * 
      * @param statuses  Of which status changes the listener should be
      *                  notified. A null collection signifies all status
      *                  changes.
+     * 
+     * @see     #createDataReader(TopicDescription, DataReaderQos, DataReaderListener, Collection)
      */
     public KeyedStringDataReader createKeyedStringDataReader(
             TopicDescription<KeyedString> topic,
@@ -190,11 +299,13 @@
             Collection<Class<? extends Status<?, ?>>> statuses);
 
     /**
-     * Create a new data reader.
+     * Create a new data reader for this built-in type.
      * 
      * @param statuses  Of which status changes the listener should be
      *                  notified. A null collection signifies all status
      *                  changes.
+     * 
+     * @see     #createDataReader(TopicDescription, DataReaderQos, DataReaderListener, Collection)
      */
     public KeyedStringDataReader createKeyedStringDataReader(
             TopicDescription<KeyedString> topic,
@@ -206,42 +317,324 @@
 
     // --- Lookup operations: ------------------------------------------------
 
+    /**
+     * This operation retrieves a previously-created DataReader belonging to
+     * the Subscriber that is attached to a {@link Topic} with a matching
+     * topicName. If no such DataReader exists, the operation will return
+     * null.
+     * 
+     * If multiple DataReaders attached to the Subscriber satisfy this
+     * condition, then the operation will return one of them. It is not
+     * specified which one.
+     * 
+     * The use of this operation on the built-in Subscriber allows access to
+     * the built-in DataReader entities for the built-in topics.
+     * 
+     * @see     DomainParticipant#getBuiltinSubscriber()
+     */
     public <TYPE> DataReader<TYPE> lookupDataReader(String topicName);
+
+    /**
+     * This operation retrieves a previously-created DataReader belonging to
+     * the Subscriber that is attached to the given {@link TopicDescription}.
+     * If no such DataReader exists, the operation will return null.
+     * 
+     * If multiple DataReaders attached to the Subscriber satisfy this
+     * condition, then the operation will return one of them. It is not
+     * specified which one.
+     * 
+     * The use of this operation on the built-in Subscriber allows access to
+     * the built-in DataReader entities for the built-in topics.
+     * 
+     * @see     DomainParticipant#getBuiltinSubscriber()
+     */
     public <TYPE> DataReader<TYPE> lookupDataReader(
             TopicDescription<TYPE> topicName);
 
+    /**
+     * Look up a DataReader for the given built-in data type.
+     * 
+     * @throws  ClassCastException      if a DataReader exists on the given
+     *          TopicDescription but is of a different type.
+     *
+     * @see     #lookupDataReader(TopicDescription)
+     */
     public BytesDataReader lookupBytesDataReader(
-            TopicDescription<byte[]> topicName);
+            TopicDescription<byte[]> topic);
+
+    /**
+     * Look up a DataReader for the given built-in data type.
+     * 
+     * @throws  ClassCastException      if a DataReader exists on the given
+     *          TopicDescription but is of a different type.
+     *
+     * @see     #lookupDataReader(TopicDescription)
+     */
     public KeyedBytesDataReader lookupKeyedBytesDataReader(
-            TopicDescription<KeyedBytes> topicName);
+            TopicDescription<KeyedBytes> topic);
+
+    /**
+     * Look up a DataReader for the given built-in data type.
+     * 
+     * @throws  ClassCastException      if a DataReader exists on the given
+     *          TopicDescription but is of a different type.
+     *
+     * @see     #lookupDataReader(TopicDescription)
+     */
     public StringDataReader lookupStringDataReader(
-            TopicDescription<String> topicName);
+            TopicDescription<String> topic);
+
+    /**
+     * Look up a DataReader for the given built-in data type.
+     * 
+     * @throws  ClassCastException      if a DataReader exists on the given
+     *          TopicDescription but is of a different type.
+     *
+     * @see     #lookupDataReader(TopicDescription)
+     */
     public KeyedStringDataReader lookupKeyedStringDataReader(
-            TopicDescription<KeyedString> topicName);
+            TopicDescription<KeyedString> topic);
 
 
     // --- Other operations: -------------------------------------------------
 
+    /**
+     * This operation closes all the entities that were created by means of
+     * the "create" operations on the Subscriber. That is, it closes all
+     * contained {@link DataReader} objects. This pattern is applied
+     * recursively. In this manner the operation on the Subscriber will end
+     * up closing all the entities recursively contained in the Subscriber,
+     * that is also the {@link QueryCondition} and {@link ReadCondition}
+     * objects belonging to the contained DataReaders.
+     * 
+     * @throws  PreconditionNotMetException     if any of the contained
+     *          entities is in a state where it cannot be closed. This will
+     *          occur, for example, if a contained DataReader cannot be
+     *          closed because the application has called a
+     *          {@link DataReader#read()} or {@link DataReader#take()}
+     *          operation and has not called the corresponding
+     *          {@link Sample.Iterator#returnLoan()} operation to return the
+     *          loaned samples.
+     */
     public void closeContainedEntities();
 
+    /**
+     * This operation is equivalent to calling
+     * {@link #getDataReaders(Collection, Collection, Collection, Collection)}
+     * with any sample state
+     * ({@link SampleState#anySampleStateSet(org.omg.dds.core.Bootstrap)}),
+     * any view state
+     * ({@link ViewState#anyViewStateSet(org.omg.dds.core.Bootstrap)}), and
+     * any instance state
+     * ({@link InstanceState#anyInstanceStateSet(org.omg.dds.core.Bootstrap)}).
+     * 
+     * @param   readers         a container, into which this method will place
+     *          its result.
+     * 
+     * @return  readers, as a convenience to facilitate chaining.
+     * 
+     * @throws  PreconditionNotMetException     if the Subscriber has
+     *          {@link PresentationQosPolicy#getAccessScope()} set to
+     *          {@link PresentationQosPolicy.AccessScopeKind#GROUP} and this
+     *          operation is not invoked inside a {@link #beginAccess()}/
+     *          {@link #endAccess()} block.
+     * 
+     * @see     #getDataReaders(Collection, Collection, Collection, Collection)
+     * @see     #beginAccess()
+     * @see     #endAccess()
+     * @see     PresentationQosPolicy
+     */
     public Collection<DataReader<?>> getDataReaders(
             Collection<DataReader<?>> readers);
+
+    /**
+     * This operation allows the application to access the {@link DataReader}
+     * objects that contain samples with the specified sampleStates,
+     * viewStates, and instanceStates.
+     * 
+     * If the {@link PresentationQosPolicy} of the Subscriber has
+     * {@link PresentationQosPolicy#getAccessScope()} set to
+     * {@link PresentationQosPolicy.AccessScopeKind#GROUP}, this operation
+     * should only be invoked inside a {@link #beginAccess()}/
+     * {@link #endAccess()} block. Otherwise it will fail with
+     * {@link PreconditionNotMetException}.
+     * 
+     * Depending on the setting of the {@link PresentationQosPolicy}, the
+     * returned collection of DataReader objects may be a 'set' containing
+     * each DataReader at most once in no specified order, or a 'list'
+     * containing each DataReader one or more times in a specific order.
+     * (This refers to the semantics of the collection; the concrete type of
+     * the collection may or may not implement {@link Set} or {@link List}).
+     * 
+     * <ol>
+     *     <li>If {@link PresentationQosPolicy#getAccessScope()} is
+     *         {@link PresentationQosPolicy.AccessScopeKind#INSTANCE} or
+     *         {@link PresentationQosPolicy.AccessScopeKind#TOPIC}, the
+     *         returned collection is a 'set'.</li>
+     *     <li>If {@link PresentationQosPolicy#getAccessScope()} is
+     *         {@link PresentationQosPolicy.AccessScopeKind#GROUP} and
+     *         {@link PresentationQosPolicy#isOrderedAccess()} is true, then
+     *         the returned collection is a 'list'.</li>
+     * </ol>
+     * 
+     * This difference is due to the fact that, in the second situation it
+     * is required to access samples belonging to different DataReader
+     * objects in a particular order. In this case, the application should
+     * process each DataReader in the same order it appears in the 'list' and
+     * read or take exactly one sample from each DataReader.
+     * 
+     * @param   readers         a container, into which this method will place
+     *          its result.
+     * @param   sampleStates    a DataReader will only be placed into the
+     *          readers collection if it has data available with one of these
+     *          sample states.
+     * @param viewStates        a DataReader will only be placed into the
+     *          readers collection if it has data available with one of these
+     *          view states.
+     * @param instanceStates    a DataReader will only be placed into the
+     *          readers collection if it has data available with one of these
+     *          instance states.
+     * 
+     * @return  readers, as a convenience to facilitate chaining.
+     * 
+     * @throws  PreconditionNotMetException     if the Subscriber has
+     *          {@link PresentationQosPolicy#getAccessScope()} set to
+     *          {@link PresentationQosPolicy.AccessScopeKind#GROUP} and this
+     *          operation is not invoked inside a {@link #beginAccess()}/
+     *          {@link #endAccess()} block.
+     * 
+     * @see     #getDataReaders(Collection)
+     * @see     #beginAccess()
+     * @see     #endAccess()
+     * @see     PresentationQosPolicy
+     */
     public Collection<DataReader<?>> getDataReaders(
             Collection<DataReader<?>> readers,
             Collection<SampleState> sampleStates,
             Collection<ViewState> viewStates,
             Collection<InstanceState> instanceStates);
 
+    /**
+     * This operation invokes the operation
+     * {@link DataReaderListener#onDataAvailable(org.omg.dds.core.status.DataAvailableStatus)}
+     * on the DataReaderListener objects attached to contained DataReader
+     * entities with a {@link DataAvailableStatus} that is considered
+     * changed.
+     * 
+     * This operation is typically invoked from
+     * {@link SubscriberListener#onDataOnReaders(org.omg.dds.core.status.DataOnReadersStatus)}.
+     * That way the SubscriberListener can delegate to the DataReaderListener
+     * objects the handling of the data.
+     */
     public void notifyDataReaders();
 
+    /**
+     * This operation indicates that the application is about to access the
+     * data samples in any of the {@link DataReader} objects attached to the
+     * Subscriber.
+     * 
+     * The application is required to use this operation only if the
+     * {@link PresentationQosPolicy} of the Subscriber has 
+     * {@link PresentationQosPolicy#getAccessScope()} equal to
+     * {@link PresentationQosPolicy.AccessScopeKind#GROUP}.
+     * 
+     * In the aforementioned case, the operation must be called prior to
+     * calling any of the sample-accessing operations, namely:
+     * {@link #getDataReaders(Collection)}, {@link DataReader#read()},
+     * {@link DataReader#take()}, or their overloads. Otherwise the
+     * sample-accessing operations will fail with
+     * {@link PreconditionNotMetException}. Once the application has
+     * finished accessing the data samples it must call {@link #endAccess()}.
+     * 
+     * It is not required for the application to call {@link #beginAccess()}/
+     * {@link #endAccess()} if the {@link PresentationQosPolicy} has the
+     * access scope set to something other than 'GROUP'. Calling these
+     * methods in this case is not considered an error and has no effect.
+     * 
+     * The calls to {@link #beginAccess()}/{@link #endAccess()} may be
+     * nested. In that case, the application must call {@link #endAccess()}
+     * as many times as it called beginAccess.
+     * 
+     * @see     #endAccess()
+     * @see     PresentationQosPolicy
+     */
     public void beginAccess();
+
+    /**
+     * Indicates that the application has finished accessing the data samples
+     * in {@link DataReader} objects managed by the Subscriber.
+     * 
+     * This operation must be used to 'close' a corresponding
+     * {@link #beginAccess()}.
+     * 
+     * After calling endAccess the application should no longer access any of
+     * the Sample (including corresponding data) elements returned from the
+     * sample-accessing operations.
+     * 
+     * @throws  PreconditionNotMetException     if this call does not close a
+     *          previous call to {@link #beginAccess()}.
+     * 
+     * @see     #beginAccess()
+     */
     public void endAccess();
 
+    /**
+     * This operation retrieves the default value of the DataReader QoS, that
+     * is, the QoS policies which will be used for newly created
+     * {@link DataReader} entities in the case where the QoS policies are
+     * defaulted in the {@link #createDataReader(TopicDescription)}
+     * operation.
+     * 
+     * The values retrieved will match the set of values specified on the
+     * last successful call to
+     * {@link #setDefaultDataReaderQos(DataReaderQos)}, or else, if the call
+     * was never made, the default values identified by the DDS
+     * specification.
+     * 
+     * @see     #setDefaultDataReaderQos(DataReaderQos)
+     */
     public DataReaderQos getDefaultDataReaderQos();
+
+    /**
+     * This operation sets a default value of the DataReader QoS policies,
+     * which will be used for newly created {@link DataReader} entities in
+     * the case where the QoS policies are defaulted in the
+     * {@link #createDataReader(TopicDescription)} operation.
+     * 
+     * @throws  InconsistentPolicyException     if the resulting policies are
+     *          not self consistent. In this case, this operation will have
+     *          no effect.
+     *
+     * @see     #getDefaultDataReaderQos()
+     */
     public void setDefaultDataReaderQos(DataReaderQos qos);
+
+    /**
+     * @see     #setDefaultDataReaderQos(DataReaderQos)
+     */
     public void setDefaultDataReaderQos(
             String qosLibraryName,
             String qosProfileName);
 
+    /**
+     * This operation copies the policies in the {@link TopicQos} to the
+     * corresponding policies in the {@link DataReaderQos} (replacing values
+     * in the latter, if present).
+     * 
+     * This is a "convenience" operation most useful in combination with the
+     * operations {@link #getDefaultDataReaderQos()} and
+     * {@link Topic#getQos()}. The operation can be used to merge the
+     * DataReader default QoS policies with the corresponding ones on the
+     * Topic. The resulting QoS can then be used to create a new DataReader
+     * or set its QoS.
+     * 
+     * This operation does not check the resulting QoS for consistency. This
+     * is because the 'merged' QoS may not be the final one, as the
+     * application can still modify some policies prior to applying the
+     * policies to the DataReader.
+     * 
+     * @param   dst     the QoS, the policies of which will be overwritten.
+     * @param   src     the source for the new policies to be copied.
+     */
     public void copyFromTopicQos(DataReaderQos dst, TopicQos src);
 }
Index: ftf_vote_01/srcJava/org/omg/dds/sub/SubscriberListener.java
===================================================================
--- ftf_vote_01/srcJava/org/omg/dds/sub/SubscriberListener.java	(revision 139)
+++ ftf_vote_01/srcJava/org/omg/dds/sub/SubscriberListener.java	(working copy)
@@ -20,6 +20,7 @@
 
 import java.util.EventListener;
 
+import org.omg.dds.core.Entity;
 import org.omg.dds.core.status.DataAvailableStatus;
 import org.omg.dds.core.status.DataOnReadersStatus;
 import org.omg.dds.core.status.LivelinessChangedStatus;
@@ -30,6 +31,11 @@
 import org.omg.dds.core.status.SubscriptionMatchedStatus;
 
 
+/**
+ * Since a {@link Subscriber} is a kind of {@link Entity}, it has the ability
+ * to have an associated listener. In this case, the associated listener must
+ * be of concrete type SubscriberListener.
+ */
 public interface SubscriberListener extends EventListener {
     public void onRequestedDeadlineMissed(
             RequestedDeadlineMissedStatus<?> status);
Index: ftf_vote_01/srcJava/org/omg/dds/sub/QueryCondition.java
===================================================================
--- ftf_vote_01/srcJava/org/omg/dds/sub/QueryCondition.java	(revision 139)
+++ ftf_vote_01/srcJava/org/omg/dds/sub/QueryCondition.java	(working copy)
@@ -21,13 +21,57 @@
 import java.util.List;
 
 
+/**
+ * QueryCondition objects are specialized {@link ReadCondition} objects that
+ * allow the application to also specify a filter on the locally available
+ * data.
+ * 
+ * The query (queryExpression) is similar to an SQL WHERE clause can be
+ * parameterized by arguments that are dynamically changeable by the
+ * {@link #setQueryParameters(List)} operation.
+ * 
+ * This feature is optional. In the cases where it is not supported, the
+ * {@link DataReader#createQueryCondition(String, List)} will return null.
+ * 
+ * The triggerValue of a QueryCondition is like that of a ReadCondition with
+ * the additional condition that the data associated with at least one sample
+ * must be such that the queryExpression evaluates to true.
+ * 
+ * @param <TYPE>    The concrete type of the data that can be read using the
+ *                  the {@link DataReader} that created this QueryCondition.
+ */
 public interface QueryCondition<TYPE> extends ReadCondition<TYPE> {
+    /**
+     * This operation returns the queryExpression associated with the
+     * QueryCondition. That is, the expression specified when the
+     * QueryCondition was created.
+     * 
+     * @see     #getQueryParameters()
+     */
     public String getQueryExpression();
 
     /**
+     * This operation returns the queryParameters associated with the
+     * QueryCondition. That is, the parameters specified on the last
+     * successful call to {@link #setQueryParameters(List)}, or if
+     * {@link #setQueryParameters(List)} was never called, the arguments
+     * specified when the QueryCondition was created.
+     * 
      * @return  an unmodifiable list of the current query parameters.
+     * 
+     * @see     #setQueryParameters(List)
+     * @see     #getQueryExpression()
      */
     public List<String> getQueryParameters();
 
+    /**
+     * This operation changes the queryParameters associated with the
+     * QueryCondition.
+     * 
+     * @param   queryParameters a container, into which this method will
+     *          place its result.
+     * 
+     * @see     #getQueryParameters()
+     */
     public void setQueryParameters(List<String> queryParameters);
 }
Index: ftf_vote_01/srcJava/org/omg/dds/sub/Sample.java
===================================================================
--- ftf_vote_01/srcJava/org/omg/dds/sub/Sample.java	(revision 139)
+++ ftf_vote_01/srcJava/org/omg/dds/sub/Sample.java	(working copy)
@@ -20,11 +20,102 @@
 
 import java.util.ListIterator;
 
+import org.omg.dds.core.InstanceHandle;
 import org.omg.dds.core.modifiable.ModifiableInstanceHandle;
 import org.omg.dds.core.modifiable.ModifiableTime;
 import org.omg.dds.core.modifiable.ModifiableValue;
+import org.omg.dds.core.policy.OwnershipQosPolicy;
+import org.omg.dds.pub.DataWriter;
 
 
+/**
+ * A Sample represents an atom of data information (i.e., one value for one
+ * instance) as returned by a {@link DataReader}'s read or take operations.
+ * It consists of two parts: the Data ({@link #getData()}) and the "Sample
+ * Info" (the remainder of the methods defined by this interface).
+ * 
+ * <b>Interpretation of the Sample Info</b>
+ * 
+ * In addition to the data value itself, the Sample contains information
+ * pertaining to it:
+ * 
+ * <ul>
+ *      <li>The sampleState ({@link #getSampleState()}) of the Data value
+ *          (i.e., if the sample has already been {@link SampleState#READ} or
+ *          {@link SampleState#NOT_READ} by that same {@link DataReader}).
+ *          </li>
+ *      <li>The viewState ({@link #getViewState()}) of the related instance
+ *          (i.e., if the current generation of the instance is
+ *          {@link ViewState#NEW} or {@link ViewState#NOT_NEW} for that
+ *          DataReader).</li>
+ *      <li>The instanceState ({@link #getInstanceState()}) of the related
+ *          instance (i.e., if the instance is {@link InstanceState#ALIVE},
+ *          {@link InstanceState#NOT_ALIVE_DISPOSED}, or
+ *          {@link InstanceState#NOT_ALIVE_NO_WRITERS}).</li>
+ *      <li>The "valid data" flag, corresponding to whether {@link #getData()}
+ *          return a non-null value. Some samples do not contain data, instead
+ *          indicating only a change on the instanceState of the corresponding
+ *          instance.</li>
+ *      <li>The values of disposedGenerationCount
+ *          ({@link #getDisposedGenerationCount()}) and
+ *          noWritersGenerationCount ({@link #getNoWritersGenerationCount()})
+ *          for the related instance at the time the sample was received.
+ *          These counters indicate the number of times the instance had
+ *          become ALIVE (with instanceState = {@link InstanceState#ALIVE})
+ *          at the time the sample was received.</li>
+ *      <li>The sampleRank ({@link #getSampleRank()}) and generationRank
+ *          ({@link #getGenerationRank()}) of the sample within the returned
+ *          sequence. These ranks provide a preview of the samples that
+ *          follow within the sequence returned by the
+ *          {@link DataReader#read()} or {@link DataReader#take()}
+ *          operations.</li>
+ *      <li>The absoluteGenerationRank ({@link #getAbsoluteGenerationRank()})
+ *          of the sample within the DataReader. This rank provides a preview
+ *          of what is available within the DataReader.</li>
+ *      <li>The sourceTimestamp ({@link #getSourceTimestamp()}) of the sample.
+ *          This is the time stamp provided by the {@link DataWriter} at the
+ *          time the sample was produced.</li>
+ *      <li>The instanceHandle ({@link #getInstanceHandle()}) that identifies
+ *          locally the corresponding instance.</li>
+ *      <li>The publicationHandle ({@link #getPublicationHandle()}) that
+ *          identifies locally the {@link DataWriter} that modified the
+ *          instance. The publicationHandle is the same {@link InstanceHandle}
+ *          that is returned by the operation
+ *          {@link DataReader#getMatchedPublications(java.util.Collection)}
+ *          on the DataReader and can also be used as a parameter to the
+ *          operation
+ *          {@link DataReader#getMatchedPublicationData(org.omg.dds.topic.PublicationBuiltinTopicData, InstanceHandle)}.</li>
+ * </ul>
+ * 
+ * <b>Interpretation of the Counters and Ranks</b>
+ * 
+ * A Sample provides several counters and ranks: the disposedGenerationCount
+ * ({@link #getDisposedGenerationCount()}), noWritersGenerationCount
+ * ({@link #getNoWritersGenerationCount()}), sampleRank
+ * ({@link #getSampleRank()}), generationRank ({@link #getGenerationRank()}),
+ * and absoluteGenerationRank ({@link #getAbsoluteGenerationRank()}). These
+ * counters and ranks allow the application to distinguish samples belonging
+ * to different 'generations' of the instance. Note that it is possible for
+ * an instance to transition from not-alive to alive (and back) several times
+ * before the application accesses the data by means of
+ * {@link DataReader#read()} or {@link DataReader#take()}. In this case the
+ * returned collection may contain samples that cross generations (i.e., some
+ * samples were received before the instance became not-alive, others after
+ * the instance reappeared again). Using the information in the Sample the
+ * application can anticipate what other information regarding the same
+ * instance appears in the returned collection as well as in the
+ * infrastructure and thus make appropriate decisions. For example, an
+ * application desiring to only consider the most current sample for each
+ * instance would only look at samples with sampleRank == 0. Similarly an
+ * application desiring to only consider samples that correspond to the
+ * latest generation in the collection will only look at samples with
+ * generationRank == 0. An application desiring only samples pertaining to
+ * the latest generation available will ignore samples for which
+ * absoluteGenerationRank != 0. Other application-defined criteria may also
+ * be used.
+ * 
+ * @param <TYPE>    The concrete type of the data encapsulated by this Sample.
+ */
 public interface Sample<TYPE>
 extends ModifiableValue<Sample<TYPE>, Sample<TYPE>> {
     // -----------------------------------------------------------------------
@@ -32,7 +123,31 @@
     // -----------------------------------------------------------------------
 
     // --- Sample data: ------------------------------------------------------
+
     /**
+     * Get the data associated with this Sample, if any.
+     * 
+     * Normally each Sample contains both meta-data ("Sample Info") and some
+     * data. However there are situations where a Sample contains only the
+     * Sample Info and does not have any associated data. This occurs when
+     * the Service notifies the application of a change of state for an
+     * instance that was caused by some internal mechanism (such as a
+     * timeout) for which there is no associated data. An example of this
+     * situation is when the Service detects that an instance has no writers
+     * and changes the corresponding instanceState to
+     * {@link InstanceState#NOT_ALIVE_NO_WRITERS}.
+     * 
+     * The actual set of scenarios under which the middleware returns Samples
+     * containing no data is implementation dependent. The application can
+     * distinguish whether a particular Sample has data by examining the
+     * value returned by this method. If the result is not null, then the
+     * Sample contains valid data. If it is null, the Sample contains no
+     * data.
+     * 
+     * To ensure correctness and portability, the application must check for
+     * a null result from this method prior to using it. If the data is null,
+     * the application should access only the Sample Info.
+     * 
      * @return  the data associated with this sample. This method will return
      *          null if this sample contains no valid data.
      */
@@ -40,18 +155,104 @@
 
 
     // --- Sample meta-data: -------------------------------------------------
+
     /**
-     * @return the sampleState
+     * For each sample received, the middleware internally maintains a
+     * sampleState relative to each {@link DataReader}. The sampleState can
+     * either be {@link SampleState#READ} or {@link SampleState#NOT_READ}.
+     * 
+     * <ul>
+     *     <li>READ indicates that the DataReader has already accessed that
+     *         sample by means of {@link DataReader#read()}. (Had the sample
+     *         been accessed by {@link DataReader#take()}, it would no longer
+     *         be available to the DataReader.)</li>
+     *     <li>NOT_READ indicates that the DataReader has not accessed that
+     *         sample before.</li>
+     * </ul>
+     * 
+     * The sampleState will, in general, be different for each sample in the
+     * collection returned by {@link DataReader#read()} or
+     * {@link DataReader#take()}.
      */
     public SampleState getSampleState();
 
     /**
-     * @return the viewState
+     * For each instance (identified by the key), the middleware internally
+     * maintains a viewState relative to each {@link DataReader}. The
+     * viewState can either be {@link ViewState#NEW} or
+     * {@link ViewState#NOT_NEW}.
+     * 
+     * <ul>
+     *     <li>NEW indicates that either this is the first time that the
+     *         DataReader has ever accessed samples of that instance, or else
+     *         that the DataReader has accessed previous samples of the
+     *         instance, but the instance has since been reborn (i.e., become
+     *         not-alive and then alive again). These two cases are
+     *         distinguished by examining the disposedGenerationCount and the
+     *         noWritersGenerationCount.</li>
+     *     <li>NOT_NEW indicates that the DataReader has already accessed
+     *         samples of the same instance and that the instance has not
+     *         been reborn since.</li>
+     * </ul>
+     * 
+     * The viewState available in the Sample is a snapshot of the viewState
+     * of the instance relative to the DataReader used to access the samples
+     * at the time the collection was obtained (i.e., at the time
+     * {@link DataReader#read()} or {@link DataReader#take()} was called).
+     * The viewState is therefore the same for all samples in the returned
+     * collection that refer to the same instance.
+     * 
+     * 
+     * 
+     * @see     #getDisposedGenerationCount()
+     * @see     #getNoWritersGenerationCount()
      */
     public ViewState getViewState();
 
     /**
-     * @return the instanceState
+     * For each instance the middleware internally maintains an
+     * instanceState. The instanceState can be {@link InstanceState#ALIVE},
+     * {@link InstanceState#NOT_ALIVE_DISPOSED}, or
+     * {@link InstanceState#NOT_ALIVE_NO_WRITERS}.
+     * 
+     * <ul>
+     *     <li>ALIVE indicates that (a) samples have been received for the
+     *         instance, (b) there are live {@link DataWriter} entities
+     *         writing the instance, and (c) the instance has not been
+     *         explicitly disposed (or else more samples have been received
+     *         after it was disposed).</li>
+     *     <li>NOT_ALIVE_DISPOSED indicates the instance was explicitly
+     *         disposed by a DataWriter by means of
+     *         {@link DataWriter#dispose(InstanceHandle)}.</li>
+     *     <li>NOT_ALIVE_NO_WRITERS indicates the instance has been declared
+     *         as not-alive by the {@link DataReader} because it detected
+     *         that there are no live DataWriter entities writing that
+     *         instance.
+     * </ul>
+     * 
+     * The precise behavior events that cause the instanceState to change
+     * depends on the setting of the {@link OwnershipQosPolicy}:
+     * 
+     * <ul>
+     *     <li>If {@link OwnershipQosPolicy#getKind()} is
+     *         {@link OwnershipQosPolicy.Kind#EXCLUSIVE}, then the
+     *         instanceState becomes NOT_ALIVE_DISPOSED only if the
+     *         DataWriter that "owns" the instance explicitly disposes it.
+     *         The instanceState becomes ALIVE again only if the DataWriter
+     *         that owns the instance writes it.</li>
+     *     <li>If {@link OwnershipQosPolicy#getKind()} is
+     *         {@link OwnershipQosPolicy.Kind#SHARED}, then the instanceState
+     *         becomes NOT_ALIVE_DISPOSED if any DataWriter explicitly
+     *         disposes the instance. The instanceState becomes ALIVE as soon
+     *         as any DataWriter writes the instance again.</li>
+     * </ul>
+     * 
+     * The instanceState available in the Sample is a snapshot of the
+     * instanceState of the instance at the time the collection was obtained
+     * (i.e., at the time {@link DataReader#read()} or
+     * {@link DataReader#take()} was called). The instanceState is therefore
+     * the same for all samples in the returned collection that refer to the
+     * same instance.
      */
     public InstanceState getInstanceState();
 
@@ -62,27 +263,139 @@
     public ModifiableInstanceHandle getPublicationHandle();
 
     /**
-     * @return the disposedGenerationCount
+     * For each instance the middleware internally maintains two counts: the
+     * disposedGenerationCount and noWritersGenerationCount, relative to each
+     * {@link DataReader}:
+     * 
+     * <ul>
+     *     <li>The disposedGenerationCount and noWritersGenerationCount are
+     *         initialized to zero when the DataReader first detects the
+     *         presence of a never-seen-before instance.</li>
+     *     <li>The disposedGenerationCount is incremented each time the
+     *         instanceState of the corresponding instance changes from
+     *         NOT_ALIVE_DISPOSED to ALIVE.</li>
+     *     <li>The noWritersGenerationCount is incremented each time the
+     *         instanceState of the corresponding instance changes from
+     *         NOT_ALIVE_NO_WRITERS to ALIVE.</li>
+     * </ul>
+     * 
+     * The disposedGenerationCount and noWritersGenerationCount available in
+     * the Sample capture a snapshot of the corresponding counters at the
+     * time the sample was received.
+     * 
+     * @see     #getNoWritersGenerationCount()
      */
     public int getDisposedGenerationCount();
 
     /**
-     * @return the noWritersGenerationCount
+     * For each instance the middleware internally maintains two counts: the
+     * disposedGenerationCount and noWritersGenerationCount, relative to each
+     * {@link DataReader}:
+     * 
+     * <ul>
+     *     <li>The disposedGenerationCount and noWritersGenerationCount are
+     *         initialized to zero when the DataReader first detects the
+     *         presence of a never-seen-before instance.</li>
+     *     <li>The disposedGenerationCount is incremented each time the
+     *         instanceState of the corresponding instance changes from
+     *         NOT_ALIVE_DISPOSED to ALIVE.</li>
+     *     <li>The noWritersGenerationCount is incremented each time the
+     *         instanceState of the corresponding instance changes from
+     *         NOT_ALIVE_NO_WRITERS to ALIVE.</li>
+     * </ul>
+     * 
+     * The disposedGenerationCount and noWritersGenerationCount available in
+     * the Sample capture a snapshot of the corresponding counters at the
+     * time the sample was received.
+     * 
+     * @see     #getDisposedGenerationCount()
      */
     public int getNoWritersGenerationCount();
 
     /**
-     * @return the sampleRank
+     * The sampleRank and generationRank available in the Sample are computed
+     * based solely on the actual samples in the ordered collection returned
+     * by {@link DataReader#read()} or {@link DataReader#take()}.
+     * 
+     * <ul>
+     *     <li>The sampleRank indicates the number of samples of the same
+     *         instance that follow the current one in the collection.</li>
+     *     <li>The generationRank available in the Sample indicates the
+     *         difference in 'generations' between the sample (S) and the
+     *         Most Recent Sample of the same instance that appears In the
+     *         returned Collection (MRSIC). That is, it counts the number of
+     *         times the instance transitioned from not-alive to alive in the
+     *         time from the reception of S to the reception of MRSIC.</li>
+     * </ul>
+     * 
+     * @see     #getAbsoluteGenerationRank()
+     * @see     #getGenerationRank()
      */
     public int getSampleRank();
 
     /**
-     * @return the generationRank
+     * The sampleRank and generationRank available in the Sample are computed
+     * based solely on the actual samples in the ordered collection returned
+     * by {@link DataReader#read()} or {@link DataReader#take()}.
+     * 
+     * <ul>
+     *     <li>The sampleRank indicates the number of samples of the same
+     *         instance that follow the current one in the collection.</li>
+     *     <li>The generationRank available in the Sample indicates the
+     *         difference in 'generations' between the sample (S) and the
+     *         Most Recent Sample of the same instance that appears In the
+     *         returned Collection (MRSIC). That is, it counts the number of
+     *         times the instance transitioned from not-alive to alive in the
+     *         time from the reception of S to the reception of MRSIC.</li>
+     * </ul>
+     * 
+     * The generationRank is computed using the formula:
+     * 
+     * <code>
+     * generationRank = (MRSIC.disposedGenerationCount
+     *                  + MRSIC.noWritersGenerationCount)
+     *                  - (S.disposedGenerationCount
+     *                  + S.noWritersGenerationCount)
+     * </code>
+     * 
+     * @see     #getAbsoluteGenerationRank()
+     * @see     #getSampleRank()
      */
     public int getGenerationRank();
 
     /**
-     * @return the absoluteGenerationRank
+     * The sampleRank and generationRank available in the Sample are computed
+     * based solely on the actual samples in the ordered collection returned
+     * by {@link DataReader#read()} or {@link DataReader#take()}.
+     * 
+     * <ul>
+     *     <li>The sampleRank indicates the number of samples of the same
+     *         instance that follow the current one in the collection.</li>
+     *     <li>The generationRank available in the Sample indicates the
+     *         difference in 'generations' between the sample (S) and the
+     *         Most Recent Sample of the same instance that appears In the
+     *         returned Collection (MRSIC). That is, it counts the number of
+     *         times the instance transitioned from not-alive to alive in the
+     *         time from the reception of S to the reception of MRSIC.</li>
+     * </ul>
+     * 
+     * The absoluteGenerationRank available in the Sample indicates the
+     * difference in 'generations' between the sample (S) and the Most Recent
+     * Sample of the same instance that the middleware has received (MRS).
+     * That is, it counts the number of times the instance transitioned from
+     * not-alive to alive in the time from the reception of S to the time
+     * when {@link DataReader#read()} or {@link DataReader#take()} was
+     * called.
+     * 
+     * <code>
+     * absoluteGenerationRank = (MRS.disposedGenerationCount
+     *                          + MRS.noWritersGenerationCount)
+     *                          - (S.disposedGenerationCount
+     *                          + S.noWritersGenerationCount)
+     * </code>
+     * 
+     * @see     #getGenerationRank()
+     * @see     #getSampleRank()
      */
     public int getAbsoluteGenerationRank();
 
@@ -95,8 +408,30 @@
     public static interface Iterator<IT_DATA>
     extends ListIterator<Sample<IT_DATA>> {
         /**
-         * The samples provided by this iterator have been loaned from a
-         * pool maintained by the Service; return that loan now.
+         * This operation indicates to that the application is done accessing
+         * the list of Samples obtained by some earlier invocation of
+         * {@link DataReader#read()} or {@link DataReader#take()}.
+         * 
+         * The operation allows implementations to "loan" buffers from the
+         * DataReader to the application and in this manner provide
+         * "zero-copy" access to the data. During the loan, the DataReader
+         * will guarantee that the data and sample information are not
+         * modified.
+         * 
+         * It is not necessary for an application to return the loans
+         * immediately after the read or take calls. However, as these
+         * buffers correspond to internal resources inside the DataReader,
+         * the application should not retain them indefinitely.
+         * 
+         * The use of the operation is only necessary if the read or take
+         * calls "loaned" buffers to the application. The situations in which
+         * this occurs are described in the documentation for
+         * {@link DataReader#read()} and {@link DataReader#take()}. However,
+         * calling returnLoan on a collection that does not have a loan is
+         * safe and has no side effects.
+         * 
+         * @see DataReader#read()
+         * @see DataReader#take()
          */
         public void returnLoan();
 
Index: ftf_vote_01/srcJava/org/omg/dds/sub/ReadCondition.java
===================================================================
--- ftf_vote_01/srcJava/org/omg/dds/sub/ReadCondition.java	(revision 139)
+++ ftf_vote_01/srcJava/org/omg/dds/sub/ReadCondition.java	(working copy)
@@ -21,25 +21,98 @@
 import java.util.Set;
 
 import org.omg.dds.core.Condition;
+import org.omg.dds.core.StatusCondition;
+import org.omg.dds.core.WaitSet;
 
 
+/**
+ * ReadCondition objects are conditions specifically dedicated to read
+ * operations and attached to one {@link DataReader}.
+ * 
+ * ReadCondition objects allow an application to specify the data samples it
+ * is interested in by specifying the desired sample states, view states,
+ * and instance states. (See the parameter definitions for
+ * {@link DataReader#read(java.util.Collection, java.util.Collection, java.util.Collection)}
+ * and
+ * {@link DataReader#take(java.util.Collection, java.util.Collection, java.util.Collection)}.)
+ * This allows the middleware to enable the condition only when suitable
+ * information is available. They are to be used in conjunction with a
+ * {@link WaitSet} as normal conditions. More than one ReadCondition may be
+ * attached to the same DataReader.
+ * 
+ * Similar to the {@link StatusCondition}, a ReadCondition also has a
+ * triggerValue that determines whether the attached {@link WaitSet} is
+ * BLOCKED or UNBLOCKED. However, unlike the StatusCondition, the
+ * triggerValue of the ReadCondition is tied to the presence of at least a
+ * sample managed by the Service with {@link SampleState}, {@link ViewState},
+ * and {@link InstanceState} matching those of the ReadCondition.
+ * 
+ * The fact that the triggerValue of a ReadCondition is dependent on the
+ * presence of samples on the associated DataReader implies that a single
+ * {@link DataReader#take()} operation can potentially change the
+ * triggerValue of several ReadCondition or {@link QueryCondition}
+ * conditions. For example, if all samples are taken, any ReadCondition and
+ * QueryCondition conditions associated with the DataReader that had their
+ * triggerValue == true before will see the triggerValue change to false.
+ * Note that this does not guarantee that WaitSet objects that were
+ * separately attached to those conditions will not be woken up. Once we have
+ * triggerValue == true on a condition it may wake up the attached WaitSet,
+ * the condition transitioning to triggerValue == false does not necessarily
+ * 'unwakeup' the WaitSet as 'unwakening' may not be possible in general. The
+ * consequence is that an application blocked on a WaitSet may return from
+ * the wait with a list of conditions. some of which are no longer "active."
+ * This is unavoidable if multiple threads are concurrently waiting on
+ * separate WaitSet objects and taking data associated with the same
+ * DataReader entity.
+ * 
+ * To elaborate further, consider the following example: A ReadCondition that
+ * has a sample state collection of {NOT_READ} will have triggerValue of true
+ * whenever a new sample arrives and will transition to false as soon as all
+ * the newly-arrived samples are either read (so their status changes to
+ * {@link SampleState#READ}) or taken (so they are no longer managed by the
+ * Service). However if the same ReadCondition had a sample_statesample state
+ * collection of {READ, NOT_READ}, then the triggerValue would only become
+ * false once all the newly-arrived samples are taken (it is not sufficient
+ * to read them as that would only change the SampleState to READ, which
+ * overlaps the collection on the ReadCondition.
+ * 
+ * @param <TYPE>    The concrete type of the data that can be read using the
+ *                  the {@link DataReader} that created this ReadCondition.
+ */
 public interface ReadCondition<TYPE>
 extends Condition {
     /**
+     * This operation returns the set of sample states that are taken into
+     * account to determine the triggerValue of the ReadCondition. These are
+     * the sample states specified when the ReadCondition was created.
+     * 
      * @return  an unmodifiable set.
      */
     public Set<SampleState> getSampleStates();
 
     /**
+     * This operation returns the set of view states that are taken into
+     * account to determine the triggerValue of the ReadCondition. These are
+     * the view states specified when the ReadCondition was created.
+     * 
      * @return  an unmodifiable set.
      */
     public Set<ViewState> getViewStates();
 
     /**
+     * This operation returns the set of instance states that are taken into
+     * account to determine the triggerValue of the ReadCondition. These are
+     * the instance states specified when the ReadCondition was created.
+     * 
      * @return  an unmodifiable set.
      */
     public Set<InstanceState> getInstanceStates();
 
+    /**
+     * @return  the DataReader associated with the ReadCondition. Note that
+     *          there is exactly one DataReader associated with each
+     *          ReadCondition.
+     */
     public DataReader<TYPE> getDataReader();
 
     /**
Index: ftf_vote_01/srcJava/org/omg/dds/sub/DataReader.java
===================================================================
--- ftf_vote_01/srcJava/org/omg/dds/sub/DataReader.java	(revision 139)
+++ ftf_vote_01/srcJava/org/omg/dds/sub/DataReader.java	(working copy)
@@ -26,17 +26,69 @@
 import org.omg.dds.core.DomainEntity;
 import org.omg.dds.core.Duration;
 import org.omg.dds.core.InstanceHandle;
+import org.omg.dds.core.NotEnabledException;
+import org.omg.dds.core.PreconditionNotMetException;
 import org.omg.dds.core.modifiable.ModifiableInstanceHandle;
+import org.omg.dds.core.policy.DurabilityQosPolicy;
+import org.omg.dds.core.policy.HistoryQosPolicy;
 import org.omg.dds.core.status.LivelinessChangedStatus;
 import org.omg.dds.core.status.RequestedDeadlineMissedStatus;
 import org.omg.dds.core.status.RequestedIncompatibleQosStatus;
 import org.omg.dds.core.status.SampleLostStatus;
 import org.omg.dds.core.status.SampleRejectedStatus;
 import org.omg.dds.core.status.SubscriptionMatchedStatus;
+import org.omg.dds.domain.DomainParticipant;
+import org.omg.dds.topic.ContentFilteredTopic;
+import org.omg.dds.topic.MultiTopic;
 import org.omg.dds.topic.PublicationBuiltinTopicData;
+import org.omg.dds.topic.Topic;
 import org.omg.dds.topic.TopicDescription;
 
 
+/**
+ * A DataReader allows the application (1) to declare the data it wishes to
+ * receive (i.e., make a subscription) and (2) to access the data received by
+ * the attached {@link Subscriber}.
+ * 
+ * A DataReader refers to exactly one {@link TopicDescription} (either a
+ * {@link Topic}, a {@link ContentFilteredTopic}, or a {@link MultiTopic})
+ * that identifies the data to be read. The subscription has a unique
+ * resulting type. The data reader may give access to several instances of
+ * the resulting type, which can be distinguished from each other by their
+ * keys.
+ * 
+ * All operations except for the inherited operations
+ * {@link #setQos(org.omg.dds.core.EntityQos)}, {@link #getQos()},
+ * {@link #setListener(java.util.EventListener)}, {@link #getListener()},
+ * {@link #enable()}, {@link #getStatusCondition()}, and {@link #close()} may
+ * fail with the exception {@link NotEnabledException}.
+ * 
+ * All sample-accessing operations, namely all variants of {@link #read()} or
+ * {@link #take()}, may fail with the exception
+ * {@link PreconditionNotMetException}.
+ * 
+ * <b>Access to the Data</b>
+ * 
+ * Data is made available to the application by the following operations on
+ * DataReader objects: {@link #read()}, {@link #take()}, and the other methods
+ * beginning with those prefixes.. The general semantics of the "read"
+ * operations is that the application only gets access to the corresponding
+ * data; the data remains the middleware's responsibility and can be read
+ * again. The semantics of the "take" operations is that the application
+ * takes full responsibility for the data; that data will no longer be
+ * accessible to the DataReader. Consequently, it is possible for a
+ * DataReader to access the same sample multiple times but only if all
+ * previous accesses were read operations.
+ * 
+ * Each of these operations returns an ordered collection of {@link Sample}s
+ * (data values and associated meta-information). Each data value represents
+ * an atom of data information (i.e., a value for one instance). This
+ * collection may contain samples related to the same or different instances
+ * (identified by the key). Multiple samples can refer to the same instance
+ * if the settings of the {@link HistoryQosPolicy} allow for it.
+ * 
+ * @param <TYPE>    The concrete type of the data to be read.
+ */
 public interface DataReader<TYPE>
 extends DomainEntity<DataReader<TYPE>,
                      Subscriber,
@@ -59,14 +111,56 @@
     public <OTHER> DataReader<OTHER> cast();
 
     public ReadCondition<TYPE> createReadCondition();
+
+    /**
+     * This operation creates a ReadCondition. The returned ReadCondition
+     * will be attached and belong to the DataReader.
+     * 
+     * @param   sampleStates    The returned condition will only trigger on
+     *          samples with one of these sample states.
+     * @param   viewStates      The returned condition will only trigger on
+     *          samples with one of these view states.
+     * @param   instanceStates  The returned condition will only trigger on
+     *          samples with one of these instance states.
+     */
     public ReadCondition<TYPE> createReadCondition(
             Collection<SampleState> sampleStates,
             Collection<ViewState> viewStates,
             Collection<InstanceState> instanceStates);
 
+    /**
+     * This operation creates a QueryCondition. The returned QueryCondition
+     * will be attached and belong to the DataReader. It will trigger on any
+     * sample state, view state, or instance state.
+     * 
+     * @param   queryExpression The returned condition will only trigger on
+     *          samples that pass this content-based filter expression.
+     * @param   queryParameters A set of parameter values for the
+     *          queryExpression.
+     *
+     * @see     #createQueryCondition(Collection, Collection, Collection, String, List)
+     */
     public QueryCondition<TYPE> createQueryCondition(
             String queryExpression,
             List<String> queryParameters);
+
+    /**
+     * This operation creates a QueryCondition. The returned QueryCondition
+     * will be attached and belong to the DataReader.
+     * 
+     * @param   sampleStates    The returned condition will only trigger on
+     *          samples with one of these sample states.
+     * @param   viewStates      The returned condition will only trigger on
+     *          samples with one of these view states.
+     * @param   instanceStates  The returned condition will only trigger on
+     *          samples with one of these instance states.
+     * @param   queryExpression The returned condition will only trigger on
+     *          samples that pass this content-based filter expression.
+     * @param   queryParameters A set of parameter values for the
+     *          queryExpression.
+     *
+     * @see     #createQueryCondition(String, List)
+     */
     public QueryCondition<TYPE> createQueryCondition(
             Collection<SampleState> sampleStates,
             Collection<ViewState> viewStates,
@@ -74,38 +168,200 @@
             String queryExpression,
             List<String> queryParameters);
 
+    /**
+     * This operation closes all the entities that were created by means of
+     * the "create" operations on the DataReader. That is, it closes all
+     * contained ReadCondition and QueryCondition objects.
+     * 
+     * @throws  PreconditionNotMetException     if the any of the contained
+     *          entities is in a state where it cannot be closed.
+     */
     public void closeContainedEntities();
 
+    /**
+     * @return  the TopicDescription associated with the DataReader. This is
+     *          the same TopicDescription that was used to create the
+     *          DataReader.
+     */
     public TopicDescription<TYPE> getTopicDescription();
 
+    /**
+     * This operation allows access to the SAMPLE_REJECTED communication
+     * status.
+     * 
+     * @param   status  a container, into which this method places it result.
+     * @return  the input status, as a convenience to facilitate chaining.
+     * 
+     * @see     org.omg.dds.core.status
+     */
     public SampleRejectedStatus<TYPE> getSampleRejectedStatus(
             SampleRejectedStatus<TYPE> status);
 
+    /**
+     * This operation allows access to the LIVELINESS_CHANGED communication
+     * status.
+     * 
+     * @param   status  a container, into which this method places it result.
+     * @return  the input status, as a convenience to facilitate chaining.
+     * 
+     * @see     org.omg.dds.core.status
+     */
     public LivelinessChangedStatus<TYPE> getLivelinessChangedStatus(
             LivelinessChangedStatus<TYPE> status);
 
+    /**
+     * This operation allows access to the REQUESTED_DEADLINE_MISSED
+     * communication status.
+     * 
+     * @param   status  a container, into which this method places it result.
+     * @return  the input status, as a convenience to facilitate chaining.
+     * 
+     * @see     org.omg.dds.core.status
+     */
     public RequestedDeadlineMissedStatus<TYPE>
     getRequestedDeadlineMissedStatus(
             RequestedDeadlineMissedStatus<TYPE> status);
 
+    /**
+     * This operation allows access to the REQUESTED_INCOMPATIBLE_QOS
+     * communication status.
+     * 
+     * @param   status  a container, into which this method places it result.
+     * @return  the input status, as a convenience to facilitate chaining.
+     * 
+     * @see     org.omg.dds.core.status
+     */
     public RequestedIncompatibleQosStatus<TYPE>
     getRequestedIncompatibleQosStatus(
             RequestedIncompatibleQosStatus<TYPE> status);
 
+    /**
+     * This operation allows access to the SUBSCRIPTION_MATCHED communication
+     * status. 
+     * 
+     * @param   status  a container, into which this method places it result.
+     * @return  the input status, as a convenience to facilitate chaining.
+     * 
+     * @see     org.omg.dds.core.status
+     */
     public SubscriptionMatchedStatus<TYPE> getSubscriptionMatchedStatus(
             SubscriptionMatchedStatus<TYPE> status);
 
+    /**
+     * This operation allows access to the SAMPLE_LOST communication status.
+     * 
+     * @param   status  a container, into which this method places its
+     *          result.
+     * @return  the input status, as a convenience to facilitate chaining.
+     * 
+     * @see     org.omg.dds.core.status
+     */
     public SampleLostStatus<TYPE> getSampleLostStatus(
             SampleLostStatus<TYPE> status);
 
+    /**
+     * This operation is intended only for DataReader entities for which
+     * {@link DurabilityQosPolicy#getKind()} is not
+     * {@link DurabilityQosPolicy.Kind#VOLATILE}.
+     * 
+     * As soon as an application enables a non-VOLATILE DataReader it will
+     * start receiving both "historical" data, i.e., the data that was
+     * written prior to the time the DataReader joined the domain, as well as
+     * any new data written by the DataWriter entities. There are situations
+     * where the application logic may require the application to wait until
+     * all "historical" data is received. This is the purpose of this
+     * operation.
+     * 
+     * The operation blocks the calling thread until either all "historical"
+     * data is received, or else the duration specified by the max_Wait
+     * parameter elapses, whichever happens first.
+     * 
+     * @throws  TimeoutException        if maxWait elapsed before all the
+     *          data was received.
+     * 
+     * @see     #waitForHistoricalData(long, TimeUnit)
+     */
     public void waitForHistoricalData(Duration maxWait)
     throws TimeoutException;
 
+    /**
+     * This operation is intended only for DataReader entities for which
+     * {@link DurabilityQosPolicy#getKind()} is not
+     * {@link DurabilityQosPolicy.Kind#VOLATILE}.
+     * 
+     * As soon as an application enables a non-VOLATILE DataReader it will
+     * start receiving both "historical" data, i.e., the data that was
+     * written prior to the time the DataReader joined the domain, as well as
+     * any new data written by the DataWriter entities. There are situations
+     * where the application logic may require the application to wait until
+     * all "historical" data is received. This is the purpose of this
+     * operation.
+     * 
+     * The operation blocks the calling thread until either all "historical"
+     * data is received, or else the duration specified by the max_Wait
+     * parameter elapses, whichever happens first.
+     * 
+     * @throws  TimeoutException        if maxWait elapsed before all the
+     *          data was received.
+     * 
+     * @see     #waitForHistoricalData(Duration)
+     */
     public void waitForHistoricalData(long maxWait, TimeUnit unit)
     throws TimeoutException;
 
+    /**
+     * This operation retrieves the list of publications currently
+     * "associated" with the DataReader; that is, publications that have a
+     * matching {@link Topic} and compatible QoS that the application has not
+     * indicated should be "ignored" by means of
+     * {@link DomainParticipant#ignorePublication(InstanceHandle)}.
+     * 
+     * The handles returned in the 'publicationHandles' list are the ones
+     * that are used by the DDS implementation to locally identify the
+     * corresponding matched DataWriter entities. These handles match the
+     * ones that appear in {@link Sample#getInstanceHandle()} when reading
+     * the "DCPSPublications" built-in topic.
+     * 
+     * The operation may fail if the infrastructure does not locally maintain
+     * the connectivity information.
+     * 
+     * @param   publicationHandles      a container, into which this method
+     *          will place its result.
+     * 
+     * @return  publicationHandles, as a convenience to facilitate chaining.
+     * 
+     * @see     #getMatchedPublicationData(PublicationBuiltinTopicData, InstanceHandle)
+     */
     public Collection<InstanceHandle> getMatchedPublications(
             Collection<InstanceHandle> publicationHandles);
+
+    /**
+     * This operation retrieves information on a publication that is
+     * currently "associated" with the DataReader; that is, a publication
+     * with a matching {@link Topic} and compatible QoS that the application
+     * has not indicated should be "ignored" by means of
+     * {@link DomainParticipant#ignorePublication(InstanceHandle)}.
+     * 
+     * The operation {@link #getMatchedPublications(Collection)} can be used
+     * to find the publications that are currently matched with the
+     * DataReader.
+     * 
+     * @param   publicationData         a container, into which this method
+     *          will place its result.
+     * @param   publicationHandle       a handle to the publication, the
+     *          data of which is to be retrieved.
+     * 
+     * @return  subscriptionData, as a convenience to facilitate chaining.
+     * 
+     * @throws  IllegalArgumentException        if the publicationHandle does
+     *          not correspond to a publication currently associated with the
+     *          DataReader.
+     * @throws  UnsupportedOperationException   if the infrastructure does
+     *          not hold the information necessary to fill in the
+     *          publicationData.
+     *
+     * @see     #getMatchedPublications(Collection)
+     */
     public PublicationBuiltinTopicData getMatchedPublicationData(
             PublicationBuiltinTopicData publicationData,
             InstanceHandle publicationHandle);
@@ -127,6 +383,8 @@
     public Sample<TYPE> createSample();
 
     /**
+     * TODO: Add JavaDoc.
+     * 
      * @return  a non-null unmodifiable iterator over loaned samples.
      */
     public Sample.Iterator<TYPE> read();
@@ -136,11 +394,20 @@
             Collection<InstanceState> instanceStates);
 
     /**
+     * TODO: Add JavaDoc.
+     * 
      * Copy samples into the provided collection, overwriting any samples that
      * might already be present.
      */
     public void read(
             List<Sample<TYPE>> samples);
+
+    /**
+     * TODO: Add JavaDoc.
+     * 
+     * Copy samples into the provided collection, overwriting any samples that
+     * might already be present.
+     */
     public void read(
             List<Sample<TYPE>> samples,
             int maxSamples,
@@ -149,6 +416,8 @@
             Collection<InstanceState> instanceStates);
 
     /**
+     * TODO: Add JavaDoc.
+     * 
      * @return  a non-null unmodifiable iterator over loaned samples.
      */
     public Sample.Iterator<TYPE> take();
@@ -157,8 +426,21 @@
             Collection<ViewState> viewStates, 
             Collection<InstanceState> instanceStates);
 
+    /**
+     * TODO: Add JavaDoc.
+     * 
+     * Copy samples into the provided collection, overwriting any samples that
+     * might already be present.
+     */
     public void take(
             List<Sample<TYPE>> samples);
+
+    /**
+     * TODO: Add JavaDoc.
+     * 
+     * Copy samples into the provided collection, overwriting any samples that
+     * might already be present.
+     */
     public void take(
             List<Sample<TYPE>> samples,
             int maxSamples,
@@ -167,34 +449,66 @@
             Collection<InstanceState> instanceStates);
 
     /**
+     * TODO: Add JavaDoc.
+     * 
      * @return  a non-null unmodifiable iterator over loaned samples.
      */
     public Sample.Iterator<TYPE> read(
             ReadCondition<TYPE> condition);
 
+    /**
+     * TODO: Add JavaDoc.
+     * 
+     * Copy samples into the provided collection, overwriting any samples that
+     * might already be present.
+     */
     public void read(
             List<Sample<TYPE>> samples,
             ReadCondition<TYPE> condition);
+
+    /**
+     * TODO: Add JavaDoc.
+     * 
+     * Copy samples into the provided collection, overwriting any samples that
+     * might already be present.
+     */
     public void read(
             List<Sample<TYPE>> samples,
             int maxSamples,
             ReadCondition<TYPE> condition);
 
     /**
+     * TODO: Add JavaDoc.
+     * 
      * @return  a non-null unmodifiable iterator over loaned samples.
      */
     public Sample.Iterator<TYPE> take(
             ReadCondition<TYPE> condition);
 
+    /**
+     * TODO: Add JavaDoc.
+     * 
+     * Copy samples into the provided collection, overwriting any samples that
+     * might already be present.
+     */
     public void take(
             List<Sample<TYPE>> samples,
             ReadCondition<TYPE> condition);
+
+    /**
+     * TODO: Add JavaDoc.
+     * 
+     * Copy samples into the provided collection, overwriting any samples that
+     * might already be present.
+     */
     public void take(
             List<Sample<TYPE>> samples,
             int maxSamples,
             ReadCondition<TYPE> condition);
 
     /**
+     * TODO: Add JavaDoc.
+     * 
      * @return  true if data was read or false if no data was available.
      */
     public boolean readNext(
@@ -207,19 +521,40 @@
             Sample<TYPE> sample);
 
     /**
+     * TODO: Add JavaDoc.
+     * 
      * @return  a non-null unmodifiable iterator over loaned samples.
      */
     public Sample.Iterator<TYPE> read(
             InstanceHandle handle);
+
+    /**
+     * TODO: Add JavaDoc.
+     * 
+     * @return  a non-null unmodifiable iterator over loaned samples.
+     */
     public Sample.Iterator<TYPE> read(
             InstanceHandle handle,
             Collection<SampleState> sampleStates, 
             Collection<ViewState> viewStates, 
             Collection<InstanceState> instanceStates);
 
+    /**
+     * TODO: Add JavaDoc.
+     * 
+     * Copy samples into the provided collection, overwriting any samples that
+     * might already be present.
+     */
     public void read(
             List<Sample<TYPE>> samples,
             InstanceHandle handle);
+
+    /**
+     * TODO: Add JavaDoc.
+     * 
+     * Copy samples into the provided collection, overwriting any samples that
+     * might already be present.
+     */
     public void read(
             List<Sample<TYPE>> samples,
             InstanceHandle handle,
@@ -229,19 +564,40 @@
             Collection<InstanceState> instanceStates);
 
     /**
+     * TODO: Add JavaDoc.
+     * 
      * @return  a non-null unmodifiable iterator over loaned samples.
      */
     public Sample.Iterator<TYPE> take(
             InstanceHandle handle);
+
+    /**
+     * TODO: Add JavaDoc.
+     * 
+     * @return  a non-null unmodifiable iterator over loaned samples.
+     */
     public Sample.Iterator<TYPE> take(
             InstanceHandle handle,
             Collection<SampleState> sampleStates, 
             Collection<ViewState> viewStates, 
             Collection<InstanceState> instanceStates);
 
+    /**
+     * TODO: Add JavaDoc.
+     * 
+     * Copy samples into the provided collection, overwriting any samples that
+     * might already be present.
+     */
     public void take(
             List<Sample<TYPE>> samples,
             InstanceHandle handle);
+
+    /**
+     * TODO: Add JavaDoc.
+     * 
+     * Copy samples into the provided collection, overwriting any samples that
+     * might already be present.
+     */
     public void take(
             List<Sample<TYPE>> samples,
             InstanceHandle handle,
@@ -251,19 +607,40 @@
             Collection<InstanceState> instanceStates);
 
     /**
+     * TODO: Add JavaDoc.
+     * 
      * @return  a non-null unmodifiable iterator over loaned samples.
      */
     public Sample.Iterator<TYPE> readNext(
             InstanceHandle previousHandle);
+
+    /**
+     * TODO: Add JavaDoc.
+     * 
+     * @return  a non-null unmodifiable iterator over loaned samples.
+     */
     public Sample.Iterator<TYPE> readNext(
             InstanceHandle previousHandle,
             Collection<SampleState> sampleStates, 
             Collection<ViewState> viewStates, 
             Collection<InstanceState> instanceStates);
 
+    /**
+     * TODO: Add JavaDoc.
+     * 
+     * Copy samples into the provided collection, overwriting any samples that
+     * might already be present.
+     */
     public void readNext(
             List<Sample<TYPE>> samples,
             InstanceHandle previousHandle);
+
+    /**
+     * TODO: Add JavaDoc.
+     * 
+     * Copy samples into the provided collection, overwriting any samples that
+     * might already be present.
+     */
     public void readNext(
             List<Sample<TYPE>> samples,
             InstanceHandle previousHandle,
@@ -273,19 +650,40 @@
             Collection<InstanceState> instanceStates);
 
     /**
+     * TODO: Add JavaDoc.
+     * 
      * @return  a non-null unmodifiable iterator over loaned samples.
      */
     public Sample.Iterator<TYPE> takeNext(
             InstanceHandle previousHandle);
+
+    /**
+     * TODO: Add JavaDoc.
+     * 
+     * @return  a non-null unmodifiable iterator over loaned samples.
+     */
     public Sample.Iterator<TYPE> takeNext(
             InstanceHandle previousHandle,
             Collection<SampleState> sampleStates, 
             Collection<ViewState> viewStates, 
             Collection<InstanceState> instanceStates);
 
+    /**
+     * TODO: Add JavaDoc.
+     * 
+     * Copy samples into the provided collection, overwriting any samples that
+     * might already be present.
+     */
     public void takeNext(
             List<Sample<TYPE>> samples,
             InstanceHandle previousHandle);
+
+    /**
+     * TODO: Add JavaDoc.
+     * 
+     * Copy samples into the provided collection, overwriting any samples that
+     * might already be present.
+     */
     public void takeNext(
             List<Sample<TYPE>> samples,
             InstanceHandle previousHandle,
@@ -295,16 +693,31 @@
             Collection<InstanceState> instanceStates);
 
     /**
+     * TODO: Add JavaDoc.
+     * 
      * @return  a non-null unmodifiable iterator over loaned samples.
      */
     public Sample.Iterator<TYPE> readNext(
             InstanceHandle previousHandle,
             ReadCondition<TYPE> condition);
 
+    /**
+     * TODO: Add JavaDoc.
+     * 
+     * Copy samples into the provided collection, overwriting any samples that
+     * might already be present.
+     */
     public void readNext(
             List<Sample<TYPE>> samples,
             InstanceHandle previousHandle,
             ReadCondition<TYPE> condition);
+
+    /**
+     * TODO: Add JavaDoc.
+     * 
+     * Copy samples into the provided collection, overwriting any samples that
+     * might already be present.
+     */
     public void readNext(
             List<Sample<TYPE>> samples,
             InstanceHandle previousHandle,
@@ -312,26 +725,77 @@
             ReadCondition<TYPE> condition);
 
     /**
+     * TODO: Add JavaDoc.
+     * 
      * @return  a non-null unmodifiable iterator over loaned samples.
      */
     public Sample.Iterator<TYPE> takeNext(
             InstanceHandle previousHandle,
             ReadCondition<TYPE> condition);
 
+    /**
+     * TODO: Add JavaDoc.
+     * 
+     * Copy samples into the provided collection, overwriting any samples that
+     * might already be present.
+     */
     public void takeNext(
             List<Sample<TYPE>> samples,
             InstanceHandle previousHandle,
             ReadCondition<TYPE> condition);
+
+    /**
+     * TODO: Add JavaDoc.
+     * 
+     * Copy samples into the provided collection, overwriting any samples that
+     * might already be present.
+     */
     public void takeNext(
             List<Sample<TYPE>> samples,
             InstanceHandle previousHandle,
             int maxSamples,
             ReadCondition<TYPE> condition);
 
+    /**
+     * This operation can be used to retrieve the instance key that
+     * corresponds to an instance handle. The operation will only fill the
+     * fields that form the key inside the keyHolder instance.
+     * 
+     * @param   keyHolder       a container, into which this method shall
+     *          place its result.
+     * @param   handle          a handle indicating the instance whose value
+     *          this method should get.
+     *
+     * @return  keyHolder, as a convenience to facilitate chaining.
+     * 
+     * @throws  IllegalArgumentException        if the {@link InstanceHandle}
+     *          does not correspond to an existing data object known to the
+     *          DataReader. If the implementation is not able to check
+     *          invalid handles, then the result in this situation is
+     *          unspecified.
+     */
     public TYPE getKeyValue(
             TYPE keyHolder, 
             InstanceHandle handle);
 
+    /**
+     * This operation takes as a parameter an instance and returns a handle
+     * that can be used in subsequent operations that accept an instance
+     * handle as an argument. The instance parameter is only used for the
+     * purpose of examining the fields that define the key.
+     * 
+     * This operation does not register the instance in question. If the
+     * instance has not been previously registered, or if for any other
+     * reason the Service is unable to provide an instance handle, the
+     * Service will return a nil handle.
+     * 
+     * @param   handle  a container, into which this method shall place its
+     *          result.
+     * @param   keyHolder       a sample of the instance whose handle this
+     *          method should look up.
+     *
+     * @return  handle, as a convenience to facilitate chaining.
+     */
     public ModifiableInstanceHandle lookupInstance(
             ModifiableInstanceHandle handle,
             TYPE keyHolder);
Index: ftf_vote_01/srcJava/org/omg/dds/topic/TopicDescription.java
===================================================================
--- ftf_vote_01/srcJava/org/omg/dds/topic/TopicDescription.java	(revision 139)
+++ ftf_vote_01/srcJava/org/omg/dds/topic/TopicDescription.java	(working copy)
@@ -19,7 +19,10 @@
 package org.omg.dds.topic;
 
 import org.omg.dds.core.DDSObject;
+import org.omg.dds.core.Entity;
 import org.omg.dds.domain.DomainParticipant;
+import org.omg.dds.pub.DataWriter;
+import org.omg.dds.sub.DataReader;
 import org.omg.dds.type.TypeSupport;
 
 
@@ -54,13 +57,32 @@
      */
     public <OTHER> TopicDescription<OTHER> cast();
 
+    /**
+     * @return  the type name used to create the TopicDescription.
+     */
     public String getTypeName();
+
+    /**
+     * @return  the name used to create the TopicDescription.
+     */
     public String getName();
 
+    /**
+     * @return  the {@link DomainParticipant} to which the TopicDescription
+     *          belongs.
+     */
     public DomainParticipant getParent();
 
     /**
      * Dispose the resources held by this object.
+     * 
+     * A TopicDescription cannot be closed if it is in use by any
+     * {@link DataWriter}s or {@link DataReader}s. With respect to
+     * {@link Topic}s specifically: a Topic cannot be closed if it has any
+     * remaining {@link ContentFilteredTopic}s or {@link MultiTopic}s related
+     * to it.
+     * 
+     * @see     Entity#close()
      */
     public void close();
 }
Index: ftf_vote_01/srcJava/org/omg/dds/topic/TopicListener.java
===================================================================
--- ftf_vote_01/srcJava/org/omg/dds/topic/TopicListener.java	(revision 139)
+++ ftf_vote_01/srcJava/org/omg/dds/topic/TopicListener.java	(working copy)
@@ -20,9 +20,18 @@
 
 import java.util.EventListener;
 
+import org.omg.dds.core.Entity;
 import org.omg.dds.core.status.InconsistentTopicStatus;
 
 
+/**
+ * Since {@link Topic} is a kind of {@link Entity}, it has the ability to
+ * have an associated listener. In this case, the associated listener must be
+ * of concrete type TopicListener.
+ * 
+ * @param <TYPE>    The concrete type of the data published and/or subscribed
+ *                  by the readers and writers that use to topic.
+ */
 public interface TopicListener<TYPE> extends EventListener {
     public void onInconsistentTopic(
             InconsistentTopicStatus<TYPE> status);
Index: ftf_vote_01/srcJava/org/omg/dds/topic/ContentFilteredTopic.java
===================================================================
--- ftf_vote_01/srcJava/org/omg/dds/topic/ContentFilteredTopic.java	(revision 139)
+++ ftf_vote_01/srcJava/org/omg/dds/topic/ContentFilteredTopic.java	(working copy)
@@ -48,14 +48,38 @@
  *                  topic description.
  */
 public interface ContentFilteredTopic<TYPE> extends TopicDescription<TYPE> {
+    /**
+     * @return  the filter expression associated with the
+     *          ContentFilteredTopic, that is, the expression specified when
+     *          the ContentFilteredTopic was created.
+     */
     public String getFilterExpression();
 
     /**
+     * This operation returns the expression parameters associated with the
+     * ContentFilteredTopic, that is, the parameters specified on the last
+     * successful call to {@link #setExpressionParameters(List)}, or if
+     * {@link #setExpressionParameters(List)} was never called, the
+     * parameters specified when the ContentFilteredTopic was created.
+     * 
      * @return  an unmodifiable list.
+     * 
+     * @see     #setExpressionParameters(List)
      */
     public List<String> getExpressionParameters();
 
+    /**
+     * This operation changes the expression parameters associated with the
+     * ContentFilteredTopic.
+     * 
+     * @see     #getExpressionParameters()
+     */
     public void setExpressionParameters(List<String> expressionParameters);
 
+    /**
+     * @return  the {@link Topic} associated with the ContentFilteredTopic,
+     *          that is, the Topic specified when the ContentFilteredTopic
+     *          was created.
+     */
     public Topic<? extends TYPE> getRelatedTopic();
 }
Index: ftf_vote_01/srcJava/org/omg/dds/topic/MultiTopic.java
===================================================================
--- ftf_vote_01/srcJava/org/omg/dds/topic/MultiTopic.java	(revision 139)
+++ ftf_vote_01/srcJava/org/omg/dds/topic/MultiTopic.java	(working copy)
@@ -78,12 +78,31 @@
  *                  topic description.
  */
 public interface MultiTopic<TYPE> extends TopicDescription<TYPE> {
+    /**
+     * @return  the subscription expression associated with the MultiTopic, 
+     *          that is, the expression specified when the MultiTopic was
+     *          created.
+     */
     public String getSubscriptionExpression();
 
     /**
+     * This operation returns the expression parameters associated with the
+     * MultiTopic, that is, the parameters specified on the last successful
+     * call to {@link #setExpressionParameters(List)}, or if
+     * {@link #setExpressionParameters(List)} was never called, the
+     * parameters specified when the MultiTopic was created.
+     * 
      * @return  an unmodifiable list.
+     * 
+     * @see     #setExpressionParameters(List)
      */
     public List<String> getExpressionParameters();
 
+    /**
+     * This operation changes the expression parameters associated with the
+     * MultiTopic.
+     * 
+     * @see     #getExpressionParameters()
+     */
     public void setExpressionParameters(List<String> expressionParameters);
 }
Index: ftf_vote_01/srcJava/org/omg/dds/topic/Topic.java
===================================================================
--- ftf_vote_01/srcJava/org/omg/dds/topic/Topic.java	(revision 139)
+++ ftf_vote_01/srcJava/org/omg/dds/topic/Topic.java	(working copy)
@@ -20,8 +20,10 @@
 
 import org.omg.dds.core.DomainEntity;
 import org.omg.dds.core.NotEnabledException;
+import org.omg.dds.core.StatusCondition;
 import org.omg.dds.core.status.InconsistentTopicStatus;
 import org.omg.dds.domain.DomainParticipant;
+import org.omg.dds.pub.DataWriter;
 
 
 /**
@@ -31,12 +33,13 @@
  * A Topic is identified by its name, which must be unique in the whole
  * Domain.
  * 
- * Topic is the only TopicDescription that can be used for publications and
- * therefore associated to a {@link DataWriter}. All operations except for
- * the inherited operations {@link #setQos(org.omg.dds.core.EntityQos)},
+ * Topic is the only {@link TopicDescription} that can be used for
+ * publications and therefore associated to a {@link DataWriter}. All
+ * operations except for the inherited operations
+ * {@link #setQos(org.omg.dds.core.EntityQos)},
  * {@link #getQos()}, {@link #setListener(java.util.EventListener)},
- * {@link #getListener()}, {@link #enable()}, and
- * {@link #getStatusCondition()} may fail with the exception
+ * {@link #getListener()}, {@link #enable()}, {@link #getStatusCondition()},
+ * and {@link #close()} may fail with the exception
  * {@link NotEnabledException}.
  *
  * @param <TYPE>    The concrete type of the data that will be published and/
@@ -48,6 +51,18 @@
                                              DomainParticipant,
                                              TopicListener<TYPE>,
                                              TopicQos> {
+    /**
+     * This method allows the application to retrieve the
+     * {@link InconsistentTopicStatus} of the Topic.
+     * 
+     * Each {@link DomainEntity} has a set of relevant communication
+     * statuses. A change of status causes the corresponding Listener to be
+     * invoked and can also be monitored by means of the associated
+     * {@link StatusCondition}.
+     * 
+     * @see     TopicListener
+     * @see     StatusCondition
+     */
     public InconsistentTopicStatus<TYPE> getInconsistentTopicStatus(
             InconsistentTopicStatus<TYPE> status);
 }
